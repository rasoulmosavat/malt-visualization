{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _routingTable = _interopRequireDefault(require(\"./routing-table\"));\n\nvar _routingUtil = _interopRequireDefault(require(\"./routing-util\"));\n\nvar _error = require(\"../error\");\n/**\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar Rediscovery = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * @param {RoutingUtil} routingUtil the util to use.\n   */\n  function Rediscovery(routingUtil) {\n    (0, _classCallCheck2[\"default\"])(this, Rediscovery);\n    this._routingUtil = routingUtil;\n  }\n  /**\n   * Try to fetch new routing table from the given router.\n   * @param {Session} session the session to use.\n   * @param {string} database the database for which to lookup routing table.\n   * @param {string} routerAddress the URL of the router.\n   * @return {Promise<RoutingTable>} promise resolved with new routing table or null when connection error happened.\n   */\n\n\n  (0, _createClass2[\"default\"])(Rediscovery, [{\n    key: \"lookupRoutingTableOnRouter\",\n    value: function () {\n      var _lookupRoutingTableOnRouter = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(session, database, routerAddress) {\n        var records, record, expirationTime, _this$_routingUtil$pa, routers, readers, writers;\n\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._routingUtil.callRoutingProcedure(session, database, routerAddress);\n\n              case 2:\n                records = _context.sent;\n\n                if (!(records === null)) {\n                  _context.next = 5;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", null);\n\n              case 5:\n                if (!(records.length !== 1)) {\n                  _context.next = 7;\n                  break;\n                }\n\n                throw (0, _error.newError)('Illegal response from router \"' + routerAddress + '\". ' + 'Received ' + records.length + ' records but expected only one.\\n' + JSON.stringify(records), _error.PROTOCOL_ERROR);\n\n              case 7:\n                record = records[0];\n                expirationTime = this._routingUtil.parseTtl(record, routerAddress);\n                _this$_routingUtil$pa = this._routingUtil.parseServers(record, routerAddress), routers = _this$_routingUtil$pa.routers, readers = _this$_routingUtil$pa.readers, writers = _this$_routingUtil$pa.writers;\n\n                Rediscovery._assertNonEmpty(routers, 'routers', routerAddress);\n\n                Rediscovery._assertNonEmpty(readers, 'readers', routerAddress); // case with no writers is processed higher in the promise chain because only RoutingDriver knows\n                // how to deal with such table and how to treat router that returned such table\n\n\n                return _context.abrupt(\"return\", new _routingTable[\"default\"]({\n                  database: database,\n                  routers: routers,\n                  readers: readers,\n                  writers: writers,\n                  expirationTime: expirationTime\n                }));\n\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function lookupRoutingTableOnRouter(_x, _x2, _x3) {\n        return _lookupRoutingTableOnRouter.apply(this, arguments);\n      }\n\n      return lookupRoutingTableOnRouter;\n    }()\n  }], [{\n    key: \"_assertNonEmpty\",\n    value: function _assertNonEmpty(serverAddressesArray, serversName, routerAddress) {\n      if (serverAddressesArray.length === 0) {\n        throw (0, _error.newError)('Received no ' + serversName + ' from router ' + routerAddress, _error.PROTOCOL_ERROR);\n      }\n    }\n  }]);\n  return Rediscovery;\n}();\n\nexports[\"default\"] = Rediscovery;","map":{"version":3,"sources":["d:/webback/pro5/node_modules/neo4j-driver/lib/internal/rediscovery.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","_regenerator","_asyncToGenerator2","_classCallCheck2","_createClass2","_routingTable","_routingUtil","_error","Rediscovery","routingUtil","key","_lookupRoutingTableOnRouter","mark","_callee","session","database","routerAddress","records","record","expirationTime","_this$_routingUtil$pa","routers","readers","writers","wrap","_callee$","_context","prev","next","callRoutingProcedure","sent","abrupt","length","newError","JSON","stringify","PROTOCOL_ERROR","parseTtl","parseServers","_assertNonEmpty","stop","lookupRoutingTableOnRouter","_x","_x2","_x3","apply","arguments","serverAddressesArray","serversName"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _routingTable = _interopRequireDefault(require(\"./routing-table\"));\n\nvar _routingUtil = _interopRequireDefault(require(\"./routing-util\"));\n\nvar _error = require(\"../error\");\n\n/**\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar Rediscovery =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @constructor\n   * @param {RoutingUtil} routingUtil the util to use.\n   */\n  function Rediscovery(routingUtil) {\n    (0, _classCallCheck2[\"default\"])(this, Rediscovery);\n    this._routingUtil = routingUtil;\n  }\n  /**\n   * Try to fetch new routing table from the given router.\n   * @param {Session} session the session to use.\n   * @param {string} database the database for which to lookup routing table.\n   * @param {string} routerAddress the URL of the router.\n   * @return {Promise<RoutingTable>} promise resolved with new routing table or null when connection error happened.\n   */\n\n\n  (0, _createClass2[\"default\"])(Rediscovery, [{\n    key: \"lookupRoutingTableOnRouter\",\n    value: function () {\n      var _lookupRoutingTableOnRouter = (0, _asyncToGenerator2[\"default\"])(\n      /*#__PURE__*/\n      _regenerator[\"default\"].mark(function _callee(session, database, routerAddress) {\n        var records, record, expirationTime, _this$_routingUtil$pa, routers, readers, writers;\n\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._routingUtil.callRoutingProcedure(session, database, routerAddress);\n\n              case 2:\n                records = _context.sent;\n\n                if (!(records === null)) {\n                  _context.next = 5;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", null);\n\n              case 5:\n                if (!(records.length !== 1)) {\n                  _context.next = 7;\n                  break;\n                }\n\n                throw (0, _error.newError)('Illegal response from router \"' + routerAddress + '\". ' + 'Received ' + records.length + ' records but expected only one.\\n' + JSON.stringify(records), _error.PROTOCOL_ERROR);\n\n              case 7:\n                record = records[0];\n                expirationTime = this._routingUtil.parseTtl(record, routerAddress);\n                _this$_routingUtil$pa = this._routingUtil.parseServers(record, routerAddress), routers = _this$_routingUtil$pa.routers, readers = _this$_routingUtil$pa.readers, writers = _this$_routingUtil$pa.writers;\n\n                Rediscovery._assertNonEmpty(routers, 'routers', routerAddress);\n\n                Rediscovery._assertNonEmpty(readers, 'readers', routerAddress); // case with no writers is processed higher in the promise chain because only RoutingDriver knows\n                // how to deal with such table and how to treat router that returned such table\n\n\n                return _context.abrupt(\"return\", new _routingTable[\"default\"]({\n                  database: database,\n                  routers: routers,\n                  readers: readers,\n                  writers: writers,\n                  expirationTime: expirationTime\n                }));\n\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function lookupRoutingTableOnRouter(_x, _x2, _x3) {\n        return _lookupRoutingTableOnRouter.apply(this, arguments);\n      }\n\n      return lookupRoutingTableOnRouter;\n    }()\n  }], [{\n    key: \"_assertNonEmpty\",\n    value: function _assertNonEmpty(serverAddressesArray, serversName, routerAddress) {\n      if (serverAddressesArray.length === 0) {\n        throw (0, _error.newError)('Received no ' + serversName + ' from router ' + routerAddress, _error.PROTOCOL_ERROR);\n      }\n    }\n  }]);\n  return Rediscovery;\n}();\n\nexports[\"default\"] = Rediscovery;"]},"metadata":{},"sourceType":"script"}