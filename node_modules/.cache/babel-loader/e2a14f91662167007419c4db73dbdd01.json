{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _poolConfig = _interopRequireDefault(require(\"./pool-config\"));\n\nvar _error = require(\"../error\");\n\nvar _logger = _interopRequireDefault(require(\"./logger\"));\n/**\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar Pool = /*#__PURE__*/function () {\n  /**\n   * @param {function(address: ServerAddress, function(address: ServerAddress, resource: object): Promise<object>): Promise<object>} create\n   *                an allocation function that creates a promise with a new resource. It's given an address for which to\n   *                allocate the connection and a function that will return the resource to the pool if invoked, which is\n   *                meant to be called on .dispose or .close or whatever mechanism the resource uses to finalize.\n   * @param {function(resource: object): Promise<void>} destroy\n   *                called with the resource when it is evicted from this pool\n   * @param {function(resource: object): boolean} validate\n   *                called at various times (like when an instance is acquired and when it is returned.\n   *                If this returns false, the resource will be evicted\n   * @param {function(resource: object, observer: { onError }): void} installIdleObserver\n   *                called when the resource is released back to pool\n   * @param {function(resource: object): void} removeIdleObserver\n   *                called when the resource is acquired from the pool\n   * @param {PoolConfig} config configuration for the new driver.\n   * @param {Logger} log the driver logger.\n   */\n  function Pool() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$create = _ref.create,\n        create = _ref$create === void 0 ? function (address, release) {\n      return Promise.resolve();\n    } : _ref$create,\n        _ref$destroy = _ref.destroy,\n        destroy = _ref$destroy === void 0 ? function (conn) {\n      return Promise.resolve();\n    } : _ref$destroy,\n        _ref$validate = _ref.validate,\n        validate = _ref$validate === void 0 ? function (conn) {\n      return true;\n    } : _ref$validate,\n        _ref$installIdleObser = _ref.installIdleObserver,\n        installIdleObserver = _ref$installIdleObser === void 0 ? function (conn, observer) {} : _ref$installIdleObser,\n        _ref$removeIdleObserv = _ref.removeIdleObserver,\n        removeIdleObserver = _ref$removeIdleObserv === void 0 ? function (conn) {} : _ref$removeIdleObserv,\n        _ref$config = _ref.config,\n        config = _ref$config === void 0 ? _poolConfig[\"default\"].defaultConfig() : _ref$config,\n        _ref$log = _ref.log,\n        log = _ref$log === void 0 ? _logger[\"default\"].noOp() : _ref$log;\n\n    (0, _classCallCheck2[\"default\"])(this, Pool);\n    this._create = create;\n    this._destroy = destroy;\n    this._validate = validate;\n    this._installIdleObserver = installIdleObserver;\n    this._removeIdleObserver = removeIdleObserver;\n    this._maxSize = config.maxSize;\n    this._acquisitionTimeout = config.acquisitionTimeout;\n    this._pools = {};\n    this._acquireRequests = {};\n    this._activeResourceCounts = {};\n    this._release = this._release.bind(this);\n    this._log = log;\n    this._closed = false;\n  }\n  /**\n   * Acquire and idle resource fom the pool or create a new one.\n   * @param {ServerAddress} address the address for which we're acquiring.\n   * @return {Object} resource that is ready to use.\n   */\n\n\n  (0, _createClass2[\"default\"])(Pool, [{\n    key: \"acquire\",\n    value: function acquire(address) {\n      var _this = this;\n\n      return this._acquire(address).then(function (resource) {\n        var key = address.asKey();\n\n        if (resource) {\n          if (_this._maxSize && _this.activeResourceCount(address) >= _this._maxSize) {\n            _this._destroy(resource);\n          } else {\n            resourceAcquired(key, _this._activeResourceCounts);\n\n            if (_this._log.isDebugEnabled()) {\n              _this._log.debug(\"\".concat(resource, \" acquired from the pool \").concat(key));\n            }\n\n            return resource;\n          }\n        } // We're out of resources and will try to acquire later on when an existing resource is released.\n\n\n        var allRequests = _this._acquireRequests;\n        var requests = allRequests[key];\n\n        if (!requests) {\n          allRequests[key] = [];\n        }\n\n        return new Promise(function (resolve, reject) {\n          var request;\n          var timeoutId = setTimeout(function () {\n            // acquisition timeout fired\n            // remove request from the queue of pending requests, if it's still there\n            // request might've been taken out by the release operation\n            var pendingRequests = allRequests[key];\n\n            if (pendingRequests) {\n              allRequests[key] = pendingRequests.filter(function (item) {\n                return item !== request;\n              });\n            }\n\n            if (request.isCompleted()) {// request already resolved/rejected by the release operation; nothing to do\n            } else {\n              // request is still pending and needs to be failed\n              var activeCount = _this.activeResourceCount(address);\n\n              var idleCount = _this.has(address) ? _this._pools[key].length : 0;\n              request.reject((0, _error.newError)(\"Connection acquisition timed out in \".concat(_this._acquisitionTimeout, \" ms. Poos status: Active conn count = \").concat(activeCount, \", Idle conn count = \").concat(idleCount, \".\")));\n            }\n          }, _this._acquisitionTimeout);\n          request = new PendingRequest(key, resolve, reject, timeoutId, _this._log);\n          allRequests[key].push(request);\n        });\n      });\n    }\n    /**\n     * Destroy all idle resources for the given address.\n     * @param {ServerAddress} address the address of the server to purge its pool.\n     * @returns {Promise<void>} A promise that is resolved when the resources are purged\n     */\n\n  }, {\n    key: \"purge\",\n    value: function purge(address) {\n      return this._purgeKey(address.asKey());\n    }\n    /**\n     * Destroy all idle resources in this pool.\n     * @returns {Promise<void>} A promise that is resolved when the resources are purged\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      var _this2 = this;\n\n      this._closed = true;\n      return Promise.all(Object.keys(this._pools).map(function (key) {\n        return _this2._purgeKey(key);\n      }));\n    }\n    /**\n     * Keep the idle resources for the provided addresses and purge the rest.\n     * @returns {Promise<void>} A promise that is resolved when the other resources are purged\n     */\n\n  }, {\n    key: \"keepAll\",\n    value: function keepAll(addresses) {\n      var _this3 = this;\n\n      var keysToKeep = addresses.map(function (a) {\n        return a.asKey();\n      });\n      var keysPresent = Object.keys(this._pools);\n      var keysToPurge = keysPresent.filter(function (k) {\n        return keysToKeep.indexOf(k) === -1;\n      });\n      return Promise.all(keysToPurge.map(function (key) {\n        return _this3._purgeKey(key);\n      }));\n    }\n    /**\n     * Check if this pool contains resources for the given address.\n     * @param {ServerAddress} address the address of the server to check.\n     * @return {boolean} `true` when pool contains entries for the given key, <code>false</code> otherwise.\n     */\n\n  }, {\n    key: \"has\",\n    value: function has(address) {\n      return address.asKey() in this._pools;\n    }\n    /**\n     * Get count of active (checked out of the pool) resources for the given key.\n     * @param {ServerAddress} address the address of the server to check.\n     * @return {number} count of resources acquired by clients.\n     */\n\n  }, {\n    key: \"activeResourceCount\",\n    value: function activeResourceCount(address) {\n      return this._activeResourceCounts[address.asKey()] || 0;\n    }\n  }, {\n    key: \"_acquire\",\n    value: function () {\n      var _acquire2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(address) {\n        var key, pool, resource;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this._closed) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw (0, _error.newError)('Pool is closed, it is no more able to serve requests.');\n\n              case 2:\n                key = address.asKey();\n                pool = this._pools[key];\n\n                if (!pool) {\n                  pool = [];\n                  this._pools[key] = pool;\n                }\n\n              case 5:\n                if (!pool.length) {\n                  _context.next = 16;\n                  break;\n                }\n\n                resource = pool.pop();\n\n                if (!this._validate(resource)) {\n                  _context.next = 12;\n                  break;\n                }\n\n                if (this._removeIdleObserver) {\n                  this._removeIdleObserver(resource);\n                } // idle resource is valid and can be acquired\n\n\n                return _context.abrupt(\"return\", Promise.resolve(resource));\n\n              case 12:\n                _context.next = 14;\n                return this._destroy(resource);\n\n              case 14:\n                _context.next = 5;\n                break;\n\n              case 16:\n                if (!(this._maxSize && this.activeResourceCount(address) >= this._maxSize)) {\n                  _context.next = 18;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", null);\n\n              case 18:\n                _context.next = 20;\n                return this._create(address, this._release);\n\n              case 20:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 21:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _acquire(_x) {\n        return _acquire2.apply(this, arguments);\n      }\n\n      return _acquire;\n    }()\n  }, {\n    key: \"_release\",\n    value: function () {\n      var _release2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2(address, resource) {\n        var _this4 = this;\n\n        var key, pool;\n        return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                key = address.asKey();\n                pool = this._pools[key];\n\n                if (!pool) {\n                  _context2.next = 14;\n                  break;\n                }\n\n                if (this._validate(resource)) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                if (this._log.isDebugEnabled()) {\n                  this._log.debug(\"\".concat(resource, \" destroyed and can't be released to the pool \").concat(key, \" because it is not functional\"));\n                }\n\n                _context2.next = 7;\n                return this._destroy(resource);\n\n              case 7:\n                _context2.next = 12;\n                break;\n\n              case 9:\n                if (this._installIdleObserver) {\n                  this._installIdleObserver(resource, {\n                    onError: function onError(error) {\n                      _this4._log.debug(\"Idle connection \".concat(resource, \" destroyed because of error: \").concat(error));\n\n                      var pool = _this4._pools[key];\n\n                      if (pool) {\n                        _this4._pools[key] = pool.filter(function (r) {\n                          return r !== resource;\n                        });\n                      } // let's not care about background clean-ups due to errors but just trigger the destroy\n                      // process for the resource, we especially catch any errors and ignore them to avoid\n                      // unhandled promise rejection warnings\n\n\n                      _this4._destroy(resource)[\"catch\"](function () {});\n                    }\n                  });\n                }\n\n                pool.push(resource);\n\n                if (this._log.isDebugEnabled()) {\n                  this._log.debug(\"\".concat(resource, \" released to the pool \").concat(key));\n                }\n\n              case 12:\n                _context2.next = 17;\n                break;\n\n              case 14:\n                // key has been purged, don't put it back, just destroy the resource\n                if (this._log.isDebugEnabled()) {\n                  this._log.debug(\"\".concat(resource, \" destroyed and can't be released to the pool \").concat(key, \" because pool has been purged\"));\n                }\n\n                _context2.next = 17;\n                return this._destroy(resource);\n\n              case 17:\n                resourceReleased(key, this._activeResourceCounts);\n\n                this._processPendingAcquireRequests(address);\n\n              case 19:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _release(_x2, _x3) {\n        return _release2.apply(this, arguments);\n      }\n\n      return _release;\n    }()\n  }, {\n    key: \"_purgeKey\",\n    value: function () {\n      var _purgeKey2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee3(key) {\n        var pool, resource;\n        return _regenerator[\"default\"].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                pool = this._pools[key] || [];\n\n              case 1:\n                if (!pool.length) {\n                  _context3.next = 8;\n                  break;\n                }\n\n                resource = pool.pop();\n\n                if (this._removeIdleObserver) {\n                  this._removeIdleObserver(resource);\n                }\n\n                _context3.next = 6;\n                return this._destroy(resource);\n\n              case 6:\n                _context3.next = 1;\n                break;\n\n              case 8:\n                delete this._pools[key];\n\n              case 9:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _purgeKey(_x4) {\n        return _purgeKey2.apply(this, arguments);\n      }\n\n      return _purgeKey;\n    }()\n  }, {\n    key: \"_processPendingAcquireRequests\",\n    value: function _processPendingAcquireRequests(address) {\n      var _this5 = this;\n\n      var key = address.asKey();\n      var requests = this._acquireRequests[key];\n\n      if (requests) {\n        var pendingRequest = requests.shift(); // pop a pending acquire request\n\n        if (pendingRequest) {\n          this._acquire(address)[\"catch\"](function (error) {\n            // failed to acquire/create a new connection to resolve the pending acquire request\n            // propagate the error by failing the pending request\n            pendingRequest.reject(error);\n            return null;\n          }).then(function (resource) {\n            if (resource) {\n              // managed to acquire a valid resource from the pool\n              if (pendingRequest.isCompleted()) {\n                // request has been completed, most likely failed by a timeout\n                // return the acquired resource back to the pool\n                _this5._release(address, resource);\n              } else {\n                // request is still pending and can be resolved with the newly acquired resource\n                resourceAcquired(key, _this5._activeResourceCounts); // increment the active counter\n\n                pendingRequest.resolve(resource); // resolve the pending request with the acquired resource\n              }\n            }\n          });\n        } else {\n          delete this._acquireRequests[key];\n        }\n      }\n    }\n  }]);\n  return Pool;\n}();\n/**\n * Increment active (checked out of the pool) resource counter.\n * @param {string} key the resource group identifier (server address for connections).\n * @param {Object.<string, number>} activeResourceCounts the object holding active counts per key.\n */\n\n\nfunction resourceAcquired(key, activeResourceCounts) {\n  var currentCount = activeResourceCounts[key] || 0;\n  activeResourceCounts[key] = currentCount + 1;\n}\n/**\n * Decrement active (checked out of the pool) resource counter.\n * @param {string} key the resource group identifier (server address for connections).\n * @param {Object.<string, number>} activeResourceCounts the object holding active counts per key.\n */\n\n\nfunction resourceReleased(key, activeResourceCounts) {\n  var currentCount = activeResourceCounts[key] || 0;\n  var nextCount = currentCount - 1;\n\n  if (nextCount > 0) {\n    activeResourceCounts[key] = nextCount;\n  } else {\n    delete activeResourceCounts[key];\n  }\n}\n\nvar PendingRequest = /*#__PURE__*/function () {\n  function PendingRequest(key, resolve, reject, timeoutId, log) {\n    (0, _classCallCheck2[\"default\"])(this, PendingRequest);\n    this._key = key;\n    this._resolve = resolve;\n    this._reject = reject;\n    this._timeoutId = timeoutId;\n    this._log = log;\n    this._completed = false;\n  }\n\n  (0, _createClass2[\"default\"])(PendingRequest, [{\n    key: \"isCompleted\",\n    value: function isCompleted() {\n      return this._completed;\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(resource) {\n      if (this._completed) {\n        return;\n      }\n\n      this._completed = true;\n      clearTimeout(this._timeoutId);\n\n      if (this._log.isDebugEnabled()) {\n        this._log.debug(\"\".concat(resource, \" acquired from the pool \").concat(this._key));\n      }\n\n      this._resolve(resource);\n    }\n  }, {\n    key: \"reject\",\n    value: function reject(error) {\n      if (this._completed) {\n        return;\n      }\n\n      this._completed = true;\n      clearTimeout(this._timeoutId);\n\n      this._reject(error);\n    }\n  }]);\n  return PendingRequest;\n}();\n\nvar _default = Pool;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["d:/webback/pro5/node_modules/neo4j-driver/lib/internal/pool.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","_regenerator","_asyncToGenerator2","_classCallCheck2","_createClass2","_poolConfig","_error","_logger","Pool","_ref","arguments","length","undefined","_ref$create","create","address","release","Promise","resolve","_ref$destroy","destroy","conn","_ref$validate","validate","_ref$installIdleObser","installIdleObserver","observer","_ref$removeIdleObserv","removeIdleObserver","_ref$config","config","defaultConfig","_ref$log","log","noOp","_create","_destroy","_validate","_installIdleObserver","_removeIdleObserver","_maxSize","maxSize","_acquisitionTimeout","acquisitionTimeout","_pools","_acquireRequests","_activeResourceCounts","_release","bind","_log","_closed","key","acquire","_this","_acquire","then","resource","asKey","activeResourceCount","resourceAcquired","isDebugEnabled","debug","concat","allRequests","requests","reject","request","timeoutId","setTimeout","pendingRequests","filter","item","isCompleted","activeCount","idleCount","has","newError","PendingRequest","push","purge","_purgeKey","close","_this2","all","keys","map","keepAll","addresses","_this3","keysToKeep","a","keysPresent","keysToPurge","k","indexOf","_acquire2","mark","_callee","pool","wrap","_callee$","_context","prev","next","pop","abrupt","sent","stop","_x","apply","_release2","_callee2","_this4","_callee2$","_context2","onError","error","r","resourceReleased","_processPendingAcquireRequests","_x2","_x3","_purgeKey2","_callee3","_callee3$","_context3","_x4","_this5","pendingRequest","shift","activeResourceCounts","currentCount","nextCount","_key","_resolve","_reject","_timeoutId","_completed","clearTimeout","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _poolConfig = _interopRequireDefault(require(\"./pool-config\"));\n\nvar _error = require(\"../error\");\n\nvar _logger = _interopRequireDefault(require(\"./logger\"));\n\n/**\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar Pool =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {function(address: ServerAddress, function(address: ServerAddress, resource: object): Promise<object>): Promise<object>} create\n   *                an allocation function that creates a promise with a new resource. It's given an address for which to\n   *                allocate the connection and a function that will return the resource to the pool if invoked, which is\n   *                meant to be called on .dispose or .close or whatever mechanism the resource uses to finalize.\n   * @param {function(resource: object): Promise<void>} destroy\n   *                called with the resource when it is evicted from this pool\n   * @param {function(resource: object): boolean} validate\n   *                called at various times (like when an instance is acquired and when it is returned.\n   *                If this returns false, the resource will be evicted\n   * @param {function(resource: object, observer: { onError }): void} installIdleObserver\n   *                called when the resource is released back to pool\n   * @param {function(resource: object): void} removeIdleObserver\n   *                called when the resource is acquired from the pool\n   * @param {PoolConfig} config configuration for the new driver.\n   * @param {Logger} log the driver logger.\n   */\n  function Pool() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$create = _ref.create,\n        create = _ref$create === void 0 ? function (address, release) {\n      return Promise.resolve();\n    } : _ref$create,\n        _ref$destroy = _ref.destroy,\n        destroy = _ref$destroy === void 0 ? function (conn) {\n      return Promise.resolve();\n    } : _ref$destroy,\n        _ref$validate = _ref.validate,\n        validate = _ref$validate === void 0 ? function (conn) {\n      return true;\n    } : _ref$validate,\n        _ref$installIdleObser = _ref.installIdleObserver,\n        installIdleObserver = _ref$installIdleObser === void 0 ? function (conn, observer) {} : _ref$installIdleObser,\n        _ref$removeIdleObserv = _ref.removeIdleObserver,\n        removeIdleObserver = _ref$removeIdleObserv === void 0 ? function (conn) {} : _ref$removeIdleObserv,\n        _ref$config = _ref.config,\n        config = _ref$config === void 0 ? _poolConfig[\"default\"].defaultConfig() : _ref$config,\n        _ref$log = _ref.log,\n        log = _ref$log === void 0 ? _logger[\"default\"].noOp() : _ref$log;\n\n    (0, _classCallCheck2[\"default\"])(this, Pool);\n    this._create = create;\n    this._destroy = destroy;\n    this._validate = validate;\n    this._installIdleObserver = installIdleObserver;\n    this._removeIdleObserver = removeIdleObserver;\n    this._maxSize = config.maxSize;\n    this._acquisitionTimeout = config.acquisitionTimeout;\n    this._pools = {};\n    this._acquireRequests = {};\n    this._activeResourceCounts = {};\n    this._release = this._release.bind(this);\n    this._log = log;\n    this._closed = false;\n  }\n  /**\n   * Acquire and idle resource fom the pool or create a new one.\n   * @param {ServerAddress} address the address for which we're acquiring.\n   * @return {Object} resource that is ready to use.\n   */\n\n\n  (0, _createClass2[\"default\"])(Pool, [{\n    key: \"acquire\",\n    value: function acquire(address) {\n      var _this = this;\n\n      return this._acquire(address).then(function (resource) {\n        var key = address.asKey();\n\n        if (resource) {\n          if (_this._maxSize && _this.activeResourceCount(address) >= _this._maxSize) {\n            _this._destroy(resource);\n          } else {\n            resourceAcquired(key, _this._activeResourceCounts);\n\n            if (_this._log.isDebugEnabled()) {\n              _this._log.debug(\"\".concat(resource, \" acquired from the pool \").concat(key));\n            }\n\n            return resource;\n          }\n        } // We're out of resources and will try to acquire later on when an existing resource is released.\n\n\n        var allRequests = _this._acquireRequests;\n        var requests = allRequests[key];\n\n        if (!requests) {\n          allRequests[key] = [];\n        }\n\n        return new Promise(function (resolve, reject) {\n          var request;\n          var timeoutId = setTimeout(function () {\n            // acquisition timeout fired\n            // remove request from the queue of pending requests, if it's still there\n            // request might've been taken out by the release operation\n            var pendingRequests = allRequests[key];\n\n            if (pendingRequests) {\n              allRequests[key] = pendingRequests.filter(function (item) {\n                return item !== request;\n              });\n            }\n\n            if (request.isCompleted()) {// request already resolved/rejected by the release operation; nothing to do\n            } else {\n              // request is still pending and needs to be failed\n              var activeCount = _this.activeResourceCount(address);\n\n              var idleCount = _this.has(address) ? _this._pools[key].length : 0;\n              request.reject((0, _error.newError)(\"Connection acquisition timed out in \".concat(_this._acquisitionTimeout, \" ms. Poos status: Active conn count = \").concat(activeCount, \", Idle conn count = \").concat(idleCount, \".\")));\n            }\n          }, _this._acquisitionTimeout);\n          request = new PendingRequest(key, resolve, reject, timeoutId, _this._log);\n          allRequests[key].push(request);\n        });\n      });\n    }\n    /**\n     * Destroy all idle resources for the given address.\n     * @param {ServerAddress} address the address of the server to purge its pool.\n     * @returns {Promise<void>} A promise that is resolved when the resources are purged\n     */\n\n  }, {\n    key: \"purge\",\n    value: function purge(address) {\n      return this._purgeKey(address.asKey());\n    }\n    /**\n     * Destroy all idle resources in this pool.\n     * @returns {Promise<void>} A promise that is resolved when the resources are purged\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      var _this2 = this;\n\n      this._closed = true;\n      return Promise.all(Object.keys(this._pools).map(function (key) {\n        return _this2._purgeKey(key);\n      }));\n    }\n    /**\n     * Keep the idle resources for the provided addresses and purge the rest.\n     * @returns {Promise<void>} A promise that is resolved when the other resources are purged\n     */\n\n  }, {\n    key: \"keepAll\",\n    value: function keepAll(addresses) {\n      var _this3 = this;\n\n      var keysToKeep = addresses.map(function (a) {\n        return a.asKey();\n      });\n      var keysPresent = Object.keys(this._pools);\n      var keysToPurge = keysPresent.filter(function (k) {\n        return keysToKeep.indexOf(k) === -1;\n      });\n      return Promise.all(keysToPurge.map(function (key) {\n        return _this3._purgeKey(key);\n      }));\n    }\n    /**\n     * Check if this pool contains resources for the given address.\n     * @param {ServerAddress} address the address of the server to check.\n     * @return {boolean} `true` when pool contains entries for the given key, <code>false</code> otherwise.\n     */\n\n  }, {\n    key: \"has\",\n    value: function has(address) {\n      return address.asKey() in this._pools;\n    }\n    /**\n     * Get count of active (checked out of the pool) resources for the given key.\n     * @param {ServerAddress} address the address of the server to check.\n     * @return {number} count of resources acquired by clients.\n     */\n\n  }, {\n    key: \"activeResourceCount\",\n    value: function activeResourceCount(address) {\n      return this._activeResourceCounts[address.asKey()] || 0;\n    }\n  }, {\n    key: \"_acquire\",\n    value: function () {\n      var _acquire2 = (0, _asyncToGenerator2[\"default\"])(\n      /*#__PURE__*/\n      _regenerator[\"default\"].mark(function _callee(address) {\n        var key, pool, resource;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this._closed) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw (0, _error.newError)('Pool is closed, it is no more able to serve requests.');\n\n              case 2:\n                key = address.asKey();\n                pool = this._pools[key];\n\n                if (!pool) {\n                  pool = [];\n                  this._pools[key] = pool;\n                }\n\n              case 5:\n                if (!pool.length) {\n                  _context.next = 16;\n                  break;\n                }\n\n                resource = pool.pop();\n\n                if (!this._validate(resource)) {\n                  _context.next = 12;\n                  break;\n                }\n\n                if (this._removeIdleObserver) {\n                  this._removeIdleObserver(resource);\n                } // idle resource is valid and can be acquired\n\n\n                return _context.abrupt(\"return\", Promise.resolve(resource));\n\n              case 12:\n                _context.next = 14;\n                return this._destroy(resource);\n\n              case 14:\n                _context.next = 5;\n                break;\n\n              case 16:\n                if (!(this._maxSize && this.activeResourceCount(address) >= this._maxSize)) {\n                  _context.next = 18;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", null);\n\n              case 18:\n                _context.next = 20;\n                return this._create(address, this._release);\n\n              case 20:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 21:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _acquire(_x) {\n        return _acquire2.apply(this, arguments);\n      }\n\n      return _acquire;\n    }()\n  }, {\n    key: \"_release\",\n    value: function () {\n      var _release2 = (0, _asyncToGenerator2[\"default\"])(\n      /*#__PURE__*/\n      _regenerator[\"default\"].mark(function _callee2(address, resource) {\n        var _this4 = this;\n\n        var key, pool;\n        return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                key = address.asKey();\n                pool = this._pools[key];\n\n                if (!pool) {\n                  _context2.next = 14;\n                  break;\n                }\n\n                if (this._validate(resource)) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                if (this._log.isDebugEnabled()) {\n                  this._log.debug(\"\".concat(resource, \" destroyed and can't be released to the pool \").concat(key, \" because it is not functional\"));\n                }\n\n                _context2.next = 7;\n                return this._destroy(resource);\n\n              case 7:\n                _context2.next = 12;\n                break;\n\n              case 9:\n                if (this._installIdleObserver) {\n                  this._installIdleObserver(resource, {\n                    onError: function onError(error) {\n                      _this4._log.debug(\"Idle connection \".concat(resource, \" destroyed because of error: \").concat(error));\n\n                      var pool = _this4._pools[key];\n\n                      if (pool) {\n                        _this4._pools[key] = pool.filter(function (r) {\n                          return r !== resource;\n                        });\n                      } // let's not care about background clean-ups due to errors but just trigger the destroy\n                      // process for the resource, we especially catch any errors and ignore them to avoid\n                      // unhandled promise rejection warnings\n\n\n                      _this4._destroy(resource)[\"catch\"](function () {});\n                    }\n                  });\n                }\n\n                pool.push(resource);\n\n                if (this._log.isDebugEnabled()) {\n                  this._log.debug(\"\".concat(resource, \" released to the pool \").concat(key));\n                }\n\n              case 12:\n                _context2.next = 17;\n                break;\n\n              case 14:\n                // key has been purged, don't put it back, just destroy the resource\n                if (this._log.isDebugEnabled()) {\n                  this._log.debug(\"\".concat(resource, \" destroyed and can't be released to the pool \").concat(key, \" because pool has been purged\"));\n                }\n\n                _context2.next = 17;\n                return this._destroy(resource);\n\n              case 17:\n                resourceReleased(key, this._activeResourceCounts);\n\n                this._processPendingAcquireRequests(address);\n\n              case 19:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _release(_x2, _x3) {\n        return _release2.apply(this, arguments);\n      }\n\n      return _release;\n    }()\n  }, {\n    key: \"_purgeKey\",\n    value: function () {\n      var _purgeKey2 = (0, _asyncToGenerator2[\"default\"])(\n      /*#__PURE__*/\n      _regenerator[\"default\"].mark(function _callee3(key) {\n        var pool, resource;\n        return _regenerator[\"default\"].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                pool = this._pools[key] || [];\n\n              case 1:\n                if (!pool.length) {\n                  _context3.next = 8;\n                  break;\n                }\n\n                resource = pool.pop();\n\n                if (this._removeIdleObserver) {\n                  this._removeIdleObserver(resource);\n                }\n\n                _context3.next = 6;\n                return this._destroy(resource);\n\n              case 6:\n                _context3.next = 1;\n                break;\n\n              case 8:\n                delete this._pools[key];\n\n              case 9:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _purgeKey(_x4) {\n        return _purgeKey2.apply(this, arguments);\n      }\n\n      return _purgeKey;\n    }()\n  }, {\n    key: \"_processPendingAcquireRequests\",\n    value: function _processPendingAcquireRequests(address) {\n      var _this5 = this;\n\n      var key = address.asKey();\n      var requests = this._acquireRequests[key];\n\n      if (requests) {\n        var pendingRequest = requests.shift(); // pop a pending acquire request\n\n        if (pendingRequest) {\n          this._acquire(address)[\"catch\"](function (error) {\n            // failed to acquire/create a new connection to resolve the pending acquire request\n            // propagate the error by failing the pending request\n            pendingRequest.reject(error);\n            return null;\n          }).then(function (resource) {\n            if (resource) {\n              // managed to acquire a valid resource from the pool\n              if (pendingRequest.isCompleted()) {\n                // request has been completed, most likely failed by a timeout\n                // return the acquired resource back to the pool\n                _this5._release(address, resource);\n              } else {\n                // request is still pending and can be resolved with the newly acquired resource\n                resourceAcquired(key, _this5._activeResourceCounts); // increment the active counter\n\n                pendingRequest.resolve(resource); // resolve the pending request with the acquired resource\n              }\n            }\n          });\n        } else {\n          delete this._acquireRequests[key];\n        }\n      }\n    }\n  }]);\n  return Pool;\n}();\n/**\n * Increment active (checked out of the pool) resource counter.\n * @param {string} key the resource group identifier (server address for connections).\n * @param {Object.<string, number>} activeResourceCounts the object holding active counts per key.\n */\n\n\nfunction resourceAcquired(key, activeResourceCounts) {\n  var currentCount = activeResourceCounts[key] || 0;\n  activeResourceCounts[key] = currentCount + 1;\n}\n/**\n * Decrement active (checked out of the pool) resource counter.\n * @param {string} key the resource group identifier (server address for connections).\n * @param {Object.<string, number>} activeResourceCounts the object holding active counts per key.\n */\n\n\nfunction resourceReleased(key, activeResourceCounts) {\n  var currentCount = activeResourceCounts[key] || 0;\n  var nextCount = currentCount - 1;\n\n  if (nextCount > 0) {\n    activeResourceCounts[key] = nextCount;\n  } else {\n    delete activeResourceCounts[key];\n  }\n}\n\nvar PendingRequest =\n/*#__PURE__*/\nfunction () {\n  function PendingRequest(key, resolve, reject, timeoutId, log) {\n    (0, _classCallCheck2[\"default\"])(this, PendingRequest);\n    this._key = key;\n    this._resolve = resolve;\n    this._reject = reject;\n    this._timeoutId = timeoutId;\n    this._log = log;\n    this._completed = false;\n  }\n\n  (0, _createClass2[\"default\"])(PendingRequest, [{\n    key: \"isCompleted\",\n    value: function isCompleted() {\n      return this._completed;\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(resource) {\n      if (this._completed) {\n        return;\n      }\n\n      this._completed = true;\n      clearTimeout(this._timeoutId);\n\n      if (this._log.isDebugEnabled()) {\n        this._log.debug(\"\".concat(resource, \" acquired from the pool \").concat(this._key));\n      }\n\n      this._resolve(resource);\n    }\n  }, {\n    key: \"reject\",\n    value: function reject(error) {\n      if (this._completed) {\n        return;\n      }\n\n      this._completed = true;\n      clearTimeout(this._timeoutId);\n\n      this._reject(error);\n    }\n  }]);\n  return PendingRequest;\n}();\n\nvar _default = Pool;\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}