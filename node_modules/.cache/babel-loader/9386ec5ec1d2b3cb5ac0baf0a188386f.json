{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _node = require(\"./node\");\n\nvar _chunking = require(\"./chunking\");\n\nvar _error = require(\"../error\");\n\nvar _channelConfig = _interopRequireDefault(require(\"./channel-config\"));\n\nvar _protocolHandshaker = _interopRequireDefault(require(\"./protocol-handshaker\"));\n\nvar _connection = _interopRequireDefault(require(\"./connection\"));\n\nvar _boltProtocolV = _interopRequireDefault(require(\"./bolt-protocol-v1\"));\n\nvar _streamObservers = require(\"./stream-observers\");\n/**\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Signature bytes for each response message type\n\n\nvar SUCCESS = 0x70; // 0111 0000 // SUCCESS <metadata>\n\nvar RECORD = 0x71; // 0111 0001 // RECORD <value>\n\nvar IGNORED = 0x7e; // 0111 1110 // IGNORED <metadata>\n\nvar FAILURE = 0x7f; // 0111 1111 // FAILURE <metadata>\n\nfunction NO_OP() {}\n\nvar NO_OP_OBSERVER = {\n  onNext: NO_OP,\n  onCompleted: NO_OP,\n  onError: NO_OP\n};\nvar idGenerator = 0;\n\nvar ChannelConnection = /*#__PURE__*/function (_Connection) {\n  (0, _inherits2[\"default\"])(ChannelConnection, _Connection);\n  /**\n   * @constructor\n   * @param {Channel} channel - channel with a 'write' function and a 'onmessage' callback property.\n   * @param {ConnectionErrorHandler} errorHandler the error handler.\n   * @param {ServerAddress} address - the server address to connect to.\n   * @param {Logger} log - the configured logger.\n   * @param {boolean} disableLosslessIntegers if this connection should convert all received integers to native JS numbers.\n   */\n\n  function ChannelConnection(channel, errorHandler, address, log) {\n    var _this;\n\n    var disableLosslessIntegers = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    (0, _classCallCheck2[\"default\"])(this, ChannelConnection);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(ChannelConnection).call(this, errorHandler));\n    _this._id = idGenerator++;\n    _this._address = address;\n    _this._server = {\n      address: address.asHostPort()\n    };\n    _this.creationTimestamp = Date.now();\n    _this._disableLosslessIntegers = disableLosslessIntegers;\n    _this._pendingObservers = [];\n    _this._currentObserver = undefined;\n    _this._ch = channel;\n    _this._dechunker = new _chunking.Dechunker();\n    _this._chunker = new _chunking.Chunker(channel);\n    _this._log = log; // connection from the database, returned in response for HELLO message and might not be available\n\n    _this._dbConnectionId = null; // bolt protocol is initially not initialized\n\n    /**\n     * @private\n     * @type {BoltProtocol}\n     */\n\n    _this._protocol = null; // error extracted from a FAILURE message\n\n    _this._currentFailure = null; // Set to true on fatal errors, to get this out of connection pool.\n\n    _this._isBroken = false;\n\n    if (_this._log.isDebugEnabled()) {\n      _this._log.debug(\"\".concat((0, _assertThisInitialized2[\"default\"])(_this), \" created towards \").concat(address));\n    }\n\n    return _this;\n  }\n  /**\n   * Crete new connection to the provided address. Returned connection is not connected.\n   * @param {ServerAddress} address - the Bolt endpoint to connect to.\n   * @param {Object} config - the driver configuration.\n   * @param {ConnectionErrorHandler} errorHandler - the error handler for connection errors.\n   * @param {Logger} log - configured logger.\n   * @return {Connection} - new connection.\n   */\n\n\n  (0, _createClass2[\"default\"])(ChannelConnection, [{\n    key: \"connect\",\n\n    /**\n     * Connect to the target address, negotiate Bolt protocol and send initialization message.\n     * @param {string} userAgent the user agent for this driver.\n     * @param {Object} authToken the object containing auth information.\n     * @return {Promise<Connection>} promise resolved with the current connection if connection is successful. Rejected promise otherwise.\n     */\n    value: function connect(userAgent, authToken) {\n      var _this2 = this;\n\n      return this._negotiateProtocol().then(function () {\n        return _this2._initialize(userAgent, authToken);\n      });\n    }\n    /**\n     * Execute Bolt protocol handshake to initialize the protocol version.\n     * @return {Promise<Connection>} promise resolved with the current connection if handshake is successful. Rejected promise otherwise.\n     */\n\n  }, {\n    key: \"_negotiateProtocol\",\n    value: function _negotiateProtocol() {\n      var _this3 = this;\n\n      var protocolHandshaker = new _protocolHandshaker[\"default\"](this, this._ch, this._chunker, this._disableLosslessIntegers, this._log);\n      return new Promise(function (resolve, reject) {\n        var handshakeErrorHandler = function handshakeErrorHandler(error) {\n          _this3._handleFatalError(error);\n\n          reject(error);\n        };\n\n        _this3._ch.onerror = handshakeErrorHandler.bind(_this3);\n\n        if (_this3._ch._error) {\n          // channel is already broken\n          handshakeErrorHandler(_this3._ch._error);\n        }\n\n        _this3._ch.onmessage = function (buffer) {\n          try {\n            // read the response buffer and initialize the protocol\n            _this3._protocol = protocolHandshaker.createNegotiatedProtocol(buffer); // reset the error handler to just handle errors and forget about the handshake promise\n\n            _this3._ch.onerror = _this3._handleFatalError.bind(_this3); // Ok, protocol running. Simply forward all messages to the dechunker\n\n            _this3._ch.onmessage = function (buf) {\n              return _this3._dechunker.write(buf);\n            }; // setup dechunker to dechunk messages and forward them to the message handler\n\n\n            _this3._dechunker.onmessage = function (buf) {\n              _this3._handleMessage(_this3._protocol.unpacker().unpack(buf));\n            }; // forward all pending bytes to the dechunker\n\n\n            if (buffer.hasRemaining()) {\n              _this3._dechunker.write(buffer.readSlice(buffer.remaining()));\n            }\n\n            resolve(_this3);\n          } catch (e) {\n            _this3._handleFatalError(e);\n\n            reject(e);\n          }\n        };\n\n        protocolHandshaker.writeHandshakeRequest();\n      });\n    }\n    /**\n     * Perform protocol-specific initialization which includes authentication.\n     * @param {string} userAgent the user agent for this driver.\n     * @param {Object} authToken the object containing auth information.\n     * @return {Promise<Connection>} promise resolved with the current connection if initialization is successful. Rejected promise otherwise.\n     */\n\n  }, {\n    key: \"_initialize\",\n    value: function _initialize(userAgent, authToken) {\n      var _this4 = this;\n\n      var self = this;\n      return new Promise(function (resolve, reject) {\n        _this4._protocol.initialize({\n          userAgent: userAgent,\n          authToken: authToken,\n          onError: function onError(err) {\n            return reject(err);\n          },\n          onComplete: function onComplete() {\n            return resolve(self);\n          }\n        });\n      });\n    }\n    /**\n     * Get the Bolt protocol for the connection.\n     * @return {BoltProtocol} the protocol.\n     */\n\n  }, {\n    key: \"protocol\",\n    value: function protocol() {\n      return this._protocol;\n    }\n  }, {\n    key: \"write\",\n\n    /**\n     * Write a message to the network channel.\n     * @param {RequestMessage} message the message to write.\n     * @param {ResultStreamObserver} observer the response observer.\n     * @param {boolean} flush `true` if flush should happen after the message is written to the buffer.\n     */\n    value: function write(message, observer, flush) {\n      var _this5 = this;\n\n      var queued = this._queueObserver(observer);\n\n      if (queued) {\n        if (this._log.isDebugEnabled()) {\n          this._log.debug(\"\".concat(this, \" C: \").concat(message));\n        }\n\n        this._protocol.packer().packStruct(message.signature, message.fields.map(function (field) {\n          return _this5._packable(field);\n        }));\n\n        this._chunker.messageBoundary();\n\n        if (flush) {\n          this._chunker.flush();\n        }\n      }\n    }\n    /**\n     * \"Fatal\" means the connection is dead. Only call this if something\n     * happens that cannot be recovered from. This will lead to all subscribers\n     * failing, and the connection getting ejected from the session pool.\n     *\n     * @param error an error object, forwarded to all current and future subscribers\n     */\n\n  }, {\n    key: \"_handleFatalError\",\n    value: function _handleFatalError(error) {\n      this._isBroken = true;\n      this._error = this.handleAndTransformError(error, this._address);\n\n      if (this._log.isErrorEnabled()) {\n        this._log.error(\"\".concat(this, \" experienced a fatal error \").concat(JSON.stringify(this._error)));\n      }\n\n      if (this._currentObserver && this._currentObserver.onError) {\n        this._currentObserver.onError(this._error);\n      }\n\n      while (this._pendingObservers.length > 0) {\n        var observer = this._pendingObservers.shift();\n\n        if (observer && observer.onError) {\n          observer.onError(this._error);\n        }\n      }\n    }\n  }, {\n    key: \"_handleMessage\",\n    value: function _handleMessage(msg) {\n      if (this._isBroken) {\n        // ignore all incoming messages when this connection is broken. all previously pending observers failed\n        // with the fatal error. all future observers will fail with same fatal error.\n        return;\n      }\n\n      var payload = msg.fields[0];\n\n      switch (msg.signature) {\n        case RECORD:\n          if (this._log.isDebugEnabled()) {\n            this._log.debug(\"\".concat(this, \" S: RECORD \").concat(JSON.stringify(msg)));\n          }\n\n          this._currentObserver.onNext(payload);\n\n          break;\n\n        case SUCCESS:\n          if (this._log.isDebugEnabled()) {\n            this._log.debug(\"\".concat(this, \" S: SUCCESS \").concat(JSON.stringify(msg)));\n          }\n\n          try {\n            var metadata = this._protocol.transformMetadata(payload);\n\n            this._currentObserver.onCompleted(metadata);\n          } finally {\n            this._updateCurrentObserver();\n          }\n\n          break;\n\n        case FAILURE:\n          if (this._log.isDebugEnabled()) {\n            this._log.debug(\"\".concat(this, \" S: FAILURE \").concat(JSON.stringify(msg)));\n          }\n\n          try {\n            var error = (0, _error.newError)(payload.message, payload.code);\n            this._currentFailure = this.handleAndTransformError(error, this._address);\n\n            this._currentObserver.onError(this._currentFailure);\n          } finally {\n            this._updateCurrentObserver(); // Things are now broken. Pending observers will get FAILURE messages routed until we are done handling this failure.\n\n\n            this._resetOnFailure();\n          }\n\n          break;\n\n        case IGNORED:\n          if (this._log.isDebugEnabled()) {\n            this._log.debug(\"\".concat(this, \" S: IGNORED \").concat(JSON.stringify(msg)));\n          }\n\n          try {\n            if (this._currentFailure && this._currentObserver.onError) {\n              this._currentObserver.onError(this._currentFailure);\n            } else if (this._currentObserver.onError) {\n              this._currentObserver.onError((0, _error.newError)('Ignored either because of an error or RESET'));\n            }\n          } finally {\n            this._updateCurrentObserver();\n          }\n\n          break;\n\n        default:\n          this._handleFatalError((0, _error.newError)('Unknown Bolt protocol message: ' + msg));\n\n      }\n    }\n    /**\n     * Send a RESET-message to the database. Message is immediately flushed to the network.\n     * @return {Promise<void>} promise resolved when SUCCESS-message response arrives, or failed when other response messages arrives.\n     */\n\n  }, {\n    key: \"resetAndFlush\",\n    value: function resetAndFlush() {\n      var _this6 = this;\n\n      return new Promise(function (resolve, reject) {\n        _this6._protocol.reset({\n          onError: function onError(error) {\n            if (_this6._isBroken) {\n              // handling a fatal error, no need to raise a protocol violation\n              reject(error);\n            } else {\n              var neo4jError = _this6._handleProtocolError('Received FAILURE as a response for RESET: ' + error);\n\n              reject(neo4jError);\n            }\n          },\n          onComplete: function onComplete() {\n            resolve();\n          }\n        });\n      });\n    }\n  }, {\n    key: \"_resetOnFailure\",\n    value: function _resetOnFailure() {\n      var _this7 = this;\n\n      this._protocol.reset({\n        onError: function onError() {\n          _this7._currentFailure = null;\n        },\n        onComplete: function onComplete() {\n          _this7._currentFailure = null;\n        }\n      });\n    }\n  }, {\n    key: \"_queueObserver\",\n    value: function _queueObserver(observer) {\n      if (this._isBroken) {\n        if (observer && observer.onError) {\n          observer.onError(this._error);\n        }\n\n        return false;\n      }\n\n      observer = observer || NO_OP_OBSERVER;\n      observer.onCompleted = observer.onCompleted || NO_OP;\n      observer.onError = observer.onError || NO_OP;\n      observer.onNext = observer.onNext || NO_OP;\n\n      if (this._currentObserver === undefined) {\n        this._currentObserver = observer;\n      } else {\n        this._pendingObservers.push(observer);\n      }\n\n      return true;\n    }\n    /*\n     * Pop next pending observer form the list of observers and make it current observer.\n     * @protected\n     */\n\n  }, {\n    key: \"_updateCurrentObserver\",\n    value: function _updateCurrentObserver() {\n      this._currentObserver = this._pendingObservers.shift();\n    }\n    /** Check if this connection is in working condition */\n\n  }, {\n    key: \"isOpen\",\n    value: function isOpen() {\n      return !this._isBroken && this._ch._open;\n    }\n    /**\n     * Call close on the channel.\n     * @returns {Promise<void>} - A promise that will be resolved when the underlying channel is closed.\n     */\n\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee() {\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this._log.isDebugEnabled()) {\n                  this._log.debug(\"\".concat(this, \" closing\"));\n                }\n\n                if (this._protocol && this.isOpen()) {\n                  // protocol has been initialized and this connection is healthy\n                  // notify the database about the upcoming close of the connection\n                  this._protocol.prepareToClose();\n                }\n\n                _context.next = 4;\n                return this._ch.close();\n\n              case 4:\n                if (this._log.isDebugEnabled()) {\n                  this._log.debug(\"\".concat(this, \" closed\"));\n                }\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"Connection [\".concat(this.id, \"][\").concat(this.databaseId || '', \"]\");\n    }\n  }, {\n    key: \"_packable\",\n    value: function _packable(value) {\n      return this._protocol.packer().packable(value);\n    }\n  }, {\n    key: \"_handleProtocolError\",\n    value: function _handleProtocolError(message) {\n      this._currentFailure = null;\n\n      this._updateCurrentObserver();\n\n      var error = (0, _error.newError)(message, _error.PROTOCOL_ERROR);\n\n      this._handleFatalError(error);\n\n      return error;\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    }\n  }, {\n    key: \"databaseId\",\n    get: function get() {\n      return this._dbConnectionId;\n    },\n    set: function set(value) {\n      this._dbConnectionId = value;\n    }\n  }, {\n    key: \"address\",\n    get: function get() {\n      return this._address;\n    }\n    /**\n     * Get the version of the connected server.\n     * Available only after initialization\n     *\n     * @returns {ServerVersion} version\n     */\n\n  }, {\n    key: \"version\",\n    get: function get() {\n      return this._server.version;\n    },\n    set: function set(value) {\n      this._server.version = value;\n    }\n  }, {\n    key: \"server\",\n    get: function get() {\n      return this._server;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(address, config, errorHandler, log) {\n      var channelConfig = new _channelConfig[\"default\"](address, config, errorHandler.errorCode());\n      return new ChannelConnection(new _node.Channel(channelConfig), errorHandler, address, log, config.disableLosslessIntegers);\n    }\n  }]);\n  return ChannelConnection;\n}(_connection[\"default\"]);\n\nexports[\"default\"] = ChannelConnection;","map":{"version":3,"sources":["d:/webback/pro5/node_modules/neo4j-driver/lib/internal/connection-channel.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","_regenerator","_asyncToGenerator2","_classCallCheck2","_createClass2","_possibleConstructorReturn2","_getPrototypeOf2","_assertThisInitialized2","_inherits2","_node","_chunking","_error","_channelConfig","_protocolHandshaker","_connection","_boltProtocolV","_streamObservers","SUCCESS","RECORD","IGNORED","FAILURE","NO_OP","NO_OP_OBSERVER","onNext","onCompleted","onError","idGenerator","ChannelConnection","_Connection","channel","errorHandler","address","log","_this","disableLosslessIntegers","arguments","length","undefined","call","_id","_address","_server","asHostPort","creationTimestamp","Date","now","_disableLosslessIntegers","_pendingObservers","_currentObserver","_ch","_dechunker","Dechunker","_chunker","Chunker","_log","_dbConnectionId","_protocol","_currentFailure","_isBroken","isDebugEnabled","debug","concat","key","connect","userAgent","authToken","_this2","_negotiateProtocol","then","_initialize","_this3","protocolHandshaker","Promise","resolve","reject","handshakeErrorHandler","error","_handleFatalError","onerror","bind","onmessage","buffer","createNegotiatedProtocol","buf","write","_handleMessage","unpacker","unpack","hasRemaining","readSlice","remaining","e","writeHandshakeRequest","_this4","self","initialize","err","onComplete","protocol","message","observer","flush","_this5","queued","_queueObserver","packer","packStruct","signature","fields","map","field","_packable","messageBoundary","handleAndTransformError","isErrorEnabled","JSON","stringify","shift","msg","payload","metadata","transformMetadata","_updateCurrentObserver","newError","code","_resetOnFailure","resetAndFlush","_this6","reset","neo4jError","_handleProtocolError","_this7","push","isOpen","_open","_close","mark","_callee","wrap","_callee$","_context","prev","next","prepareToClose","close","stop","apply","toString","id","databaseId","packable","PROTOCOL_ERROR","get","set","version","create","config","channelConfig","errorCode","Channel"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _node = require(\"./node\");\n\nvar _chunking = require(\"./chunking\");\n\nvar _error = require(\"../error\");\n\nvar _channelConfig = _interopRequireDefault(require(\"./channel-config\"));\n\nvar _protocolHandshaker = _interopRequireDefault(require(\"./protocol-handshaker\"));\n\nvar _connection = _interopRequireDefault(require(\"./connection\"));\n\nvar _boltProtocolV = _interopRequireDefault(require(\"./bolt-protocol-v1\"));\n\nvar _streamObservers = require(\"./stream-observers\");\n\n/**\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Signature bytes for each response message type\nvar SUCCESS = 0x70; // 0111 0000 // SUCCESS <metadata>\n\nvar RECORD = 0x71; // 0111 0001 // RECORD <value>\n\nvar IGNORED = 0x7e; // 0111 1110 // IGNORED <metadata>\n\nvar FAILURE = 0x7f; // 0111 1111 // FAILURE <metadata>\n\nfunction NO_OP() {}\n\nvar NO_OP_OBSERVER = {\n  onNext: NO_OP,\n  onCompleted: NO_OP,\n  onError: NO_OP\n};\nvar idGenerator = 0;\n\nvar ChannelConnection =\n/*#__PURE__*/\nfunction (_Connection) {\n  (0, _inherits2[\"default\"])(ChannelConnection, _Connection);\n\n  /**\n   * @constructor\n   * @param {Channel} channel - channel with a 'write' function and a 'onmessage' callback property.\n   * @param {ConnectionErrorHandler} errorHandler the error handler.\n   * @param {ServerAddress} address - the server address to connect to.\n   * @param {Logger} log - the configured logger.\n   * @param {boolean} disableLosslessIntegers if this connection should convert all received integers to native JS numbers.\n   */\n  function ChannelConnection(channel, errorHandler, address, log) {\n    var _this;\n\n    var disableLosslessIntegers = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    (0, _classCallCheck2[\"default\"])(this, ChannelConnection);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(ChannelConnection).call(this, errorHandler));\n    _this._id = idGenerator++;\n    _this._address = address;\n    _this._server = {\n      address: address.asHostPort()\n    };\n    _this.creationTimestamp = Date.now();\n    _this._disableLosslessIntegers = disableLosslessIntegers;\n    _this._pendingObservers = [];\n    _this._currentObserver = undefined;\n    _this._ch = channel;\n    _this._dechunker = new _chunking.Dechunker();\n    _this._chunker = new _chunking.Chunker(channel);\n    _this._log = log; // connection from the database, returned in response for HELLO message and might not be available\n\n    _this._dbConnectionId = null; // bolt protocol is initially not initialized\n\n    /**\n     * @private\n     * @type {BoltProtocol}\n     */\n\n    _this._protocol = null; // error extracted from a FAILURE message\n\n    _this._currentFailure = null; // Set to true on fatal errors, to get this out of connection pool.\n\n    _this._isBroken = false;\n\n    if (_this._log.isDebugEnabled()) {\n      _this._log.debug(\"\".concat((0, _assertThisInitialized2[\"default\"])(_this), \" created towards \").concat(address));\n    }\n\n    return _this;\n  }\n  /**\n   * Crete new connection to the provided address. Returned connection is not connected.\n   * @param {ServerAddress} address - the Bolt endpoint to connect to.\n   * @param {Object} config - the driver configuration.\n   * @param {ConnectionErrorHandler} errorHandler - the error handler for connection errors.\n   * @param {Logger} log - configured logger.\n   * @return {Connection} - new connection.\n   */\n\n\n  (0, _createClass2[\"default\"])(ChannelConnection, [{\n    key: \"connect\",\n\n    /**\n     * Connect to the target address, negotiate Bolt protocol and send initialization message.\n     * @param {string} userAgent the user agent for this driver.\n     * @param {Object} authToken the object containing auth information.\n     * @return {Promise<Connection>} promise resolved with the current connection if connection is successful. Rejected promise otherwise.\n     */\n    value: function connect(userAgent, authToken) {\n      var _this2 = this;\n\n      return this._negotiateProtocol().then(function () {\n        return _this2._initialize(userAgent, authToken);\n      });\n    }\n    /**\n     * Execute Bolt protocol handshake to initialize the protocol version.\n     * @return {Promise<Connection>} promise resolved with the current connection if handshake is successful. Rejected promise otherwise.\n     */\n\n  }, {\n    key: \"_negotiateProtocol\",\n    value: function _negotiateProtocol() {\n      var _this3 = this;\n\n      var protocolHandshaker = new _protocolHandshaker[\"default\"](this, this._ch, this._chunker, this._disableLosslessIntegers, this._log);\n      return new Promise(function (resolve, reject) {\n        var handshakeErrorHandler = function handshakeErrorHandler(error) {\n          _this3._handleFatalError(error);\n\n          reject(error);\n        };\n\n        _this3._ch.onerror = handshakeErrorHandler.bind(_this3);\n\n        if (_this3._ch._error) {\n          // channel is already broken\n          handshakeErrorHandler(_this3._ch._error);\n        }\n\n        _this3._ch.onmessage = function (buffer) {\n          try {\n            // read the response buffer and initialize the protocol\n            _this3._protocol = protocolHandshaker.createNegotiatedProtocol(buffer); // reset the error handler to just handle errors and forget about the handshake promise\n\n            _this3._ch.onerror = _this3._handleFatalError.bind(_this3); // Ok, protocol running. Simply forward all messages to the dechunker\n\n            _this3._ch.onmessage = function (buf) {\n              return _this3._dechunker.write(buf);\n            }; // setup dechunker to dechunk messages and forward them to the message handler\n\n\n            _this3._dechunker.onmessage = function (buf) {\n              _this3._handleMessage(_this3._protocol.unpacker().unpack(buf));\n            }; // forward all pending bytes to the dechunker\n\n\n            if (buffer.hasRemaining()) {\n              _this3._dechunker.write(buffer.readSlice(buffer.remaining()));\n            }\n\n            resolve(_this3);\n          } catch (e) {\n            _this3._handleFatalError(e);\n\n            reject(e);\n          }\n        };\n\n        protocolHandshaker.writeHandshakeRequest();\n      });\n    }\n    /**\n     * Perform protocol-specific initialization which includes authentication.\n     * @param {string} userAgent the user agent for this driver.\n     * @param {Object} authToken the object containing auth information.\n     * @return {Promise<Connection>} promise resolved with the current connection if initialization is successful. Rejected promise otherwise.\n     */\n\n  }, {\n    key: \"_initialize\",\n    value: function _initialize(userAgent, authToken) {\n      var _this4 = this;\n\n      var self = this;\n      return new Promise(function (resolve, reject) {\n        _this4._protocol.initialize({\n          userAgent: userAgent,\n          authToken: authToken,\n          onError: function onError(err) {\n            return reject(err);\n          },\n          onComplete: function onComplete() {\n            return resolve(self);\n          }\n        });\n      });\n    }\n    /**\n     * Get the Bolt protocol for the connection.\n     * @return {BoltProtocol} the protocol.\n     */\n\n  }, {\n    key: \"protocol\",\n    value: function protocol() {\n      return this._protocol;\n    }\n  }, {\n    key: \"write\",\n\n    /**\n     * Write a message to the network channel.\n     * @param {RequestMessage} message the message to write.\n     * @param {ResultStreamObserver} observer the response observer.\n     * @param {boolean} flush `true` if flush should happen after the message is written to the buffer.\n     */\n    value: function write(message, observer, flush) {\n      var _this5 = this;\n\n      var queued = this._queueObserver(observer);\n\n      if (queued) {\n        if (this._log.isDebugEnabled()) {\n          this._log.debug(\"\".concat(this, \" C: \").concat(message));\n        }\n\n        this._protocol.packer().packStruct(message.signature, message.fields.map(function (field) {\n          return _this5._packable(field);\n        }));\n\n        this._chunker.messageBoundary();\n\n        if (flush) {\n          this._chunker.flush();\n        }\n      }\n    }\n    /**\n     * \"Fatal\" means the connection is dead. Only call this if something\n     * happens that cannot be recovered from. This will lead to all subscribers\n     * failing, and the connection getting ejected from the session pool.\n     *\n     * @param error an error object, forwarded to all current and future subscribers\n     */\n\n  }, {\n    key: \"_handleFatalError\",\n    value: function _handleFatalError(error) {\n      this._isBroken = true;\n      this._error = this.handleAndTransformError(error, this._address);\n\n      if (this._log.isErrorEnabled()) {\n        this._log.error(\"\".concat(this, \" experienced a fatal error \").concat(JSON.stringify(this._error)));\n      }\n\n      if (this._currentObserver && this._currentObserver.onError) {\n        this._currentObserver.onError(this._error);\n      }\n\n      while (this._pendingObservers.length > 0) {\n        var observer = this._pendingObservers.shift();\n\n        if (observer && observer.onError) {\n          observer.onError(this._error);\n        }\n      }\n    }\n  }, {\n    key: \"_handleMessage\",\n    value: function _handleMessage(msg) {\n      if (this._isBroken) {\n        // ignore all incoming messages when this connection is broken. all previously pending observers failed\n        // with the fatal error. all future observers will fail with same fatal error.\n        return;\n      }\n\n      var payload = msg.fields[0];\n\n      switch (msg.signature) {\n        case RECORD:\n          if (this._log.isDebugEnabled()) {\n            this._log.debug(\"\".concat(this, \" S: RECORD \").concat(JSON.stringify(msg)));\n          }\n\n          this._currentObserver.onNext(payload);\n\n          break;\n\n        case SUCCESS:\n          if (this._log.isDebugEnabled()) {\n            this._log.debug(\"\".concat(this, \" S: SUCCESS \").concat(JSON.stringify(msg)));\n          }\n\n          try {\n            var metadata = this._protocol.transformMetadata(payload);\n\n            this._currentObserver.onCompleted(metadata);\n          } finally {\n            this._updateCurrentObserver();\n          }\n\n          break;\n\n        case FAILURE:\n          if (this._log.isDebugEnabled()) {\n            this._log.debug(\"\".concat(this, \" S: FAILURE \").concat(JSON.stringify(msg)));\n          }\n\n          try {\n            var error = (0, _error.newError)(payload.message, payload.code);\n            this._currentFailure = this.handleAndTransformError(error, this._address);\n\n            this._currentObserver.onError(this._currentFailure);\n          } finally {\n            this._updateCurrentObserver(); // Things are now broken. Pending observers will get FAILURE messages routed until we are done handling this failure.\n\n\n            this._resetOnFailure();\n          }\n\n          break;\n\n        case IGNORED:\n          if (this._log.isDebugEnabled()) {\n            this._log.debug(\"\".concat(this, \" S: IGNORED \").concat(JSON.stringify(msg)));\n          }\n\n          try {\n            if (this._currentFailure && this._currentObserver.onError) {\n              this._currentObserver.onError(this._currentFailure);\n            } else if (this._currentObserver.onError) {\n              this._currentObserver.onError((0, _error.newError)('Ignored either because of an error or RESET'));\n            }\n          } finally {\n            this._updateCurrentObserver();\n          }\n\n          break;\n\n        default:\n          this._handleFatalError((0, _error.newError)('Unknown Bolt protocol message: ' + msg));\n\n      }\n    }\n    /**\n     * Send a RESET-message to the database. Message is immediately flushed to the network.\n     * @return {Promise<void>} promise resolved when SUCCESS-message response arrives, or failed when other response messages arrives.\n     */\n\n  }, {\n    key: \"resetAndFlush\",\n    value: function resetAndFlush() {\n      var _this6 = this;\n\n      return new Promise(function (resolve, reject) {\n        _this6._protocol.reset({\n          onError: function onError(error) {\n            if (_this6._isBroken) {\n              // handling a fatal error, no need to raise a protocol violation\n              reject(error);\n            } else {\n              var neo4jError = _this6._handleProtocolError('Received FAILURE as a response for RESET: ' + error);\n\n              reject(neo4jError);\n            }\n          },\n          onComplete: function onComplete() {\n            resolve();\n          }\n        });\n      });\n    }\n  }, {\n    key: \"_resetOnFailure\",\n    value: function _resetOnFailure() {\n      var _this7 = this;\n\n      this._protocol.reset({\n        onError: function onError() {\n          _this7._currentFailure = null;\n        },\n        onComplete: function onComplete() {\n          _this7._currentFailure = null;\n        }\n      });\n    }\n  }, {\n    key: \"_queueObserver\",\n    value: function _queueObserver(observer) {\n      if (this._isBroken) {\n        if (observer && observer.onError) {\n          observer.onError(this._error);\n        }\n\n        return false;\n      }\n\n      observer = observer || NO_OP_OBSERVER;\n      observer.onCompleted = observer.onCompleted || NO_OP;\n      observer.onError = observer.onError || NO_OP;\n      observer.onNext = observer.onNext || NO_OP;\n\n      if (this._currentObserver === undefined) {\n        this._currentObserver = observer;\n      } else {\n        this._pendingObservers.push(observer);\n      }\n\n      return true;\n    }\n    /*\n     * Pop next pending observer form the list of observers and make it current observer.\n     * @protected\n     */\n\n  }, {\n    key: \"_updateCurrentObserver\",\n    value: function _updateCurrentObserver() {\n      this._currentObserver = this._pendingObservers.shift();\n    }\n    /** Check if this connection is in working condition */\n\n  }, {\n    key: \"isOpen\",\n    value: function isOpen() {\n      return !this._isBroken && this._ch._open;\n    }\n    /**\n     * Call close on the channel.\n     * @returns {Promise<void>} - A promise that will be resolved when the underlying channel is closed.\n     */\n\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = (0, _asyncToGenerator2[\"default\"])(\n      /*#__PURE__*/\n      _regenerator[\"default\"].mark(function _callee() {\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this._log.isDebugEnabled()) {\n                  this._log.debug(\"\".concat(this, \" closing\"));\n                }\n\n                if (this._protocol && this.isOpen()) {\n                  // protocol has been initialized and this connection is healthy\n                  // notify the database about the upcoming close of the connection\n                  this._protocol.prepareToClose();\n                }\n\n                _context.next = 4;\n                return this._ch.close();\n\n              case 4:\n                if (this._log.isDebugEnabled()) {\n                  this._log.debug(\"\".concat(this, \" closed\"));\n                }\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"Connection [\".concat(this.id, \"][\").concat(this.databaseId || '', \"]\");\n    }\n  }, {\n    key: \"_packable\",\n    value: function _packable(value) {\n      return this._protocol.packer().packable(value);\n    }\n  }, {\n    key: \"_handleProtocolError\",\n    value: function _handleProtocolError(message) {\n      this._currentFailure = null;\n\n      this._updateCurrentObserver();\n\n      var error = (0, _error.newError)(message, _error.PROTOCOL_ERROR);\n\n      this._handleFatalError(error);\n\n      return error;\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    }\n  }, {\n    key: \"databaseId\",\n    get: function get() {\n      return this._dbConnectionId;\n    },\n    set: function set(value) {\n      this._dbConnectionId = value;\n    }\n  }, {\n    key: \"address\",\n    get: function get() {\n      return this._address;\n    }\n    /**\n     * Get the version of the connected server.\n     * Available only after initialization\n     *\n     * @returns {ServerVersion} version\n     */\n\n  }, {\n    key: \"version\",\n    get: function get() {\n      return this._server.version;\n    },\n    set: function set(value) {\n      this._server.version = value;\n    }\n  }, {\n    key: \"server\",\n    get: function get() {\n      return this._server;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(address, config, errorHandler, log) {\n      var channelConfig = new _channelConfig[\"default\"](address, config, errorHandler.errorCode());\n      return new ChannelConnection(new _node.Channel(channelConfig), errorHandler, address, log, config.disableLosslessIntegers);\n    }\n  }]);\n  return ChannelConnection;\n}(_connection[\"default\"]);\n\nexports[\"default\"] = ChannelConnection;"]},"metadata":{},"sourceType":"script"}