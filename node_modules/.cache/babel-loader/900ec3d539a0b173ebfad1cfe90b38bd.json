{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Structure = exports.Unpacker = exports.Packer = void 0;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _node = require(\"./node\");\n\nvar _integer = _interopRequireWildcard(require(\"../integer\"));\n\nvar _error = require(\"../error\");\n\nvar _graphTypes = require(\"../graph-types\");\n/**\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar TINY_STRING = 0x80;\nvar TINY_LIST = 0x90;\nvar TINY_MAP = 0xa0;\nvar TINY_STRUCT = 0xb0;\nvar NULL = 0xc0;\nvar FLOAT_64 = 0xc1;\nvar FALSE = 0xc2;\nvar TRUE = 0xc3;\nvar INT_8 = 0xc8;\nvar INT_16 = 0xc9;\nvar INT_32 = 0xca;\nvar INT_64 = 0xcb;\nvar STRING_8 = 0xd0;\nvar STRING_16 = 0xd1;\nvar STRING_32 = 0xd2;\nvar LIST_8 = 0xd4;\nvar LIST_16 = 0xd5;\nvar LIST_32 = 0xd6;\nvar BYTES_8 = 0xcc;\nvar BYTES_16 = 0xcd;\nvar BYTES_32 = 0xce;\nvar MAP_8 = 0xd8;\nvar MAP_16 = 0xd9;\nvar MAP_32 = 0xda;\nvar STRUCT_8 = 0xdc;\nvar STRUCT_16 = 0xdd;\nvar NODE = 0x4e;\nvar NODE_STRUCT_SIZE = 3;\nvar RELATIONSHIP = 0x52;\nvar RELATIONSHIP_STRUCT_SIZE = 5;\nvar UNBOUND_RELATIONSHIP = 0x72;\nvar UNBOUND_RELATIONSHIP_STRUCT_SIZE = 3;\nvar PATH = 0x50;\nvar PATH_STRUCT_SIZE = 3;\n/**\n * A Structure have a signature and fields.\n * @access private\n */\n\nvar Structure = /*#__PURE__*/function () {\n  /**\n   * Create new instance\n   */\n  function Structure(signature, fields) {\n    (0, _classCallCheck2[\"default\"])(this, Structure);\n    this.signature = signature;\n    this.fields = fields;\n  }\n\n  (0, _createClass2[\"default\"])(Structure, [{\n    key: \"toString\",\n    value: function toString() {\n      var fieldStr = '';\n\n      for (var i = 0; i < this.fields.length; i++) {\n        if (i > 0) {\n          fieldStr += ', ';\n        }\n\n        fieldStr += this.fields[i];\n      }\n\n      return 'Structure(' + this.signature + ', [' + fieldStr + '])';\n    }\n  }]);\n  return Structure;\n}();\n/**\n * Class to pack\n * @access private\n */\n\n\nexports.Structure = Structure;\n\nvar Packer = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * @param {Chunker} channel the chunker backed by a network channel.\n   */\n  function Packer(channel) {\n    (0, _classCallCheck2[\"default\"])(this, Packer);\n    this._ch = channel;\n    this._byteArraysSupported = true;\n  }\n  /**\n   * Creates a packable function out of the provided value\n   * @param x the value to pack\n   * @returns Function\n   */\n\n\n  (0, _createClass2[\"default\"])(Packer, [{\n    key: \"packable\",\n    value: function packable(x) {\n      var _this = this;\n\n      if (x === null) {\n        return function () {\n          return _this._ch.writeUInt8(NULL);\n        };\n      } else if (x === true) {\n        return function () {\n          return _this._ch.writeUInt8(TRUE);\n        };\n      } else if (x === false) {\n        return function () {\n          return _this._ch.writeUInt8(FALSE);\n        };\n      } else if (typeof x === 'number') {\n        return function () {\n          return _this.packFloat(x);\n        };\n      } else if (typeof x === 'string') {\n        return function () {\n          return _this.packString(x);\n        };\n      } else if ((0, _integer.isInt)(x)) {\n        return function () {\n          return _this.packInteger(x);\n        };\n      } else if (x instanceof Int8Array) {\n        return function () {\n          return _this.packBytes(x);\n        };\n      } else if (x instanceof Array) {\n        return function () {\n          _this.packListHeader(x.length);\n\n          for (var _i = 0; _i < x.length; _i++) {\n            _this.packable(x[_i] === undefined ? null : x[_i])();\n          }\n        };\n      } else if (isIterable(x)) {\n        return this.packableIterable(x);\n      } else if (x instanceof _graphTypes.Node) {\n        return this._nonPackableValue(\"It is not allowed to pass nodes in query parameters, given: \".concat(x));\n      } else if (x instanceof _graphTypes.Relationship) {\n        return this._nonPackableValue(\"It is not allowed to pass relationships in query parameters, given: \".concat(x));\n      } else if (x instanceof _graphTypes.Path) {\n        return this._nonPackableValue(\"It is not allowed to pass paths in query parameters, given: \".concat(x));\n      } else if (x instanceof Structure) {\n        var packableFields = [];\n\n        for (var i = 0; i < x.fields.length; i++) {\n          packableFields[i] = this.packable(x.fields[i]);\n        }\n\n        return function () {\n          return _this.packStruct(x.signature, packableFields);\n        };\n      } else if ((0, _typeof2[\"default\"])(x) === 'object') {\n        return function () {\n          var keys = Object.keys(x);\n          var count = 0;\n\n          for (var _i2 = 0; _i2 < keys.length; _i2++) {\n            if (x[keys[_i2]] !== undefined) {\n              count++;\n            }\n          }\n\n          _this.packMapHeader(count);\n\n          for (var _i3 = 0; _i3 < keys.length; _i3++) {\n            var key = keys[_i3];\n\n            if (x[key] !== undefined) {\n              _this.packString(key);\n\n              _this.packable(x[key])();\n            }\n          }\n        };\n      } else {\n        return this._nonPackableValue(\"Unable to pack the given value: \".concat(x));\n      }\n    }\n  }, {\n    key: \"packableIterable\",\n    value: function packableIterable(iterable) {\n      try {\n        var array = Array.from(iterable);\n        return this.packable(array);\n      } catch (e) {\n        // handle errors from iterable to array conversion\n        throw (0, _error.newError)(\"Cannot pack given iterable, \".concat(e.message, \": \").concat(iterable));\n      }\n    }\n    /**\n     * Packs a struct\n     * @param signature the signature of the struct\n     * @param packableFields the fields of the struct, make sure you call `packable on all fields`\n     */\n\n  }, {\n    key: \"packStruct\",\n    value: function packStruct(signature, packableFields) {\n      packableFields = packableFields || [];\n      this.packStructHeader(packableFields.length, signature);\n\n      for (var i = 0; i < packableFields.length; i++) {\n        packableFields[i]();\n      }\n    }\n  }, {\n    key: \"packInteger\",\n    value: function packInteger(x) {\n      var high = x.high;\n      var low = x.low;\n\n      if (x.greaterThanOrEqual(-0x10) && x.lessThan(0x80)) {\n        this._ch.writeInt8(low);\n      } else if (x.greaterThanOrEqual(-0x80) && x.lessThan(-0x10)) {\n        this._ch.writeUInt8(INT_8);\n\n        this._ch.writeInt8(low);\n      } else if (x.greaterThanOrEqual(-0x8000) && x.lessThan(0x8000)) {\n        this._ch.writeUInt8(INT_16);\n\n        this._ch.writeInt16(low);\n      } else if (x.greaterThanOrEqual(-0x80000000) && x.lessThan(0x80000000)) {\n        this._ch.writeUInt8(INT_32);\n\n        this._ch.writeInt32(low);\n      } else {\n        this._ch.writeUInt8(INT_64);\n\n        this._ch.writeInt32(high);\n\n        this._ch.writeInt32(low);\n      }\n    }\n  }, {\n    key: \"packFloat\",\n    value: function packFloat(x) {\n      this._ch.writeUInt8(FLOAT_64);\n\n      this._ch.writeFloat64(x);\n    }\n  }, {\n    key: \"packString\",\n    value: function packString(x) {\n      var bytes = _node.utf8.encode(x);\n\n      var size = bytes.length;\n\n      if (size < 0x10) {\n        this._ch.writeUInt8(TINY_STRING | size);\n\n        this._ch.writeBytes(bytes);\n      } else if (size < 0x100) {\n        this._ch.writeUInt8(STRING_8);\n\n        this._ch.writeUInt8(size);\n\n        this._ch.writeBytes(bytes);\n      } else if (size < 0x10000) {\n        this._ch.writeUInt8(STRING_16);\n\n        this._ch.writeUInt8(size / 256 >> 0);\n\n        this._ch.writeUInt8(size % 256);\n\n        this._ch.writeBytes(bytes);\n      } else if (size < 0x100000000) {\n        this._ch.writeUInt8(STRING_32);\n\n        this._ch.writeUInt8((size / 16777216 >> 0) % 256);\n\n        this._ch.writeUInt8((size / 65536 >> 0) % 256);\n\n        this._ch.writeUInt8((size / 256 >> 0) % 256);\n\n        this._ch.writeUInt8(size % 256);\n\n        this._ch.writeBytes(bytes);\n      } else {\n        throw (0, _error.newError)('UTF-8 strings of size ' + size + ' are not supported');\n      }\n    }\n  }, {\n    key: \"packListHeader\",\n    value: function packListHeader(size) {\n      if (size < 0x10) {\n        this._ch.writeUInt8(TINY_LIST | size);\n      } else if (size < 0x100) {\n        this._ch.writeUInt8(LIST_8);\n\n        this._ch.writeUInt8(size);\n      } else if (size < 0x10000) {\n        this._ch.writeUInt8(LIST_16);\n\n        this._ch.writeUInt8((size / 256 >> 0) % 256);\n\n        this._ch.writeUInt8(size % 256);\n      } else if (size < 0x100000000) {\n        this._ch.writeUInt8(LIST_32);\n\n        this._ch.writeUInt8((size / 16777216 >> 0) % 256);\n\n        this._ch.writeUInt8((size / 65536 >> 0) % 256);\n\n        this._ch.writeUInt8((size / 256 >> 0) % 256);\n\n        this._ch.writeUInt8(size % 256);\n      } else {\n        throw (0, _error.newError)('Lists of size ' + size + ' are not supported');\n      }\n    }\n  }, {\n    key: \"packBytes\",\n    value: function packBytes(array) {\n      if (this._byteArraysSupported) {\n        this.packBytesHeader(array.length);\n\n        for (var i = 0; i < array.length; i++) {\n          this._ch.writeInt8(array[i]);\n        }\n      } else {\n        throw (0, _error.newError)('Byte arrays are not supported by the database this driver is connected to');\n      }\n    }\n  }, {\n    key: \"packBytesHeader\",\n    value: function packBytesHeader(size) {\n      if (size < 0x100) {\n        this._ch.writeUInt8(BYTES_8);\n\n        this._ch.writeUInt8(size);\n      } else if (size < 0x10000) {\n        this._ch.writeUInt8(BYTES_16);\n\n        this._ch.writeUInt8((size / 256 >> 0) % 256);\n\n        this._ch.writeUInt8(size % 256);\n      } else if (size < 0x100000000) {\n        this._ch.writeUInt8(BYTES_32);\n\n        this._ch.writeUInt8((size / 16777216 >> 0) % 256);\n\n        this._ch.writeUInt8((size / 65536 >> 0) % 256);\n\n        this._ch.writeUInt8((size / 256 >> 0) % 256);\n\n        this._ch.writeUInt8(size % 256);\n      } else {\n        throw (0, _error.newError)('Byte arrays of size ' + size + ' are not supported');\n      }\n    }\n  }, {\n    key: \"packMapHeader\",\n    value: function packMapHeader(size) {\n      if (size < 0x10) {\n        this._ch.writeUInt8(TINY_MAP | size);\n      } else if (size < 0x100) {\n        this._ch.writeUInt8(MAP_8);\n\n        this._ch.writeUInt8(size);\n      } else if (size < 0x10000) {\n        this._ch.writeUInt8(MAP_16);\n\n        this._ch.writeUInt8(size / 256 >> 0);\n\n        this._ch.writeUInt8(size % 256);\n      } else if (size < 0x100000000) {\n        this._ch.writeUInt8(MAP_32);\n\n        this._ch.writeUInt8((size / 16777216 >> 0) % 256);\n\n        this._ch.writeUInt8((size / 65536 >> 0) % 256);\n\n        this._ch.writeUInt8((size / 256 >> 0) % 256);\n\n        this._ch.writeUInt8(size % 256);\n      } else {\n        throw (0, _error.newError)('Maps of size ' + size + ' are not supported');\n      }\n    }\n  }, {\n    key: \"packStructHeader\",\n    value: function packStructHeader(size, signature) {\n      if (size < 0x10) {\n        this._ch.writeUInt8(TINY_STRUCT | size);\n\n        this._ch.writeUInt8(signature);\n      } else if (size < 0x100) {\n        this._ch.writeUInt8(STRUCT_8);\n\n        this._ch.writeUInt8(size);\n\n        this._ch.writeUInt8(signature);\n      } else if (size < 0x10000) {\n        this._ch.writeUInt8(STRUCT_16);\n\n        this._ch.writeUInt8(size / 256 >> 0);\n\n        this._ch.writeUInt8(size % 256);\n      } else {\n        throw (0, _error.newError)('Structures of size ' + size + ' are not supported');\n      }\n    }\n  }, {\n    key: \"disableByteArrays\",\n    value: function disableByteArrays() {\n      this._byteArraysSupported = false;\n    }\n  }, {\n    key: \"_nonPackableValue\",\n    value: function _nonPackableValue(message) {\n      return function () {\n        throw (0, _error.newError)(message, _error.PROTOCOL_ERROR);\n      };\n    }\n  }]);\n  return Packer;\n}();\n/**\n * Class to unpack\n * @access private\n */\n\n\nexports.Packer = Packer;\n\nvar Unpacker = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * @param {boolean} disableLosslessIntegers if this unpacker should convert all received integers to native JS numbers.\n   */\n  function Unpacker() {\n    var disableLosslessIntegers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    (0, _classCallCheck2[\"default\"])(this, Unpacker);\n    this._disableLosslessIntegers = disableLosslessIntegers;\n  }\n\n  (0, _createClass2[\"default\"])(Unpacker, [{\n    key: \"unpack\",\n    value: function unpack(buffer) {\n      var marker = buffer.readUInt8();\n      var markerHigh = marker & 0xf0;\n      var markerLow = marker & 0x0f;\n\n      if (marker === NULL) {\n        return null;\n      }\n\n      var _boolean = this._unpackBoolean(marker);\n\n      if (_boolean !== null) {\n        return _boolean;\n      }\n\n      var numberOrInteger = this._unpackNumberOrInteger(marker, buffer);\n\n      if (numberOrInteger !== null) {\n        if (this._disableLosslessIntegers && (0, _integer.isInt)(numberOrInteger)) {\n          return numberOrInteger.toNumberOrInfinity();\n        }\n\n        return numberOrInteger;\n      }\n\n      var string = this._unpackString(marker, markerHigh, markerLow, buffer);\n\n      if (string !== null) {\n        return string;\n      }\n\n      var list = this._unpackList(marker, markerHigh, markerLow, buffer);\n\n      if (list !== null) {\n        return list;\n      }\n\n      var byteArray = this._unpackByteArray(marker, buffer);\n\n      if (byteArray !== null) {\n        return byteArray;\n      }\n\n      var map = this._unpackMap(marker, markerHigh, markerLow, buffer);\n\n      if (map !== null) {\n        return map;\n      }\n\n      var struct = this._unpackStruct(marker, markerHigh, markerLow, buffer);\n\n      if (struct !== null) {\n        return struct;\n      }\n\n      throw (0, _error.newError)('Unknown packed value with marker ' + marker.toString(16));\n    }\n  }, {\n    key: \"unpackInteger\",\n    value: function unpackInteger(buffer) {\n      var marker = buffer.readUInt8();\n\n      var result = this._unpackInteger(marker, buffer);\n\n      if (result == null) {\n        throw (0, _error.newError)('Unable to unpack integer value with marker ' + marker.toString(16));\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_unpackBoolean\",\n    value: function _unpackBoolean(marker) {\n      if (marker === TRUE) {\n        return true;\n      } else if (marker === FALSE) {\n        return false;\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"_unpackNumberOrInteger\",\n    value: function _unpackNumberOrInteger(marker, buffer) {\n      if (marker === FLOAT_64) {\n        return buffer.readFloat64();\n      } else {\n        return this._unpackInteger(marker, buffer);\n      }\n    }\n  }, {\n    key: \"_unpackInteger\",\n    value: function _unpackInteger(marker, buffer) {\n      if (marker >= 0 && marker < 128) {\n        return (0, _integer[\"int\"])(marker);\n      } else if (marker >= 240 && marker < 256) {\n        return (0, _integer[\"int\"])(marker - 256);\n      } else if (marker === INT_8) {\n        return (0, _integer[\"int\"])(buffer.readInt8());\n      } else if (marker === INT_16) {\n        return (0, _integer[\"int\"])(buffer.readInt16());\n      } else if (marker === INT_32) {\n        var b = buffer.readInt32();\n        return (0, _integer[\"int\"])(b);\n      } else if (marker === INT_64) {\n        var high = buffer.readInt32();\n        var low = buffer.readInt32();\n        return new _integer[\"default\"](low, high);\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"_unpackString\",\n    value: function _unpackString(marker, markerHigh, markerLow, buffer) {\n      if (markerHigh === TINY_STRING) {\n        return _node.utf8.decode(buffer, markerLow);\n      } else if (marker === STRING_8) {\n        return _node.utf8.decode(buffer, buffer.readUInt8());\n      } else if (marker === STRING_16) {\n        return _node.utf8.decode(buffer, buffer.readUInt16());\n      } else if (marker === STRING_32) {\n        return _node.utf8.decode(buffer, buffer.readUInt32());\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"_unpackList\",\n    value: function _unpackList(marker, markerHigh, markerLow, buffer) {\n      if (markerHigh === TINY_LIST) {\n        return this._unpackListWithSize(markerLow, buffer);\n      } else if (marker === LIST_8) {\n        return this._unpackListWithSize(buffer.readUInt8(), buffer);\n      } else if (marker === LIST_16) {\n        return this._unpackListWithSize(buffer.readUInt16(), buffer);\n      } else if (marker === LIST_32) {\n        return this._unpackListWithSize(buffer.readUInt32(), buffer);\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"_unpackListWithSize\",\n    value: function _unpackListWithSize(size, buffer) {\n      var value = [];\n\n      for (var i = 0; i < size; i++) {\n        value.push(this.unpack(buffer));\n      }\n\n      return value;\n    }\n  }, {\n    key: \"_unpackByteArray\",\n    value: function _unpackByteArray(marker, buffer) {\n      if (marker === BYTES_8) {\n        return this._unpackByteArrayWithSize(buffer.readUInt8(), buffer);\n      } else if (marker === BYTES_16) {\n        return this._unpackByteArrayWithSize(buffer.readUInt16(), buffer);\n      } else if (marker === BYTES_32) {\n        return this._unpackByteArrayWithSize(buffer.readUInt32(), buffer);\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"_unpackByteArrayWithSize\",\n    value: function _unpackByteArrayWithSize(size, buffer) {\n      var value = new Int8Array(size);\n\n      for (var i = 0; i < size; i++) {\n        value[i] = buffer.readInt8();\n      }\n\n      return value;\n    }\n  }, {\n    key: \"_unpackMap\",\n    value: function _unpackMap(marker, markerHigh, markerLow, buffer) {\n      if (markerHigh === TINY_MAP) {\n        return this._unpackMapWithSize(markerLow, buffer);\n      } else if (marker === MAP_8) {\n        return this._unpackMapWithSize(buffer.readUInt8(), buffer);\n      } else if (marker === MAP_16) {\n        return this._unpackMapWithSize(buffer.readUInt16(), buffer);\n      } else if (marker === MAP_32) {\n        return this._unpackMapWithSize(buffer.readUInt32(), buffer);\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"_unpackMapWithSize\",\n    value: function _unpackMapWithSize(size, buffer) {\n      var value = {};\n\n      for (var i = 0; i < size; i++) {\n        var key = this.unpack(buffer);\n        value[key] = this.unpack(buffer);\n      }\n\n      return value;\n    }\n  }, {\n    key: \"_unpackStruct\",\n    value: function _unpackStruct(marker, markerHigh, markerLow, buffer) {\n      if (markerHigh === TINY_STRUCT) {\n        return this._unpackStructWithSize(markerLow, buffer);\n      } else if (marker === STRUCT_8) {\n        return this._unpackStructWithSize(buffer.readUInt8(), buffer);\n      } else if (marker === STRUCT_16) {\n        return this._unpackStructWithSize(buffer.readUInt16(), buffer);\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"_unpackStructWithSize\",\n    value: function _unpackStructWithSize(structSize, buffer) {\n      var signature = buffer.readUInt8();\n\n      if (signature === NODE) {\n        return this._unpackNode(structSize, buffer);\n      } else if (signature === RELATIONSHIP) {\n        return this._unpackRelationship(structSize, buffer);\n      } else if (signature === UNBOUND_RELATIONSHIP) {\n        return this._unpackUnboundRelationship(structSize, buffer);\n      } else if (signature === PATH) {\n        return this._unpackPath(structSize, buffer);\n      } else {\n        return this._unpackUnknownStruct(signature, structSize, buffer);\n      }\n    }\n  }, {\n    key: \"_unpackNode\",\n    value: function _unpackNode(structSize, buffer) {\n      this._verifyStructSize('Node', NODE_STRUCT_SIZE, structSize);\n\n      return new _graphTypes.Node(this.unpack(buffer), // Identity\n      this.unpack(buffer), // Labels\n      this.unpack(buffer) // Properties\n      );\n    }\n  }, {\n    key: \"_unpackRelationship\",\n    value: function _unpackRelationship(structSize, buffer) {\n      this._verifyStructSize('Relationship', RELATIONSHIP_STRUCT_SIZE, structSize);\n\n      return new _graphTypes.Relationship(this.unpack(buffer), // Identity\n      this.unpack(buffer), // Start Node Identity\n      this.unpack(buffer), // End Node Identity\n      this.unpack(buffer), // Type\n      this.unpack(buffer) // Properties\n      );\n    }\n  }, {\n    key: \"_unpackUnboundRelationship\",\n    value: function _unpackUnboundRelationship(structSize, buffer) {\n      this._verifyStructSize('UnboundRelationship', UNBOUND_RELATIONSHIP_STRUCT_SIZE, structSize);\n\n      return new _graphTypes.UnboundRelationship(this.unpack(buffer), // Identity\n      this.unpack(buffer), // Type\n      this.unpack(buffer) // Properties\n      );\n    }\n  }, {\n    key: \"_unpackPath\",\n    value: function _unpackPath(structSize, buffer) {\n      this._verifyStructSize('Path', PATH_STRUCT_SIZE, structSize);\n\n      var nodes = this.unpack(buffer);\n      var rels = this.unpack(buffer);\n      var sequence = this.unpack(buffer);\n      var segments = [];\n      var prevNode = nodes[0];\n\n      for (var i = 0; i < sequence.length; i += 2) {\n        var nextNode = nodes[sequence[i + 1]];\n        var relIndex = sequence[i];\n        var rel = void 0;\n\n        if (relIndex > 0) {\n          rel = rels[relIndex - 1];\n\n          if (rel instanceof _graphTypes.UnboundRelationship) {\n            // To avoid duplication, relationships in a path do not contain\n            // information about their start and end nodes, that's instead\n            // inferred from the path sequence. This is us inferring (and,\n            // for performance reasons remembering) the start/end of a rel.\n            rels[relIndex - 1] = rel = rel.bind(prevNode.identity, nextNode.identity);\n          }\n        } else {\n          rel = rels[-relIndex - 1];\n\n          if (rel instanceof _graphTypes.UnboundRelationship) {\n            // See above\n            rels[-relIndex - 1] = rel = rel.bind(nextNode.identity, prevNode.identity);\n          }\n        } // Done hydrating one path segment.\n\n\n        segments.push(new _graphTypes.PathSegment(prevNode, rel, nextNode));\n        prevNode = nextNode;\n      }\n\n      return new _graphTypes.Path(nodes[0], nodes[nodes.length - 1], segments);\n    }\n  }, {\n    key: \"_unpackUnknownStruct\",\n    value: function _unpackUnknownStruct(signature, structSize, buffer) {\n      var result = new Structure(signature, []);\n\n      for (var i = 0; i < structSize; i++) {\n        result.fields.push(this.unpack(buffer));\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_verifyStructSize\",\n    value: function _verifyStructSize(structName, expectedSize, actualSize) {\n      if (expectedSize !== actualSize) {\n        throw (0, _error.newError)(\"Wrong struct size for \".concat(structName, \", expected \").concat(expectedSize, \" but was \").concat(actualSize), _error.PROTOCOL_ERROR);\n      }\n    }\n  }]);\n  return Unpacker;\n}();\n\nexports.Unpacker = Unpacker;\n\nfunction isIterable(obj) {\n  if (obj == null) {\n    return false;\n  }\n\n  return typeof obj[Symbol.iterator] === 'function';\n}","map":{"version":3,"sources":["d:/webback/pro5/node_modules/neo4j-driver/lib/internal/packstream-v1.js"],"names":["_interopRequireWildcard","require","_interopRequireDefault","Object","defineProperty","exports","value","Structure","Unpacker","Packer","_typeof2","_classCallCheck2","_createClass2","_node","_integer","_error","_graphTypes","TINY_STRING","TINY_LIST","TINY_MAP","TINY_STRUCT","NULL","FLOAT_64","FALSE","TRUE","INT_8","INT_16","INT_32","INT_64","STRING_8","STRING_16","STRING_32","LIST_8","LIST_16","LIST_32","BYTES_8","BYTES_16","BYTES_32","MAP_8","MAP_16","MAP_32","STRUCT_8","STRUCT_16","NODE","NODE_STRUCT_SIZE","RELATIONSHIP","RELATIONSHIP_STRUCT_SIZE","UNBOUND_RELATIONSHIP","UNBOUND_RELATIONSHIP_STRUCT_SIZE","PATH","PATH_STRUCT_SIZE","signature","fields","key","toString","fieldStr","i","length","channel","_ch","_byteArraysSupported","packable","x","_this","writeUInt8","packFloat","packString","isInt","packInteger","Int8Array","packBytes","Array","packListHeader","_i","undefined","isIterable","packableIterable","Node","_nonPackableValue","concat","Relationship","Path","packableFields","packStruct","keys","count","_i2","packMapHeader","_i3","iterable","array","from","e","newError","message","packStructHeader","high","low","greaterThanOrEqual","lessThan","writeInt8","writeInt16","writeInt32","writeFloat64","bytes","utf8","encode","size","writeBytes","packBytesHeader","disableByteArrays","PROTOCOL_ERROR","disableLosslessIntegers","arguments","_disableLosslessIntegers","unpack","buffer","marker","readUInt8","markerHigh","markerLow","_boolean","_unpackBoolean","numberOrInteger","_unpackNumberOrInteger","toNumberOrInfinity","string","_unpackString","list","_unpackList","byteArray","_unpackByteArray","map","_unpackMap","struct","_unpackStruct","unpackInteger","result","_unpackInteger","readFloat64","readInt8","readInt16","b","readInt32","decode","readUInt16","readUInt32","_unpackListWithSize","push","_unpackByteArrayWithSize","_unpackMapWithSize","_unpackStructWithSize","structSize","_unpackNode","_unpackRelationship","_unpackUnboundRelationship","_unpackPath","_unpackUnknownStruct","_verifyStructSize","UnboundRelationship","nodes","rels","sequence","segments","prevNode","nextNode","relIndex","rel","bind","identity","PathSegment","structName","expectedSize","actualSize","obj","Symbol","iterator"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Structure = exports.Unpacker = exports.Packer = void 0;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _node = require(\"./node\");\n\nvar _integer = _interopRequireWildcard(require(\"../integer\"));\n\nvar _error = require(\"../error\");\n\nvar _graphTypes = require(\"../graph-types\");\n\n/**\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar TINY_STRING = 0x80;\nvar TINY_LIST = 0x90;\nvar TINY_MAP = 0xa0;\nvar TINY_STRUCT = 0xb0;\nvar NULL = 0xc0;\nvar FLOAT_64 = 0xc1;\nvar FALSE = 0xc2;\nvar TRUE = 0xc3;\nvar INT_8 = 0xc8;\nvar INT_16 = 0xc9;\nvar INT_32 = 0xca;\nvar INT_64 = 0xcb;\nvar STRING_8 = 0xd0;\nvar STRING_16 = 0xd1;\nvar STRING_32 = 0xd2;\nvar LIST_8 = 0xd4;\nvar LIST_16 = 0xd5;\nvar LIST_32 = 0xd6;\nvar BYTES_8 = 0xcc;\nvar BYTES_16 = 0xcd;\nvar BYTES_32 = 0xce;\nvar MAP_8 = 0xd8;\nvar MAP_16 = 0xd9;\nvar MAP_32 = 0xda;\nvar STRUCT_8 = 0xdc;\nvar STRUCT_16 = 0xdd;\nvar NODE = 0x4e;\nvar NODE_STRUCT_SIZE = 3;\nvar RELATIONSHIP = 0x52;\nvar RELATIONSHIP_STRUCT_SIZE = 5;\nvar UNBOUND_RELATIONSHIP = 0x72;\nvar UNBOUND_RELATIONSHIP_STRUCT_SIZE = 3;\nvar PATH = 0x50;\nvar PATH_STRUCT_SIZE = 3;\n/**\n * A Structure have a signature and fields.\n * @access private\n */\n\nvar Structure =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Create new instance\n   */\n  function Structure(signature, fields) {\n    (0, _classCallCheck2[\"default\"])(this, Structure);\n    this.signature = signature;\n    this.fields = fields;\n  }\n\n  (0, _createClass2[\"default\"])(Structure, [{\n    key: \"toString\",\n    value: function toString() {\n      var fieldStr = '';\n\n      for (var i = 0; i < this.fields.length; i++) {\n        if (i > 0) {\n          fieldStr += ', ';\n        }\n\n        fieldStr += this.fields[i];\n      }\n\n      return 'Structure(' + this.signature + ', [' + fieldStr + '])';\n    }\n  }]);\n  return Structure;\n}();\n/**\n * Class to pack\n * @access private\n */\n\n\nexports.Structure = Structure;\n\nvar Packer =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @constructor\n   * @param {Chunker} channel the chunker backed by a network channel.\n   */\n  function Packer(channel) {\n    (0, _classCallCheck2[\"default\"])(this, Packer);\n    this._ch = channel;\n    this._byteArraysSupported = true;\n  }\n  /**\n   * Creates a packable function out of the provided value\n   * @param x the value to pack\n   * @returns Function\n   */\n\n\n  (0, _createClass2[\"default\"])(Packer, [{\n    key: \"packable\",\n    value: function packable(x) {\n      var _this = this;\n\n      if (x === null) {\n        return function () {\n          return _this._ch.writeUInt8(NULL);\n        };\n      } else if (x === true) {\n        return function () {\n          return _this._ch.writeUInt8(TRUE);\n        };\n      } else if (x === false) {\n        return function () {\n          return _this._ch.writeUInt8(FALSE);\n        };\n      } else if (typeof x === 'number') {\n        return function () {\n          return _this.packFloat(x);\n        };\n      } else if (typeof x === 'string') {\n        return function () {\n          return _this.packString(x);\n        };\n      } else if ((0, _integer.isInt)(x)) {\n        return function () {\n          return _this.packInteger(x);\n        };\n      } else if (x instanceof Int8Array) {\n        return function () {\n          return _this.packBytes(x);\n        };\n      } else if (x instanceof Array) {\n        return function () {\n          _this.packListHeader(x.length);\n\n          for (var _i = 0; _i < x.length; _i++) {\n            _this.packable(x[_i] === undefined ? null : x[_i])();\n          }\n        };\n      } else if (isIterable(x)) {\n        return this.packableIterable(x);\n      } else if (x instanceof _graphTypes.Node) {\n        return this._nonPackableValue(\"It is not allowed to pass nodes in query parameters, given: \".concat(x));\n      } else if (x instanceof _graphTypes.Relationship) {\n        return this._nonPackableValue(\"It is not allowed to pass relationships in query parameters, given: \".concat(x));\n      } else if (x instanceof _graphTypes.Path) {\n        return this._nonPackableValue(\"It is not allowed to pass paths in query parameters, given: \".concat(x));\n      } else if (x instanceof Structure) {\n        var packableFields = [];\n\n        for (var i = 0; i < x.fields.length; i++) {\n          packableFields[i] = this.packable(x.fields[i]);\n        }\n\n        return function () {\n          return _this.packStruct(x.signature, packableFields);\n        };\n      } else if ((0, _typeof2[\"default\"])(x) === 'object') {\n        return function () {\n          var keys = Object.keys(x);\n          var count = 0;\n\n          for (var _i2 = 0; _i2 < keys.length; _i2++) {\n            if (x[keys[_i2]] !== undefined) {\n              count++;\n            }\n          }\n\n          _this.packMapHeader(count);\n\n          for (var _i3 = 0; _i3 < keys.length; _i3++) {\n            var key = keys[_i3];\n\n            if (x[key] !== undefined) {\n              _this.packString(key);\n\n              _this.packable(x[key])();\n            }\n          }\n        };\n      } else {\n        return this._nonPackableValue(\"Unable to pack the given value: \".concat(x));\n      }\n    }\n  }, {\n    key: \"packableIterable\",\n    value: function packableIterable(iterable) {\n      try {\n        var array = Array.from(iterable);\n        return this.packable(array);\n      } catch (e) {\n        // handle errors from iterable to array conversion\n        throw (0, _error.newError)(\"Cannot pack given iterable, \".concat(e.message, \": \").concat(iterable));\n      }\n    }\n    /**\n     * Packs a struct\n     * @param signature the signature of the struct\n     * @param packableFields the fields of the struct, make sure you call `packable on all fields`\n     */\n\n  }, {\n    key: \"packStruct\",\n    value: function packStruct(signature, packableFields) {\n      packableFields = packableFields || [];\n      this.packStructHeader(packableFields.length, signature);\n\n      for (var i = 0; i < packableFields.length; i++) {\n        packableFields[i]();\n      }\n    }\n  }, {\n    key: \"packInteger\",\n    value: function packInteger(x) {\n      var high = x.high;\n      var low = x.low;\n\n      if (x.greaterThanOrEqual(-0x10) && x.lessThan(0x80)) {\n        this._ch.writeInt8(low);\n      } else if (x.greaterThanOrEqual(-0x80) && x.lessThan(-0x10)) {\n        this._ch.writeUInt8(INT_8);\n\n        this._ch.writeInt8(low);\n      } else if (x.greaterThanOrEqual(-0x8000) && x.lessThan(0x8000)) {\n        this._ch.writeUInt8(INT_16);\n\n        this._ch.writeInt16(low);\n      } else if (x.greaterThanOrEqual(-0x80000000) && x.lessThan(0x80000000)) {\n        this._ch.writeUInt8(INT_32);\n\n        this._ch.writeInt32(low);\n      } else {\n        this._ch.writeUInt8(INT_64);\n\n        this._ch.writeInt32(high);\n\n        this._ch.writeInt32(low);\n      }\n    }\n  }, {\n    key: \"packFloat\",\n    value: function packFloat(x) {\n      this._ch.writeUInt8(FLOAT_64);\n\n      this._ch.writeFloat64(x);\n    }\n  }, {\n    key: \"packString\",\n    value: function packString(x) {\n      var bytes = _node.utf8.encode(x);\n\n      var size = bytes.length;\n\n      if (size < 0x10) {\n        this._ch.writeUInt8(TINY_STRING | size);\n\n        this._ch.writeBytes(bytes);\n      } else if (size < 0x100) {\n        this._ch.writeUInt8(STRING_8);\n\n        this._ch.writeUInt8(size);\n\n        this._ch.writeBytes(bytes);\n      } else if (size < 0x10000) {\n        this._ch.writeUInt8(STRING_16);\n\n        this._ch.writeUInt8(size / 256 >> 0);\n\n        this._ch.writeUInt8(size % 256);\n\n        this._ch.writeBytes(bytes);\n      } else if (size < 0x100000000) {\n        this._ch.writeUInt8(STRING_32);\n\n        this._ch.writeUInt8((size / 16777216 >> 0) % 256);\n\n        this._ch.writeUInt8((size / 65536 >> 0) % 256);\n\n        this._ch.writeUInt8((size / 256 >> 0) % 256);\n\n        this._ch.writeUInt8(size % 256);\n\n        this._ch.writeBytes(bytes);\n      } else {\n        throw (0, _error.newError)('UTF-8 strings of size ' + size + ' are not supported');\n      }\n    }\n  }, {\n    key: \"packListHeader\",\n    value: function packListHeader(size) {\n      if (size < 0x10) {\n        this._ch.writeUInt8(TINY_LIST | size);\n      } else if (size < 0x100) {\n        this._ch.writeUInt8(LIST_8);\n\n        this._ch.writeUInt8(size);\n      } else if (size < 0x10000) {\n        this._ch.writeUInt8(LIST_16);\n\n        this._ch.writeUInt8((size / 256 >> 0) % 256);\n\n        this._ch.writeUInt8(size % 256);\n      } else if (size < 0x100000000) {\n        this._ch.writeUInt8(LIST_32);\n\n        this._ch.writeUInt8((size / 16777216 >> 0) % 256);\n\n        this._ch.writeUInt8((size / 65536 >> 0) % 256);\n\n        this._ch.writeUInt8((size / 256 >> 0) % 256);\n\n        this._ch.writeUInt8(size % 256);\n      } else {\n        throw (0, _error.newError)('Lists of size ' + size + ' are not supported');\n      }\n    }\n  }, {\n    key: \"packBytes\",\n    value: function packBytes(array) {\n      if (this._byteArraysSupported) {\n        this.packBytesHeader(array.length);\n\n        for (var i = 0; i < array.length; i++) {\n          this._ch.writeInt8(array[i]);\n        }\n      } else {\n        throw (0, _error.newError)('Byte arrays are not supported by the database this driver is connected to');\n      }\n    }\n  }, {\n    key: \"packBytesHeader\",\n    value: function packBytesHeader(size) {\n      if (size < 0x100) {\n        this._ch.writeUInt8(BYTES_8);\n\n        this._ch.writeUInt8(size);\n      } else if (size < 0x10000) {\n        this._ch.writeUInt8(BYTES_16);\n\n        this._ch.writeUInt8((size / 256 >> 0) % 256);\n\n        this._ch.writeUInt8(size % 256);\n      } else if (size < 0x100000000) {\n        this._ch.writeUInt8(BYTES_32);\n\n        this._ch.writeUInt8((size / 16777216 >> 0) % 256);\n\n        this._ch.writeUInt8((size / 65536 >> 0) % 256);\n\n        this._ch.writeUInt8((size / 256 >> 0) % 256);\n\n        this._ch.writeUInt8(size % 256);\n      } else {\n        throw (0, _error.newError)('Byte arrays of size ' + size + ' are not supported');\n      }\n    }\n  }, {\n    key: \"packMapHeader\",\n    value: function packMapHeader(size) {\n      if (size < 0x10) {\n        this._ch.writeUInt8(TINY_MAP | size);\n      } else if (size < 0x100) {\n        this._ch.writeUInt8(MAP_8);\n\n        this._ch.writeUInt8(size);\n      } else if (size < 0x10000) {\n        this._ch.writeUInt8(MAP_16);\n\n        this._ch.writeUInt8(size / 256 >> 0);\n\n        this._ch.writeUInt8(size % 256);\n      } else if (size < 0x100000000) {\n        this._ch.writeUInt8(MAP_32);\n\n        this._ch.writeUInt8((size / 16777216 >> 0) % 256);\n\n        this._ch.writeUInt8((size / 65536 >> 0) % 256);\n\n        this._ch.writeUInt8((size / 256 >> 0) % 256);\n\n        this._ch.writeUInt8(size % 256);\n      } else {\n        throw (0, _error.newError)('Maps of size ' + size + ' are not supported');\n      }\n    }\n  }, {\n    key: \"packStructHeader\",\n    value: function packStructHeader(size, signature) {\n      if (size < 0x10) {\n        this._ch.writeUInt8(TINY_STRUCT | size);\n\n        this._ch.writeUInt8(signature);\n      } else if (size < 0x100) {\n        this._ch.writeUInt8(STRUCT_8);\n\n        this._ch.writeUInt8(size);\n\n        this._ch.writeUInt8(signature);\n      } else if (size < 0x10000) {\n        this._ch.writeUInt8(STRUCT_16);\n\n        this._ch.writeUInt8(size / 256 >> 0);\n\n        this._ch.writeUInt8(size % 256);\n      } else {\n        throw (0, _error.newError)('Structures of size ' + size + ' are not supported');\n      }\n    }\n  }, {\n    key: \"disableByteArrays\",\n    value: function disableByteArrays() {\n      this._byteArraysSupported = false;\n    }\n  }, {\n    key: \"_nonPackableValue\",\n    value: function _nonPackableValue(message) {\n      return function () {\n        throw (0, _error.newError)(message, _error.PROTOCOL_ERROR);\n      };\n    }\n  }]);\n  return Packer;\n}();\n/**\n * Class to unpack\n * @access private\n */\n\n\nexports.Packer = Packer;\n\nvar Unpacker =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @constructor\n   * @param {boolean} disableLosslessIntegers if this unpacker should convert all received integers to native JS numbers.\n   */\n  function Unpacker() {\n    var disableLosslessIntegers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    (0, _classCallCheck2[\"default\"])(this, Unpacker);\n    this._disableLosslessIntegers = disableLosslessIntegers;\n  }\n\n  (0, _createClass2[\"default\"])(Unpacker, [{\n    key: \"unpack\",\n    value: function unpack(buffer) {\n      var marker = buffer.readUInt8();\n      var markerHigh = marker & 0xf0;\n      var markerLow = marker & 0x0f;\n\n      if (marker === NULL) {\n        return null;\n      }\n\n      var _boolean = this._unpackBoolean(marker);\n\n      if (_boolean !== null) {\n        return _boolean;\n      }\n\n      var numberOrInteger = this._unpackNumberOrInteger(marker, buffer);\n\n      if (numberOrInteger !== null) {\n        if (this._disableLosslessIntegers && (0, _integer.isInt)(numberOrInteger)) {\n          return numberOrInteger.toNumberOrInfinity();\n        }\n\n        return numberOrInteger;\n      }\n\n      var string = this._unpackString(marker, markerHigh, markerLow, buffer);\n\n      if (string !== null) {\n        return string;\n      }\n\n      var list = this._unpackList(marker, markerHigh, markerLow, buffer);\n\n      if (list !== null) {\n        return list;\n      }\n\n      var byteArray = this._unpackByteArray(marker, buffer);\n\n      if (byteArray !== null) {\n        return byteArray;\n      }\n\n      var map = this._unpackMap(marker, markerHigh, markerLow, buffer);\n\n      if (map !== null) {\n        return map;\n      }\n\n      var struct = this._unpackStruct(marker, markerHigh, markerLow, buffer);\n\n      if (struct !== null) {\n        return struct;\n      }\n\n      throw (0, _error.newError)('Unknown packed value with marker ' + marker.toString(16));\n    }\n  }, {\n    key: \"unpackInteger\",\n    value: function unpackInteger(buffer) {\n      var marker = buffer.readUInt8();\n\n      var result = this._unpackInteger(marker, buffer);\n\n      if (result == null) {\n        throw (0, _error.newError)('Unable to unpack integer value with marker ' + marker.toString(16));\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_unpackBoolean\",\n    value: function _unpackBoolean(marker) {\n      if (marker === TRUE) {\n        return true;\n      } else if (marker === FALSE) {\n        return false;\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"_unpackNumberOrInteger\",\n    value: function _unpackNumberOrInteger(marker, buffer) {\n      if (marker === FLOAT_64) {\n        return buffer.readFloat64();\n      } else {\n        return this._unpackInteger(marker, buffer);\n      }\n    }\n  }, {\n    key: \"_unpackInteger\",\n    value: function _unpackInteger(marker, buffer) {\n      if (marker >= 0 && marker < 128) {\n        return (0, _integer[\"int\"])(marker);\n      } else if (marker >= 240 && marker < 256) {\n        return (0, _integer[\"int\"])(marker - 256);\n      } else if (marker === INT_8) {\n        return (0, _integer[\"int\"])(buffer.readInt8());\n      } else if (marker === INT_16) {\n        return (0, _integer[\"int\"])(buffer.readInt16());\n      } else if (marker === INT_32) {\n        var b = buffer.readInt32();\n        return (0, _integer[\"int\"])(b);\n      } else if (marker === INT_64) {\n        var high = buffer.readInt32();\n        var low = buffer.readInt32();\n        return new _integer[\"default\"](low, high);\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"_unpackString\",\n    value: function _unpackString(marker, markerHigh, markerLow, buffer) {\n      if (markerHigh === TINY_STRING) {\n        return _node.utf8.decode(buffer, markerLow);\n      } else if (marker === STRING_8) {\n        return _node.utf8.decode(buffer, buffer.readUInt8());\n      } else if (marker === STRING_16) {\n        return _node.utf8.decode(buffer, buffer.readUInt16());\n      } else if (marker === STRING_32) {\n        return _node.utf8.decode(buffer, buffer.readUInt32());\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"_unpackList\",\n    value: function _unpackList(marker, markerHigh, markerLow, buffer) {\n      if (markerHigh === TINY_LIST) {\n        return this._unpackListWithSize(markerLow, buffer);\n      } else if (marker === LIST_8) {\n        return this._unpackListWithSize(buffer.readUInt8(), buffer);\n      } else if (marker === LIST_16) {\n        return this._unpackListWithSize(buffer.readUInt16(), buffer);\n      } else if (marker === LIST_32) {\n        return this._unpackListWithSize(buffer.readUInt32(), buffer);\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"_unpackListWithSize\",\n    value: function _unpackListWithSize(size, buffer) {\n      var value = [];\n\n      for (var i = 0; i < size; i++) {\n        value.push(this.unpack(buffer));\n      }\n\n      return value;\n    }\n  }, {\n    key: \"_unpackByteArray\",\n    value: function _unpackByteArray(marker, buffer) {\n      if (marker === BYTES_8) {\n        return this._unpackByteArrayWithSize(buffer.readUInt8(), buffer);\n      } else if (marker === BYTES_16) {\n        return this._unpackByteArrayWithSize(buffer.readUInt16(), buffer);\n      } else if (marker === BYTES_32) {\n        return this._unpackByteArrayWithSize(buffer.readUInt32(), buffer);\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"_unpackByteArrayWithSize\",\n    value: function _unpackByteArrayWithSize(size, buffer) {\n      var value = new Int8Array(size);\n\n      for (var i = 0; i < size; i++) {\n        value[i] = buffer.readInt8();\n      }\n\n      return value;\n    }\n  }, {\n    key: \"_unpackMap\",\n    value: function _unpackMap(marker, markerHigh, markerLow, buffer) {\n      if (markerHigh === TINY_MAP) {\n        return this._unpackMapWithSize(markerLow, buffer);\n      } else if (marker === MAP_8) {\n        return this._unpackMapWithSize(buffer.readUInt8(), buffer);\n      } else if (marker === MAP_16) {\n        return this._unpackMapWithSize(buffer.readUInt16(), buffer);\n      } else if (marker === MAP_32) {\n        return this._unpackMapWithSize(buffer.readUInt32(), buffer);\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"_unpackMapWithSize\",\n    value: function _unpackMapWithSize(size, buffer) {\n      var value = {};\n\n      for (var i = 0; i < size; i++) {\n        var key = this.unpack(buffer);\n        value[key] = this.unpack(buffer);\n      }\n\n      return value;\n    }\n  }, {\n    key: \"_unpackStruct\",\n    value: function _unpackStruct(marker, markerHigh, markerLow, buffer) {\n      if (markerHigh === TINY_STRUCT) {\n        return this._unpackStructWithSize(markerLow, buffer);\n      } else if (marker === STRUCT_8) {\n        return this._unpackStructWithSize(buffer.readUInt8(), buffer);\n      } else if (marker === STRUCT_16) {\n        return this._unpackStructWithSize(buffer.readUInt16(), buffer);\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"_unpackStructWithSize\",\n    value: function _unpackStructWithSize(structSize, buffer) {\n      var signature = buffer.readUInt8();\n\n      if (signature === NODE) {\n        return this._unpackNode(structSize, buffer);\n      } else if (signature === RELATIONSHIP) {\n        return this._unpackRelationship(structSize, buffer);\n      } else if (signature === UNBOUND_RELATIONSHIP) {\n        return this._unpackUnboundRelationship(structSize, buffer);\n      } else if (signature === PATH) {\n        return this._unpackPath(structSize, buffer);\n      } else {\n        return this._unpackUnknownStruct(signature, structSize, buffer);\n      }\n    }\n  }, {\n    key: \"_unpackNode\",\n    value: function _unpackNode(structSize, buffer) {\n      this._verifyStructSize('Node', NODE_STRUCT_SIZE, structSize);\n\n      return new _graphTypes.Node(this.unpack(buffer), // Identity\n      this.unpack(buffer), // Labels\n      this.unpack(buffer) // Properties\n      );\n    }\n  }, {\n    key: \"_unpackRelationship\",\n    value: function _unpackRelationship(structSize, buffer) {\n      this._verifyStructSize('Relationship', RELATIONSHIP_STRUCT_SIZE, structSize);\n\n      return new _graphTypes.Relationship(this.unpack(buffer), // Identity\n      this.unpack(buffer), // Start Node Identity\n      this.unpack(buffer), // End Node Identity\n      this.unpack(buffer), // Type\n      this.unpack(buffer) // Properties\n      );\n    }\n  }, {\n    key: \"_unpackUnboundRelationship\",\n    value: function _unpackUnboundRelationship(structSize, buffer) {\n      this._verifyStructSize('UnboundRelationship', UNBOUND_RELATIONSHIP_STRUCT_SIZE, structSize);\n\n      return new _graphTypes.UnboundRelationship(this.unpack(buffer), // Identity\n      this.unpack(buffer), // Type\n      this.unpack(buffer) // Properties\n      );\n    }\n  }, {\n    key: \"_unpackPath\",\n    value: function _unpackPath(structSize, buffer) {\n      this._verifyStructSize('Path', PATH_STRUCT_SIZE, structSize);\n\n      var nodes = this.unpack(buffer);\n      var rels = this.unpack(buffer);\n      var sequence = this.unpack(buffer);\n      var segments = [];\n      var prevNode = nodes[0];\n\n      for (var i = 0; i < sequence.length; i += 2) {\n        var nextNode = nodes[sequence[i + 1]];\n        var relIndex = sequence[i];\n        var rel = void 0;\n\n        if (relIndex > 0) {\n          rel = rels[relIndex - 1];\n\n          if (rel instanceof _graphTypes.UnboundRelationship) {\n            // To avoid duplication, relationships in a path do not contain\n            // information about their start and end nodes, that's instead\n            // inferred from the path sequence. This is us inferring (and,\n            // for performance reasons remembering) the start/end of a rel.\n            rels[relIndex - 1] = rel = rel.bind(prevNode.identity, nextNode.identity);\n          }\n        } else {\n          rel = rels[-relIndex - 1];\n\n          if (rel instanceof _graphTypes.UnboundRelationship) {\n            // See above\n            rels[-relIndex - 1] = rel = rel.bind(nextNode.identity, prevNode.identity);\n          }\n        } // Done hydrating one path segment.\n\n\n        segments.push(new _graphTypes.PathSegment(prevNode, rel, nextNode));\n        prevNode = nextNode;\n      }\n\n      return new _graphTypes.Path(nodes[0], nodes[nodes.length - 1], segments);\n    }\n  }, {\n    key: \"_unpackUnknownStruct\",\n    value: function _unpackUnknownStruct(signature, structSize, buffer) {\n      var result = new Structure(signature, []);\n\n      for (var i = 0; i < structSize; i++) {\n        result.fields.push(this.unpack(buffer));\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_verifyStructSize\",\n    value: function _verifyStructSize(structName, expectedSize, actualSize) {\n      if (expectedSize !== actualSize) {\n        throw (0, _error.newError)(\"Wrong struct size for \".concat(structName, \", expected \").concat(expectedSize, \" but was \").concat(actualSize), _error.PROTOCOL_ERROR);\n      }\n    }\n  }]);\n  return Unpacker;\n}();\n\nexports.Unpacker = Unpacker;\n\nfunction isIterable(obj) {\n  if (obj == null) {\n    return false;\n  }\n\n  return typeof obj[Symbol.iterator] === 'function';\n}"]},"metadata":{},"sourceType":"script"}