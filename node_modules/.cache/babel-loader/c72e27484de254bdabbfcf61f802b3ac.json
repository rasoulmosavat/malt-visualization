{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isNode = isNode;\nexports.isRelationship = isRelationship;\nexports.isUnboundRelationship = isUnboundRelationship;\nexports.isPath = isPath;\nexports.isPathSegment = isPathSegment;\nexports.PathSegment = exports.Path = exports.UnboundRelationship = exports.Relationship = exports.Node = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n/**\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar IDENTIFIER_PROPERTY_ATTRIBUTES = {\n  value: true,\n  enumerable: false,\n  configurable: false,\n  writable: false\n};\nvar NODE_IDENTIFIER_PROPERTY = '__isNode__';\nvar RELATIONSHIP_IDENTIFIER_PROPERTY = '__isRelationship__';\nvar UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY = '__isUnboundRelationship__';\nvar PATH_IDENTIFIER_PROPERTY = '__isPath__';\nvar PATH_SEGMENT_IDENTIFIER_PROPERTY = '__isPathSegment__';\n\nfunction hasIdentifierProperty(obj, property) {\n  return (obj && obj[property]) === true;\n}\n/**\n * Class for Node Type.\n */\n\n\nvar Node = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * @protected\n   * @param {Integer} identity - Unique identity\n   * @param {Array<string>} labels - Array for all labels\n   * @param {Object} properties - Map with node properties\n   */\n  function Node(identity, labels, properties) {\n    (0, _classCallCheck2[\"default\"])(this, Node);\n    /**\n     * Identity of the node.\n     * @type {Integer}\n     */\n\n    this.identity = identity;\n    /**\n     * Labels of the node.\n     * @type {string[]}\n     */\n\n    this.labels = labels;\n    /**\n     * Properties of the node.\n     * @type {Object}\n     */\n\n    this.properties = properties;\n  }\n  /**\n   * @ignore\n   */\n\n\n  (0, _createClass2[\"default\"])(Node, [{\n    key: \"toString\",\n    value: function toString() {\n      var s = '(' + this.identity;\n\n      for (var i = 0; i < this.labels.length; i++) {\n        s += ':' + this.labels[i];\n      }\n\n      var keys = Object.keys(this.properties);\n\n      if (keys.length > 0) {\n        s += ' {';\n\n        for (var _i = 0; _i < keys.length; _i++) {\n          if (_i > 0) s += ',';\n          s += keys[_i] + ':' + JSON.stringify(this.properties[keys[_i]]);\n        }\n\n        s += '}';\n      }\n\n      s += ')';\n      return s;\n    }\n  }]);\n  return Node;\n}();\n\nexports.Node = Node;\nObject.defineProperty(Node.prototype, NODE_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link Node} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link Node}, `false` otherwise.\n */\n\nfunction isNode(obj) {\n  return hasIdentifierProperty(obj, NODE_IDENTIFIER_PROPERTY);\n}\n/**\n * Class for Relationship Type.\n */\n\n\nvar Relationship = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * @protected\n   * @param {Integer} identity - Unique identity\n   * @param {Integer} start - Identity of start Node\n   * @param {Integer} end - Identity of end Node\n   * @param {string} type - Relationship type\n   * @param {Object} properties - Map with relationship properties\n   */\n  function Relationship(identity, start, end, type, properties) {\n    (0, _classCallCheck2[\"default\"])(this, Relationship);\n    /**\n     * Identity of the relationship.\n     * @type {Integer}\n     */\n\n    this.identity = identity;\n    /**\n     * Identity of the start node.\n     * @type {Integer}\n     */\n\n    this.start = start;\n    /**\n     * Identity of the end node.\n     * @type {Integer}\n     */\n\n    this.end = end;\n    /**\n     * Type of the relationship.\n     * @type {string}\n     */\n\n    this.type = type;\n    /**\n     * Properties of the relationship.\n     * @type {Object}\n     */\n\n    this.properties = properties;\n  }\n  /**\n   * @ignore\n   */\n\n\n  (0, _createClass2[\"default\"])(Relationship, [{\n    key: \"toString\",\n    value: function toString() {\n      var s = '(' + this.start + ')-[:' + this.type;\n      var keys = Object.keys(this.properties);\n\n      if (keys.length > 0) {\n        s += ' {';\n\n        for (var i = 0; i < keys.length; i++) {\n          if (i > 0) s += ',';\n          s += keys[i] + ':' + JSON.stringify(this.properties[keys[i]]);\n        }\n\n        s += '}';\n      }\n\n      s += ']->(' + this.end + ')';\n      return s;\n    }\n  }]);\n  return Relationship;\n}();\n\nexports.Relationship = Relationship;\nObject.defineProperty(Relationship.prototype, RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link Relationship} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link Relationship}, `false` otherwise.\n */\n\nfunction isRelationship(obj) {\n  return hasIdentifierProperty(obj, RELATIONSHIP_IDENTIFIER_PROPERTY);\n}\n/**\n * Class for UnboundRelationship Type.\n * @access private\n */\n\n\nvar UnboundRelationship = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * @protected\n   * @param {Integer} identity - Unique identity\n   * @param {string} type - Relationship type\n   * @param {Object} properties - Map with relationship properties\n   */\n  function UnboundRelationship(identity, type, properties) {\n    (0, _classCallCheck2[\"default\"])(this, UnboundRelationship);\n    /**\n     * Identity of the relationship.\n     * @type {Integer}\n     */\n\n    this.identity = identity;\n    /**\n     * Type of the relationship.\n     * @type {string}\n     */\n\n    this.type = type;\n    /**\n     * Properties of the relationship.\n     * @type {Object}\n     */\n\n    this.properties = properties;\n  }\n  /**\n   * Bind relationship\n   *\n   * @protected\n   * @param {Integer} start - Identity of start node\n   * @param {Integer} end - Identity of end node\n   * @return {Relationship} - Created relationship\n   */\n\n\n  (0, _createClass2[\"default\"])(UnboundRelationship, [{\n    key: \"bind\",\n    value: function bind(start, end) {\n      return new Relationship(this.identity, start, end, this.type, this.properties);\n    }\n    /**\n     * @ignore\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var s = '-[:' + this.type;\n      var keys = Object.keys(this.properties);\n\n      if (keys.length > 0) {\n        s += ' {';\n\n        for (var i = 0; i < keys.length; i++) {\n          if (i > 0) s += ',';\n          s += keys[i] + ':' + JSON.stringify(this.properties[keys[i]]);\n        }\n\n        s += '}';\n      }\n\n      s += ']->';\n      return s;\n    }\n  }]);\n  return UnboundRelationship;\n}();\n\nexports.UnboundRelationship = UnboundRelationship;\nObject.defineProperty(UnboundRelationship.prototype, UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link UnboundRelationship} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link UnboundRelationship}, `false` otherwise.\n */\n\nfunction isUnboundRelationship(obj) {\n  return hasIdentifierProperty(obj, UNBOUNT_RELATIONSHIP_IDENTIFIER_PROPERTY);\n}\n/**\n * Class for PathSegment Type.\n */\n\n\nvar PathSegment =\n/**\n * @constructor\n * @protected\n * @param {Node} start - start node\n * @param {Relationship} rel - relationship that connects start and end node\n * @param {Node} end - end node\n */\nfunction PathSegment(start, rel, end) {\n  (0, _classCallCheck2[\"default\"])(this, PathSegment);\n  /**\n   * Start node.\n   * @type {Node}\n   */\n\n  this.start = start;\n  /**\n   * Relationship.\n   * @type {Relationship}\n   */\n\n  this.relationship = rel;\n  /**\n   * End node.\n   * @type {Node}\n   */\n\n  this.end = end;\n};\n\nexports.PathSegment = PathSegment;\nObject.defineProperty(PathSegment.prototype, PATH_SEGMENT_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link PathSegment} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link PathSegment}, `false` otherwise.\n */\n\nfunction isPathSegment(obj) {\n  return hasIdentifierProperty(obj, PATH_SEGMENT_IDENTIFIER_PROPERTY);\n}\n/**\n * Class for Path Type.\n */\n\n\nvar Path =\n/**\n * @constructor\n * @protected\n * @param {Node} start  - start node\n * @param {Node} end - end node\n * @param {Array<PathSegment>} segments - Array of Segments\n */\nfunction Path(start, end, segments) {\n  (0, _classCallCheck2[\"default\"])(this, Path);\n  /**\n   * Start node.\n   * @type {Node}\n   */\n\n  this.start = start;\n  /**\n   * End node.\n   * @type {Node}\n   */\n\n  this.end = end;\n  /**\n   * Segments.\n   * @type {Array<PathSegment>}\n   */\n\n  this.segments = segments;\n  /**\n   * Length of the segments.\n   * @type {Number}\n   */\n\n  this.length = segments.length;\n};\n\nexports.Path = Path;\nObject.defineProperty(Path.prototype, PATH_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link Path} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link Path}, `false` otherwise.\n */\n\nfunction isPath(obj) {\n  return hasIdentifierProperty(obj, PATH_IDENTIFIER_PROPERTY);\n}","map":{"version":3,"sources":["d:/webback/pro5/node_modules/neo4j-driver/lib/graph-types.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","isNode","isRelationship","isUnboundRelationship","isPath","isPathSegment","PathSegment","Path","UnboundRelationship","Relationship","Node","_classCallCheck2","_createClass2","IDENTIFIER_PROPERTY_ATTRIBUTES","enumerable","configurable","writable","NODE_IDENTIFIER_PROPERTY","RELATIONSHIP_IDENTIFIER_PROPERTY","UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY","PATH_IDENTIFIER_PROPERTY","PATH_SEGMENT_IDENTIFIER_PROPERTY","hasIdentifierProperty","obj","property","identity","labels","properties","key","toString","s","i","length","keys","_i","JSON","stringify","prototype","start","end","type","bind","UNBOUNT_RELATIONSHIP_IDENTIFIER_PROPERTY","rel","relationship","segments"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isNode = isNode;\nexports.isRelationship = isRelationship;\nexports.isUnboundRelationship = isUnboundRelationship;\nexports.isPath = isPath;\nexports.isPathSegment = isPathSegment;\nexports.PathSegment = exports.Path = exports.UnboundRelationship = exports.Relationship = exports.Node = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\n/**\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar IDENTIFIER_PROPERTY_ATTRIBUTES = {\n  value: true,\n  enumerable: false,\n  configurable: false,\n  writable: false\n};\nvar NODE_IDENTIFIER_PROPERTY = '__isNode__';\nvar RELATIONSHIP_IDENTIFIER_PROPERTY = '__isRelationship__';\nvar UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY = '__isUnboundRelationship__';\nvar PATH_IDENTIFIER_PROPERTY = '__isPath__';\nvar PATH_SEGMENT_IDENTIFIER_PROPERTY = '__isPathSegment__';\n\nfunction hasIdentifierProperty(obj, property) {\n  return (obj && obj[property]) === true;\n}\n/**\n * Class for Node Type.\n */\n\n\nvar Node =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @constructor\n   * @protected\n   * @param {Integer} identity - Unique identity\n   * @param {Array<string>} labels - Array for all labels\n   * @param {Object} properties - Map with node properties\n   */\n  function Node(identity, labels, properties) {\n    (0, _classCallCheck2[\"default\"])(this, Node);\n\n    /**\n     * Identity of the node.\n     * @type {Integer}\n     */\n    this.identity = identity;\n    /**\n     * Labels of the node.\n     * @type {string[]}\n     */\n\n    this.labels = labels;\n    /**\n     * Properties of the node.\n     * @type {Object}\n     */\n\n    this.properties = properties;\n  }\n  /**\n   * @ignore\n   */\n\n\n  (0, _createClass2[\"default\"])(Node, [{\n    key: \"toString\",\n    value: function toString() {\n      var s = '(' + this.identity;\n\n      for (var i = 0; i < this.labels.length; i++) {\n        s += ':' + this.labels[i];\n      }\n\n      var keys = Object.keys(this.properties);\n\n      if (keys.length > 0) {\n        s += ' {';\n\n        for (var _i = 0; _i < keys.length; _i++) {\n          if (_i > 0) s += ',';\n          s += keys[_i] + ':' + JSON.stringify(this.properties[keys[_i]]);\n        }\n\n        s += '}';\n      }\n\n      s += ')';\n      return s;\n    }\n  }]);\n  return Node;\n}();\n\nexports.Node = Node;\nObject.defineProperty(Node.prototype, NODE_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link Node} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link Node}, `false` otherwise.\n */\n\nfunction isNode(obj) {\n  return hasIdentifierProperty(obj, NODE_IDENTIFIER_PROPERTY);\n}\n/**\n * Class for Relationship Type.\n */\n\n\nvar Relationship =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @constructor\n   * @protected\n   * @param {Integer} identity - Unique identity\n   * @param {Integer} start - Identity of start Node\n   * @param {Integer} end - Identity of end Node\n   * @param {string} type - Relationship type\n   * @param {Object} properties - Map with relationship properties\n   */\n  function Relationship(identity, start, end, type, properties) {\n    (0, _classCallCheck2[\"default\"])(this, Relationship);\n\n    /**\n     * Identity of the relationship.\n     * @type {Integer}\n     */\n    this.identity = identity;\n    /**\n     * Identity of the start node.\n     * @type {Integer}\n     */\n\n    this.start = start;\n    /**\n     * Identity of the end node.\n     * @type {Integer}\n     */\n\n    this.end = end;\n    /**\n     * Type of the relationship.\n     * @type {string}\n     */\n\n    this.type = type;\n    /**\n     * Properties of the relationship.\n     * @type {Object}\n     */\n\n    this.properties = properties;\n  }\n  /**\n   * @ignore\n   */\n\n\n  (0, _createClass2[\"default\"])(Relationship, [{\n    key: \"toString\",\n    value: function toString() {\n      var s = '(' + this.start + ')-[:' + this.type;\n      var keys = Object.keys(this.properties);\n\n      if (keys.length > 0) {\n        s += ' {';\n\n        for (var i = 0; i < keys.length; i++) {\n          if (i > 0) s += ',';\n          s += keys[i] + ':' + JSON.stringify(this.properties[keys[i]]);\n        }\n\n        s += '}';\n      }\n\n      s += ']->(' + this.end + ')';\n      return s;\n    }\n  }]);\n  return Relationship;\n}();\n\nexports.Relationship = Relationship;\nObject.defineProperty(Relationship.prototype, RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link Relationship} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link Relationship}, `false` otherwise.\n */\n\nfunction isRelationship(obj) {\n  return hasIdentifierProperty(obj, RELATIONSHIP_IDENTIFIER_PROPERTY);\n}\n/**\n * Class for UnboundRelationship Type.\n * @access private\n */\n\n\nvar UnboundRelationship =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @constructor\n   * @protected\n   * @param {Integer} identity - Unique identity\n   * @param {string} type - Relationship type\n   * @param {Object} properties - Map with relationship properties\n   */\n  function UnboundRelationship(identity, type, properties) {\n    (0, _classCallCheck2[\"default\"])(this, UnboundRelationship);\n\n    /**\n     * Identity of the relationship.\n     * @type {Integer}\n     */\n    this.identity = identity;\n    /**\n     * Type of the relationship.\n     * @type {string}\n     */\n\n    this.type = type;\n    /**\n     * Properties of the relationship.\n     * @type {Object}\n     */\n\n    this.properties = properties;\n  }\n  /**\n   * Bind relationship\n   *\n   * @protected\n   * @param {Integer} start - Identity of start node\n   * @param {Integer} end - Identity of end node\n   * @return {Relationship} - Created relationship\n   */\n\n\n  (0, _createClass2[\"default\"])(UnboundRelationship, [{\n    key: \"bind\",\n    value: function bind(start, end) {\n      return new Relationship(this.identity, start, end, this.type, this.properties);\n    }\n    /**\n     * @ignore\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var s = '-[:' + this.type;\n      var keys = Object.keys(this.properties);\n\n      if (keys.length > 0) {\n        s += ' {';\n\n        for (var i = 0; i < keys.length; i++) {\n          if (i > 0) s += ',';\n          s += keys[i] + ':' + JSON.stringify(this.properties[keys[i]]);\n        }\n\n        s += '}';\n      }\n\n      s += ']->';\n      return s;\n    }\n  }]);\n  return UnboundRelationship;\n}();\n\nexports.UnboundRelationship = UnboundRelationship;\nObject.defineProperty(UnboundRelationship.prototype, UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link UnboundRelationship} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link UnboundRelationship}, `false` otherwise.\n */\n\nfunction isUnboundRelationship(obj) {\n  return hasIdentifierProperty(obj, UNBOUNT_RELATIONSHIP_IDENTIFIER_PROPERTY);\n}\n/**\n * Class for PathSegment Type.\n */\n\n\nvar PathSegment =\n/**\n * @constructor\n * @protected\n * @param {Node} start - start node\n * @param {Relationship} rel - relationship that connects start and end node\n * @param {Node} end - end node\n */\nfunction PathSegment(start, rel, end) {\n  (0, _classCallCheck2[\"default\"])(this, PathSegment);\n\n  /**\n   * Start node.\n   * @type {Node}\n   */\n  this.start = start;\n  /**\n   * Relationship.\n   * @type {Relationship}\n   */\n\n  this.relationship = rel;\n  /**\n   * End node.\n   * @type {Node}\n   */\n\n  this.end = end;\n};\n\nexports.PathSegment = PathSegment;\nObject.defineProperty(PathSegment.prototype, PATH_SEGMENT_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link PathSegment} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link PathSegment}, `false` otherwise.\n */\n\nfunction isPathSegment(obj) {\n  return hasIdentifierProperty(obj, PATH_SEGMENT_IDENTIFIER_PROPERTY);\n}\n/**\n * Class for Path Type.\n */\n\n\nvar Path =\n/**\n * @constructor\n * @protected\n * @param {Node} start  - start node\n * @param {Node} end - end node\n * @param {Array<PathSegment>} segments - Array of Segments\n */\nfunction Path(start, end, segments) {\n  (0, _classCallCheck2[\"default\"])(this, Path);\n\n  /**\n   * Start node.\n   * @type {Node}\n   */\n  this.start = start;\n  /**\n   * End node.\n   * @type {Node}\n   */\n\n  this.end = end;\n  /**\n   * Segments.\n   * @type {Array<PathSegment>}\n   */\n\n  this.segments = segments;\n  /**\n   * Length of the segments.\n   * @type {Number}\n   */\n\n  this.length = segments.length;\n};\n\nexports.Path = Path;\nObject.defineProperty(Path.prototype, PATH_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link Path} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link Path}, `false` otherwise.\n */\n\nfunction isPath(obj) {\n  return hasIdentifierProperty(obj, PATH_IDENTIFIER_PROPERTY);\n}"]},"metadata":{},"sourceType":"script"}