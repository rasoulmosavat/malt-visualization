{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Unpacker = exports.Packer = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _get2 = _interopRequireDefault(require(\"@babel/runtime/helpers/get\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar v1 = _interopRequireWildcard(require(\"./packstream-v1\"));\n\nvar _spatialTypes = require(\"../spatial-types\");\n\nvar _temporalTypes = require(\"../temporal-types\");\n\nvar _integer = require(\"../integer\");\n\nvar _temporalUtil = require(\"./temporal-util\");\n/**\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar POINT_2D = 0x58;\nvar POINT_2D_STRUCT_SIZE = 3;\nvar POINT_3D = 0x59;\nvar POINT_3D_STRUCT_SIZE = 4;\nvar DURATION = 0x45;\nvar DURATION_STRUCT_SIZE = 4;\nvar LOCAL_TIME = 0x74;\nvar LOCAL_TIME_STRUCT_SIZE = 1;\nvar TIME = 0x54;\nvar TIME_STRUCT_SIZE = 2;\nvar DATE = 0x44;\nvar DATE_STRUCT_SIZE = 1;\nvar LOCAL_DATE_TIME = 0x64;\nvar LOCAL_DATE_TIME_STRUCT_SIZE = 2;\nvar DATE_TIME_WITH_ZONE_OFFSET = 0x46;\nvar DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE = 3;\nvar DATE_TIME_WITH_ZONE_ID = 0x66;\nvar DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE = 3;\n\nvar Packer = /*#__PURE__*/function (_v1$Packer) {\n  (0, _inherits2[\"default\"])(Packer, _v1$Packer);\n\n  function Packer() {\n    (0, _classCallCheck2[\"default\"])(this, Packer);\n    return (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(Packer).apply(this, arguments));\n  }\n\n  (0, _createClass2[\"default\"])(Packer, [{\n    key: \"disableByteArrays\",\n    value: function disableByteArrays() {\n      throw new Error('Bolt V2 should always support byte arrays');\n    }\n  }, {\n    key: \"packable\",\n    value: function packable(obj) {\n      var _this = this;\n\n      if ((0, _spatialTypes.isPoint)(obj)) {\n        return function () {\n          return packPoint(obj, _this);\n        };\n      } else if ((0, _temporalTypes.isDuration)(obj)) {\n        return function () {\n          return packDuration(obj, _this);\n        };\n      } else if ((0, _temporalTypes.isLocalTime)(obj)) {\n        return function () {\n          return packLocalTime(obj, _this);\n        };\n      } else if ((0, _temporalTypes.isTime)(obj)) {\n        return function () {\n          return packTime(obj, _this);\n        };\n      } else if ((0, _temporalTypes.isDate)(obj)) {\n        return function () {\n          return packDate(obj, _this);\n        };\n      } else if ((0, _temporalTypes.isLocalDateTime)(obj)) {\n        return function () {\n          return packLocalDateTime(obj, _this);\n        };\n      } else if ((0, _temporalTypes.isDateTime)(obj)) {\n        return function () {\n          return packDateTime(obj, _this);\n        };\n      } else {\n        return (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(Packer.prototype), \"packable\", this).call(this, obj);\n      }\n    }\n  }]);\n  return Packer;\n}(v1.Packer);\n\nexports.Packer = Packer;\n\nvar Unpacker = /*#__PURE__*/function (_v1$Unpacker) {\n  (0, _inherits2[\"default\"])(Unpacker, _v1$Unpacker);\n  /**\n   * @constructor\n   * @param {boolean} disableLosslessIntegers if this unpacker should convert all received integers to native JS numbers.\n   */\n\n  function Unpacker() {\n    var disableLosslessIntegers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    (0, _classCallCheck2[\"default\"])(this, Unpacker);\n    return (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(Unpacker).call(this, disableLosslessIntegers));\n  }\n\n  (0, _createClass2[\"default\"])(Unpacker, [{\n    key: \"_unpackUnknownStruct\",\n    value: function _unpackUnknownStruct(signature, structSize, buffer) {\n      if (signature === POINT_2D) {\n        return unpackPoint2D(this, structSize, buffer);\n      } else if (signature === POINT_3D) {\n        return unpackPoint3D(this, structSize, buffer);\n      } else if (signature === DURATION) {\n        return unpackDuration(this, structSize, buffer);\n      } else if (signature === LOCAL_TIME) {\n        return unpackLocalTime(this, structSize, buffer, this._disableLosslessIntegers);\n      } else if (signature === TIME) {\n        return unpackTime(this, structSize, buffer, this._disableLosslessIntegers);\n      } else if (signature === DATE) {\n        return unpackDate(this, structSize, buffer, this._disableLosslessIntegers);\n      } else if (signature === LOCAL_DATE_TIME) {\n        return unpackLocalDateTime(this, structSize, buffer, this._disableLosslessIntegers);\n      } else if (signature === DATE_TIME_WITH_ZONE_OFFSET) {\n        return unpackDateTimeWithZoneOffset(this, structSize, buffer, this._disableLosslessIntegers);\n      } else if (signature === DATE_TIME_WITH_ZONE_ID) {\n        return unpackDateTimeWithZoneId(this, structSize, buffer, this._disableLosslessIntegers);\n      } else {\n        return (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(Unpacker.prototype), \"_unpackUnknownStruct\", this).call(this, signature, structSize, buffer, this._disableLosslessIntegers);\n      }\n    }\n  }]);\n  return Unpacker;\n}(v1.Unpacker);\n/**\n * Pack given 2D or 3D point.\n * @param {Point} point the point value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nexports.Unpacker = Unpacker;\n\nfunction packPoint(point, packer) {\n  var is2DPoint = point.z === null || point.z === undefined;\n\n  if (is2DPoint) {\n    packPoint2D(point, packer);\n  } else {\n    packPoint3D(point, packer);\n  }\n}\n/**\n * Pack given 2D point.\n * @param {Point} point the point value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packPoint2D(point, packer) {\n  var packableStructFields = [packer.packable((0, _integer[\"int\"])(point.srid)), packer.packable(point.x), packer.packable(point.y)];\n  packer.packStruct(POINT_2D, packableStructFields);\n}\n/**\n * Pack given 3D point.\n * @param {Point} point the point value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packPoint3D(point, packer) {\n  var packableStructFields = [packer.packable((0, _integer[\"int\"])(point.srid)), packer.packable(point.x), packer.packable(point.y), packer.packable(point.z)];\n  packer.packStruct(POINT_3D, packableStructFields);\n}\n/**\n * Unpack 2D point value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @return {Point} the unpacked 2D point value.\n */\n\n\nfunction unpackPoint2D(unpacker, structSize, buffer) {\n  unpacker._verifyStructSize('Point2D', POINT_2D_STRUCT_SIZE, structSize);\n\n  return new _spatialTypes.Point(unpacker.unpack(buffer), // srid\n  unpacker.unpack(buffer), // x\n  unpacker.unpack(buffer), // y\n  undefined // z\n  );\n}\n/**\n * Unpack 3D point value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @return {Point} the unpacked 3D point value.\n */\n\n\nfunction unpackPoint3D(unpacker, structSize, buffer) {\n  unpacker._verifyStructSize('Point3D', POINT_3D_STRUCT_SIZE, structSize);\n\n  return new _spatialTypes.Point(unpacker.unpack(buffer), // srid\n  unpacker.unpack(buffer), // x\n  unpacker.unpack(buffer), // y\n  unpacker.unpack(buffer) // z\n  );\n}\n/**\n * Pack given duration.\n * @param {Duration} value the duration value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packDuration(value, packer) {\n  var months = (0, _integer[\"int\"])(value.months);\n  var days = (0, _integer[\"int\"])(value.days);\n  var seconds = (0, _integer[\"int\"])(value.seconds);\n  var nanoseconds = (0, _integer[\"int\"])(value.nanoseconds);\n  var packableStructFields = [packer.packable(months), packer.packable(days), packer.packable(seconds), packer.packable(nanoseconds)];\n  packer.packStruct(DURATION, packableStructFields);\n}\n/**\n * Unpack duration value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @return {Duration} the unpacked duration value.\n */\n\n\nfunction unpackDuration(unpacker, structSize, buffer) {\n  unpacker._verifyStructSize('Duration', DURATION_STRUCT_SIZE, structSize);\n\n  var months = unpacker.unpack(buffer);\n  var days = unpacker.unpack(buffer);\n  var seconds = unpacker.unpack(buffer);\n  var nanoseconds = unpacker.unpack(buffer);\n  return new _temporalTypes.Duration(months, days, seconds, nanoseconds);\n}\n/**\n * Pack given local time.\n * @param {LocalTime} value the local time value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packLocalTime(value, packer) {\n  var nanoOfDay = (0, _temporalUtil.localTimeToNanoOfDay)(value.hour, value.minute, value.second, value.nanosecond);\n  var packableStructFields = [packer.packable(nanoOfDay)];\n  packer.packStruct(LOCAL_TIME, packableStructFields);\n}\n/**\n * Unpack local time value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result local time should be native JS numbers.\n * @return {LocalTime} the unpacked local time value.\n */\n\n\nfunction unpackLocalTime(unpacker, structSize, buffer, disableLosslessIntegers) {\n  unpacker._verifyStructSize('LocalTime', LOCAL_TIME_STRUCT_SIZE, structSize);\n\n  var nanoOfDay = unpacker.unpackInteger(buffer);\n  var result = (0, _temporalUtil.nanoOfDayToLocalTime)(nanoOfDay);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);\n}\n/**\n * Pack given time.\n * @param {Time} value the time value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packTime(value, packer) {\n  var nanoOfDay = (0, _temporalUtil.localTimeToNanoOfDay)(value.hour, value.minute, value.second, value.nanosecond);\n  var offsetSeconds = (0, _integer[\"int\"])(value.timeZoneOffsetSeconds);\n  var packableStructFields = [packer.packable(nanoOfDay), packer.packable(offsetSeconds)];\n  packer.packStruct(TIME, packableStructFields);\n}\n/**\n * Unpack time value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result time should be native JS numbers.\n * @return {Time} the unpacked time value.\n */\n\n\nfunction unpackTime(unpacker, structSize, buffer, disableLosslessIntegers) {\n  unpacker._verifyStructSize('Time', TIME_STRUCT_SIZE, structSize);\n\n  var nanoOfDay = unpacker.unpackInteger(buffer);\n  var offsetSeconds = unpacker.unpackInteger(buffer);\n  var localTime = (0, _temporalUtil.nanoOfDayToLocalTime)(nanoOfDay);\n  var result = new _temporalTypes.Time(localTime.hour, localTime.minute, localTime.second, localTime.nanosecond, offsetSeconds);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);\n}\n/**\n * Pack given neo4j date.\n * @param {Date} value the date value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packDate(value, packer) {\n  var epochDay = (0, _temporalUtil.dateToEpochDay)(value.year, value.month, value.day);\n  var packableStructFields = [packer.packable(epochDay)];\n  packer.packStruct(DATE, packableStructFields);\n}\n/**\n * Unpack neo4j date value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result date should be native JS numbers.\n * @return {Date} the unpacked neo4j date value.\n */\n\n\nfunction unpackDate(unpacker, structSize, buffer, disableLosslessIntegers) {\n  unpacker._verifyStructSize('Date', DATE_STRUCT_SIZE, structSize);\n\n  var epochDay = unpacker.unpackInteger(buffer);\n  var result = (0, _temporalUtil.epochDayToDate)(epochDay);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);\n}\n/**\n * Pack given local date time.\n * @param {LocalDateTime} value the local date time value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packLocalDateTime(value, packer) {\n  var epochSecond = (0, _temporalUtil.localDateTimeToEpochSecond)(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n  var nano = (0, _integer[\"int\"])(value.nanosecond);\n  var packableStructFields = [packer.packable(epochSecond), packer.packable(nano)];\n  packer.packStruct(LOCAL_DATE_TIME, packableStructFields);\n}\n/**\n * Unpack local date time value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result local date-time should be native JS numbers.\n * @return {LocalDateTime} the unpacked local date time value.\n */\n\n\nfunction unpackLocalDateTime(unpacker, structSize, buffer, disableLosslessIntegers) {\n  unpacker._verifyStructSize('LocalDateTime', LOCAL_DATE_TIME_STRUCT_SIZE, structSize);\n\n  var epochSecond = unpacker.unpackInteger(buffer);\n  var nano = unpacker.unpackInteger(buffer);\n  var result = (0, _temporalUtil.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);\n}\n/**\n * Pack given date time.\n * @param {DateTime} value the date time value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packDateTime(value, packer) {\n  if (value.timeZoneId) {\n    packDateTimeWithZoneId(value, packer);\n  } else {\n    packDateTimeWithZoneOffset(value, packer);\n  }\n}\n/**\n * Pack given date time with zone offset.\n * @param {DateTime} value the date time value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packDateTimeWithZoneOffset(value, packer) {\n  var epochSecond = (0, _temporalUtil.localDateTimeToEpochSecond)(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n  var nano = (0, _integer[\"int\"])(value.nanosecond);\n  var timeZoneOffsetSeconds = (0, _integer[\"int\"])(value.timeZoneOffsetSeconds);\n  var packableStructFields = [packer.packable(epochSecond), packer.packable(nano), packer.packable(timeZoneOffsetSeconds)];\n  packer.packStruct(DATE_TIME_WITH_ZONE_OFFSET, packableStructFields);\n}\n/**\n * Unpack date time with zone offset value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.\n * @return {DateTime} the unpacked date time with zone offset value.\n */\n\n\nfunction unpackDateTimeWithZoneOffset(unpacker, structSize, buffer, disableLosslessIntegers) {\n  unpacker._verifyStructSize('DateTimeWithZoneOffset', DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE, structSize);\n\n  var epochSecond = unpacker.unpackInteger(buffer);\n  var nano = unpacker.unpackInteger(buffer);\n  var timeZoneOffsetSeconds = unpacker.unpackInteger(buffer);\n  var localDateTime = (0, _temporalUtil.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n  var result = new _temporalTypes.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, timeZoneOffsetSeconds, null);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);\n}\n/**\n * Pack given date time with zone id.\n * @param {DateTime} value the date time value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packDateTimeWithZoneId(value, packer) {\n  var epochSecond = (0, _temporalUtil.localDateTimeToEpochSecond)(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n  var nano = (0, _integer[\"int\"])(value.nanosecond);\n  var timeZoneId = value.timeZoneId;\n  var packableStructFields = [packer.packable(epochSecond), packer.packable(nano), packer.packable(timeZoneId)];\n  packer.packStruct(DATE_TIME_WITH_ZONE_ID, packableStructFields);\n}\n/**\n * Unpack date time with zone id value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.\n * @return {DateTime} the unpacked date time with zone id value.\n */\n\n\nfunction unpackDateTimeWithZoneId(unpacker, structSize, buffer, disableLosslessIntegers) {\n  unpacker._verifyStructSize('DateTimeWithZoneId', DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE, structSize);\n\n  var epochSecond = unpacker.unpackInteger(buffer);\n  var nano = unpacker.unpackInteger(buffer);\n  var timeZoneId = unpacker.unpack(buffer);\n  var localDateTime = (0, _temporalUtil.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n  var result = new _temporalTypes.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, null, timeZoneId);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);\n}\n\nfunction convertIntegerPropsIfNeeded(obj, disableLosslessIntegers) {\n  if (!disableLosslessIntegers) {\n    return obj;\n  }\n\n  var clone = Object.create(Object.getPrototypeOf(obj));\n\n  for (var prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      var value = obj[prop];\n      clone[prop] = (0, _integer.isInt)(value) ? value.toNumberOrInfinity() : value;\n    }\n  }\n\n  Object.freeze(clone);\n  return clone;\n}","map":{"version":3,"sources":["d:/webback/pro5/node_modules/neo4j-driver/lib/internal/packstream-v2.js"],"names":["_interopRequireWildcard","require","_interopRequireDefault","Object","defineProperty","exports","value","Unpacker","Packer","_classCallCheck2","_createClass2","_possibleConstructorReturn2","_getPrototypeOf2","_get2","_inherits2","v1","_spatialTypes","_temporalTypes","_integer","_temporalUtil","POINT_2D","POINT_2D_STRUCT_SIZE","POINT_3D","POINT_3D_STRUCT_SIZE","DURATION","DURATION_STRUCT_SIZE","LOCAL_TIME","LOCAL_TIME_STRUCT_SIZE","TIME","TIME_STRUCT_SIZE","DATE","DATE_STRUCT_SIZE","LOCAL_DATE_TIME","LOCAL_DATE_TIME_STRUCT_SIZE","DATE_TIME_WITH_ZONE_OFFSET","DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE","DATE_TIME_WITH_ZONE_ID","DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE","_v1$Packer","apply","arguments","key","disableByteArrays","Error","packable","obj","_this","isPoint","packPoint","isDuration","packDuration","isLocalTime","packLocalTime","isTime","packTime","isDate","packDate","isLocalDateTime","packLocalDateTime","isDateTime","packDateTime","prototype","call","_v1$Unpacker","disableLosslessIntegers","length","undefined","_unpackUnknownStruct","signature","structSize","buffer","unpackPoint2D","unpackPoint3D","unpackDuration","unpackLocalTime","_disableLosslessIntegers","unpackTime","unpackDate","unpackLocalDateTime","unpackDateTimeWithZoneOffset","unpackDateTimeWithZoneId","point","packer","is2DPoint","z","packPoint2D","packPoint3D","packableStructFields","srid","x","y","packStruct","unpacker","_verifyStructSize","Point","unpack","months","days","seconds","nanoseconds","Duration","nanoOfDay","localTimeToNanoOfDay","hour","minute","second","nanosecond","unpackInteger","result","nanoOfDayToLocalTime","convertIntegerPropsIfNeeded","offsetSeconds","timeZoneOffsetSeconds","localTime","Time","epochDay","dateToEpochDay","year","month","day","epochDayToDate","epochSecond","localDateTimeToEpochSecond","nano","epochSecondAndNanoToLocalDateTime","timeZoneId","packDateTimeWithZoneId","packDateTimeWithZoneOffset","localDateTime","DateTime","clone","create","getPrototypeOf","prop","hasOwnProperty","isInt","toNumberOrInfinity","freeze"],"mappings":"AAAA;;AAEA,IAAIA,uBAAuB,GAAGC,OAAO,CAAC,+CAAD,CAArC;;AAEA,IAAIC,sBAAsB,GAAGD,OAAO,CAAC,8CAAD,CAApC;;AAEAE,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,QAAR,GAAmBF,OAAO,CAACG,MAAR,GAAiB,KAAK,CAAzC;;AAEA,IAAIC,gBAAgB,GAAGP,sBAAsB,CAACD,OAAO,CAAC,uCAAD,CAAR,CAA7C;;AAEA,IAAIS,aAAa,GAAGR,sBAAsB,CAACD,OAAO,CAAC,oCAAD,CAAR,CAA1C;;AAEA,IAAIU,2BAA2B,GAAGT,sBAAsB,CAACD,OAAO,CAAC,kDAAD,CAAR,CAAxD;;AAEA,IAAIW,gBAAgB,GAAGV,sBAAsB,CAACD,OAAO,CAAC,uCAAD,CAAR,CAA7C;;AAEA,IAAIY,KAAK,GAAGX,sBAAsB,CAACD,OAAO,CAAC,4BAAD,CAAR,CAAlC;;AAEA,IAAIa,UAAU,GAAGZ,sBAAsB,CAACD,OAAO,CAAC,iCAAD,CAAR,CAAvC;;AAEA,IAAIc,EAAE,GAAGf,uBAAuB,CAACC,OAAO,CAAC,iBAAD,CAAR,CAAhC;;AAEA,IAAIe,aAAa,GAAGf,OAAO,CAAC,kBAAD,CAA3B;;AAEA,IAAIgB,cAAc,GAAGhB,OAAO,CAAC,mBAAD,CAA5B;;AAEA,IAAIiB,QAAQ,GAAGjB,OAAO,CAAC,YAAD,CAAtB;;AAEA,IAAIkB,aAAa,GAAGlB,OAAO,CAAC,iBAAD,CAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAImB,QAAQ,GAAG,IAAf;AACA,IAAIC,oBAAoB,GAAG,CAA3B;AACA,IAAIC,QAAQ,GAAG,IAAf;AACA,IAAIC,oBAAoB,GAAG,CAA3B;AACA,IAAIC,QAAQ,GAAG,IAAf;AACA,IAAIC,oBAAoB,GAAG,CAA3B;AACA,IAAIC,UAAU,GAAG,IAAjB;AACA,IAAIC,sBAAsB,GAAG,CAA7B;AACA,IAAIC,IAAI,GAAG,IAAX;AACA,IAAIC,gBAAgB,GAAG,CAAvB;AACA,IAAIC,IAAI,GAAG,IAAX;AACA,IAAIC,gBAAgB,GAAG,CAAvB;AACA,IAAIC,eAAe,GAAG,IAAtB;AACA,IAAIC,2BAA2B,GAAG,CAAlC;AACA,IAAIC,0BAA0B,GAAG,IAAjC;AACA,IAAIC,sCAAsC,GAAG,CAA7C;AACA,IAAIC,sBAAsB,GAAG,IAA7B;AACA,IAAIC,kCAAkC,GAAG,CAAzC;;AAEA,IAAI7B,MAAM,GACV,aACA,UAAU8B,UAAV,EAAsB;AACpB,GAAC,GAAGxB,UAAU,CAAC,SAAD,CAAd,EAA2BN,MAA3B,EAAmC8B,UAAnC;;AAEA,WAAS9B,MAAT,GAAkB;AAChB,KAAC,GAAGC,gBAAgB,CAAC,SAAD,CAApB,EAAiC,IAAjC,EAAuCD,MAAvC;AACA,WAAO,CAAC,GAAGG,2BAA2B,CAAC,SAAD,CAA/B,EAA4C,IAA5C,EAAkD,CAAC,GAAGC,gBAAgB,CAAC,SAAD,CAApB,EAAiCJ,MAAjC,EAAyC+B,KAAzC,CAA+C,IAA/C,EAAqDC,SAArD,CAAlD,CAAP;AACD;;AAED,GAAC,GAAG9B,aAAa,CAAC,SAAD,CAAjB,EAA8BF,MAA9B,EAAsC,CAAC;AACrCiC,IAAAA,GAAG,EAAE,mBADgC;AAErCnC,IAAAA,KAAK,EAAE,SAASoC,iBAAT,GAA6B;AAClC,YAAM,IAAIC,KAAJ,CAAU,2CAAV,CAAN;AACD;AAJoC,GAAD,EAKnC;AACDF,IAAAA,GAAG,EAAE,UADJ;AAEDnC,IAAAA,KAAK,EAAE,SAASsC,QAAT,CAAkBC,GAAlB,EAAuB;AAC5B,UAAIC,KAAK,GAAG,IAAZ;;AAEA,UAAI,CAAC,GAAG9B,aAAa,CAAC+B,OAAlB,EAA2BF,GAA3B,CAAJ,EAAqC;AACnC,eAAO,YAAY;AACjB,iBAAOG,SAAS,CAACH,GAAD,EAAMC,KAAN,CAAhB;AACD,SAFD;AAGD,OAJD,MAIO,IAAI,CAAC,GAAG7B,cAAc,CAACgC,UAAnB,EAA+BJ,GAA/B,CAAJ,EAAyC;AAC9C,eAAO,YAAY;AACjB,iBAAOK,YAAY,CAACL,GAAD,EAAMC,KAAN,CAAnB;AACD,SAFD;AAGD,OAJM,MAIA,IAAI,CAAC,GAAG7B,cAAc,CAACkC,WAAnB,EAAgCN,GAAhC,CAAJ,EAA0C;AAC/C,eAAO,YAAY;AACjB,iBAAOO,aAAa,CAACP,GAAD,EAAMC,KAAN,CAApB;AACD,SAFD;AAGD,OAJM,MAIA,IAAI,CAAC,GAAG7B,cAAc,CAACoC,MAAnB,EAA2BR,GAA3B,CAAJ,EAAqC;AAC1C,eAAO,YAAY;AACjB,iBAAOS,QAAQ,CAACT,GAAD,EAAMC,KAAN,CAAf;AACD,SAFD;AAGD,OAJM,MAIA,IAAI,CAAC,GAAG7B,cAAc,CAACsC,MAAnB,EAA2BV,GAA3B,CAAJ,EAAqC;AAC1C,eAAO,YAAY;AACjB,iBAAOW,QAAQ,CAACX,GAAD,EAAMC,KAAN,CAAf;AACD,SAFD;AAGD,OAJM,MAIA,IAAI,CAAC,GAAG7B,cAAc,CAACwC,eAAnB,EAAoCZ,GAApC,CAAJ,EAA8C;AACnD,eAAO,YAAY;AACjB,iBAAOa,iBAAiB,CAACb,GAAD,EAAMC,KAAN,CAAxB;AACD,SAFD;AAGD,OAJM,MAIA,IAAI,CAAC,GAAG7B,cAAc,CAAC0C,UAAnB,EAA+Bd,GAA/B,CAAJ,EAAyC;AAC9C,eAAO,YAAY;AACjB,iBAAOe,YAAY,CAACf,GAAD,EAAMC,KAAN,CAAnB;AACD,SAFD;AAGD,OAJM,MAIA;AACL,eAAO,CAAC,GAAGjC,KAAK,CAAC,SAAD,CAAT,EAAsB,CAAC,GAAGD,gBAAgB,CAAC,SAAD,CAApB,EAAiCJ,MAAM,CAACqD,SAAxC,CAAtB,EAA0E,UAA1E,EAAsF,IAAtF,EAA4FC,IAA5F,CAAiG,IAAjG,EAAuGjB,GAAvG,CAAP;AACD;AACF;AApCA,GALmC,CAAtC;AA2CA,SAAOrC,MAAP;AACD,CApDD,CAoDEO,EAAE,CAACP,MApDL,CAFA;;AAwDAH,OAAO,CAACG,MAAR,GAAiBA,MAAjB;;AAEA,IAAID,QAAQ,GACZ,aACA,UAAUwD,YAAV,EAAwB;AACtB,GAAC,GAAGjD,UAAU,CAAC,SAAD,CAAd,EAA2BP,QAA3B,EAAqCwD,YAArC;AAEA;AACF;AACA;AACA;;AACE,WAASxD,QAAT,GAAoB;AAClB,QAAIyD,uBAAuB,GAAGxB,SAAS,CAACyB,MAAV,GAAmB,CAAnB,IAAwBzB,SAAS,CAAC,CAAD,CAAT,KAAiB0B,SAAzC,GAAqD1B,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAlG;AACA,KAAC,GAAG/B,gBAAgB,CAAC,SAAD,CAApB,EAAiC,IAAjC,EAAuCF,QAAvC;AACA,WAAO,CAAC,GAAGI,2BAA2B,CAAC,SAAD,CAA/B,EAA4C,IAA5C,EAAkD,CAAC,GAAGC,gBAAgB,CAAC,SAAD,CAApB,EAAiCL,QAAjC,EAA2CuD,IAA3C,CAAgD,IAAhD,EAAsDE,uBAAtD,CAAlD,CAAP;AACD;;AAED,GAAC,GAAGtD,aAAa,CAAC,SAAD,CAAjB,EAA8BH,QAA9B,EAAwC,CAAC;AACvCkC,IAAAA,GAAG,EAAE,sBADkC;AAEvCnC,IAAAA,KAAK,EAAE,SAAS6D,oBAAT,CAA8BC,SAA9B,EAAyCC,UAAzC,EAAqDC,MAArD,EAA6D;AAClE,UAAIF,SAAS,KAAKhD,QAAlB,EAA4B;AAC1B,eAAOmD,aAAa,CAAC,IAAD,EAAOF,UAAP,EAAmBC,MAAnB,CAApB;AACD,OAFD,MAEO,IAAIF,SAAS,KAAK9C,QAAlB,EAA4B;AACjC,eAAOkD,aAAa,CAAC,IAAD,EAAOH,UAAP,EAAmBC,MAAnB,CAApB;AACD,OAFM,MAEA,IAAIF,SAAS,KAAK5C,QAAlB,EAA4B;AACjC,eAAOiD,cAAc,CAAC,IAAD,EAAOJ,UAAP,EAAmBC,MAAnB,CAArB;AACD,OAFM,MAEA,IAAIF,SAAS,KAAK1C,UAAlB,EAA8B;AACnC,eAAOgD,eAAe,CAAC,IAAD,EAAOL,UAAP,EAAmBC,MAAnB,EAA2B,KAAKK,wBAAhC,CAAtB;AACD,OAFM,MAEA,IAAIP,SAAS,KAAKxC,IAAlB,EAAwB;AAC7B,eAAOgD,UAAU,CAAC,IAAD,EAAOP,UAAP,EAAmBC,MAAnB,EAA2B,KAAKK,wBAAhC,CAAjB;AACD,OAFM,MAEA,IAAIP,SAAS,KAAKtC,IAAlB,EAAwB;AAC7B,eAAO+C,UAAU,CAAC,IAAD,EAAOR,UAAP,EAAmBC,MAAnB,EAA2B,KAAKK,wBAAhC,CAAjB;AACD,OAFM,MAEA,IAAIP,SAAS,KAAKpC,eAAlB,EAAmC;AACxC,eAAO8C,mBAAmB,CAAC,IAAD,EAAOT,UAAP,EAAmBC,MAAnB,EAA2B,KAAKK,wBAAhC,CAA1B;AACD,OAFM,MAEA,IAAIP,SAAS,KAAKlC,0BAAlB,EAA8C;AACnD,eAAO6C,4BAA4B,CAAC,IAAD,EAAOV,UAAP,EAAmBC,MAAnB,EAA2B,KAAKK,wBAAhC,CAAnC;AACD,OAFM,MAEA,IAAIP,SAAS,KAAKhC,sBAAlB,EAA0C;AAC/C,eAAO4C,wBAAwB,CAAC,IAAD,EAAOX,UAAP,EAAmBC,MAAnB,EAA2B,KAAKK,wBAAhC,CAA/B;AACD,OAFM,MAEA;AACL,eAAO,CAAC,GAAG9D,KAAK,CAAC,SAAD,CAAT,EAAsB,CAAC,GAAGD,gBAAgB,CAAC,SAAD,CAApB,EAAiCL,QAAQ,CAACsD,SAA1C,CAAtB,EAA4E,sBAA5E,EAAoG,IAApG,EAA0GC,IAA1G,CAA+G,IAA/G,EAAqHM,SAArH,EAAgIC,UAAhI,EAA4IC,MAA5I,EAAoJ,KAAKK,wBAAzJ,CAAP;AACD;AACF;AAxBsC,GAAD,CAAxC;AA0BA,SAAOpE,QAAP;AACD,CAxCD,CAwCEQ,EAAE,CAACR,QAxCL,CAFA;AA2CA;AACA;AACA;AACA;AACA;;;AAGAF,OAAO,CAACE,QAAR,GAAmBA,QAAnB;;AAEA,SAASyC,SAAT,CAAmBiC,KAAnB,EAA0BC,MAA1B,EAAkC;AAChC,MAAIC,SAAS,GAAGF,KAAK,CAACG,CAAN,KAAY,IAAZ,IAAoBH,KAAK,CAACG,CAAN,KAAYlB,SAAhD;;AAEA,MAAIiB,SAAJ,EAAe;AACbE,IAAAA,WAAW,CAACJ,KAAD,EAAQC,MAAR,CAAX;AACD,GAFD,MAEO;AACLI,IAAAA,WAAW,CAACL,KAAD,EAAQC,MAAR,CAAX;AACD;AACF;AACD;AACA;AACA;AACA;AACA;;;AAGA,SAASG,WAAT,CAAqBJ,KAArB,EAA4BC,MAA5B,EAAoC;AAClC,MAAIK,oBAAoB,GAAG,CAACL,MAAM,CAACtC,QAAP,CAAgB,CAAC,GAAG1B,QAAQ,CAAC,KAAD,CAAZ,EAAqB+D,KAAK,CAACO,IAA3B,CAAhB,CAAD,EAAoDN,MAAM,CAACtC,QAAP,CAAgBqC,KAAK,CAACQ,CAAtB,CAApD,EAA8EP,MAAM,CAACtC,QAAP,CAAgBqC,KAAK,CAACS,CAAtB,CAA9E,CAA3B;AACAR,EAAAA,MAAM,CAACS,UAAP,CAAkBvE,QAAlB,EAA4BmE,oBAA5B;AACD;AACD;AACA;AACA;AACA;AACA;;;AAGA,SAASD,WAAT,CAAqBL,KAArB,EAA4BC,MAA5B,EAAoC;AAClC,MAAIK,oBAAoB,GAAG,CAACL,MAAM,CAACtC,QAAP,CAAgB,CAAC,GAAG1B,QAAQ,CAAC,KAAD,CAAZ,EAAqB+D,KAAK,CAACO,IAA3B,CAAhB,CAAD,EAAoDN,MAAM,CAACtC,QAAP,CAAgBqC,KAAK,CAACQ,CAAtB,CAApD,EAA8EP,MAAM,CAACtC,QAAP,CAAgBqC,KAAK,CAACS,CAAtB,CAA9E,EAAwGR,MAAM,CAACtC,QAAP,CAAgBqC,KAAK,CAACG,CAAtB,CAAxG,CAA3B;AACAF,EAAAA,MAAM,CAACS,UAAP,CAAkBrE,QAAlB,EAA4BiE,oBAA5B;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAAShB,aAAT,CAAuBqB,QAAvB,EAAiCvB,UAAjC,EAA6CC,MAA7C,EAAqD;AACnDsB,EAAAA,QAAQ,CAACC,iBAAT,CAA2B,SAA3B,EAAsCxE,oBAAtC,EAA4DgD,UAA5D;;AAEA,SAAO,IAAIrD,aAAa,CAAC8E,KAAlB,CAAwBF,QAAQ,CAACG,MAAT,CAAgBzB,MAAhB,CAAxB,EAAiD;AACxDsB,EAAAA,QAAQ,CAACG,MAAT,CAAgBzB,MAAhB,CADO,EACkB;AACzBsB,EAAAA,QAAQ,CAACG,MAAT,CAAgBzB,MAAhB,CAFO,EAEkB;AACzBJ,EAAAA,SAHO,CAGG;AAHH,GAAP;AAKD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASM,aAAT,CAAuBoB,QAAvB,EAAiCvB,UAAjC,EAA6CC,MAA7C,EAAqD;AACnDsB,EAAAA,QAAQ,CAACC,iBAAT,CAA2B,SAA3B,EAAsCtE,oBAAtC,EAA4D8C,UAA5D;;AAEA,SAAO,IAAIrD,aAAa,CAAC8E,KAAlB,CAAwBF,QAAQ,CAACG,MAAT,CAAgBzB,MAAhB,CAAxB,EAAiD;AACxDsB,EAAAA,QAAQ,CAACG,MAAT,CAAgBzB,MAAhB,CADO,EACkB;AACzBsB,EAAAA,QAAQ,CAACG,MAAT,CAAgBzB,MAAhB,CAFO,EAEkB;AACzBsB,EAAAA,QAAQ,CAACG,MAAT,CAAgBzB,MAAhB,CAHO,CAGiB;AAHjB,GAAP;AAKD;AACD;AACA;AACA;AACA;AACA;;;AAGA,SAASpB,YAAT,CAAsB5C,KAAtB,EAA6B4E,MAA7B,EAAqC;AACnC,MAAIc,MAAM,GAAG,CAAC,GAAG9E,QAAQ,CAAC,KAAD,CAAZ,EAAqBZ,KAAK,CAAC0F,MAA3B,CAAb;AACA,MAAIC,IAAI,GAAG,CAAC,GAAG/E,QAAQ,CAAC,KAAD,CAAZ,EAAqBZ,KAAK,CAAC2F,IAA3B,CAAX;AACA,MAAIC,OAAO,GAAG,CAAC,GAAGhF,QAAQ,CAAC,KAAD,CAAZ,EAAqBZ,KAAK,CAAC4F,OAA3B,CAAd;AACA,MAAIC,WAAW,GAAG,CAAC,GAAGjF,QAAQ,CAAC,KAAD,CAAZ,EAAqBZ,KAAK,CAAC6F,WAA3B,CAAlB;AACA,MAAIZ,oBAAoB,GAAG,CAACL,MAAM,CAACtC,QAAP,CAAgBoD,MAAhB,CAAD,EAA0Bd,MAAM,CAACtC,QAAP,CAAgBqD,IAAhB,CAA1B,EAAiDf,MAAM,CAACtC,QAAP,CAAgBsD,OAAhB,CAAjD,EAA2EhB,MAAM,CAACtC,QAAP,CAAgBuD,WAAhB,CAA3E,CAA3B;AACAjB,EAAAA,MAAM,CAACS,UAAP,CAAkBnE,QAAlB,EAA4B+D,oBAA5B;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASd,cAAT,CAAwBmB,QAAxB,EAAkCvB,UAAlC,EAA8CC,MAA9C,EAAsD;AACpDsB,EAAAA,QAAQ,CAACC,iBAAT,CAA2B,UAA3B,EAAuCpE,oBAAvC,EAA6D4C,UAA7D;;AAEA,MAAI2B,MAAM,GAAGJ,QAAQ,CAACG,MAAT,CAAgBzB,MAAhB,CAAb;AACA,MAAI2B,IAAI,GAAGL,QAAQ,CAACG,MAAT,CAAgBzB,MAAhB,CAAX;AACA,MAAI4B,OAAO,GAAGN,QAAQ,CAACG,MAAT,CAAgBzB,MAAhB,CAAd;AACA,MAAI6B,WAAW,GAAGP,QAAQ,CAACG,MAAT,CAAgBzB,MAAhB,CAAlB;AACA,SAAO,IAAIrD,cAAc,CAACmF,QAAnB,CAA4BJ,MAA5B,EAAoCC,IAApC,EAA0CC,OAA1C,EAAmDC,WAAnD,CAAP;AACD;AACD;AACA;AACA;AACA;AACA;;;AAGA,SAAS/C,aAAT,CAAuB9C,KAAvB,EAA8B4E,MAA9B,EAAsC;AACpC,MAAImB,SAAS,GAAG,CAAC,GAAGlF,aAAa,CAACmF,oBAAlB,EAAwChG,KAAK,CAACiG,IAA9C,EAAoDjG,KAAK,CAACkG,MAA1D,EAAkElG,KAAK,CAACmG,MAAxE,EAAgFnG,KAAK,CAACoG,UAAtF,CAAhB;AACA,MAAInB,oBAAoB,GAAG,CAACL,MAAM,CAACtC,QAAP,CAAgByD,SAAhB,CAAD,CAA3B;AACAnB,EAAAA,MAAM,CAACS,UAAP,CAAkBjE,UAAlB,EAA8B6D,oBAA9B;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASb,eAAT,CAAyBkB,QAAzB,EAAmCvB,UAAnC,EAA+CC,MAA/C,EAAuDN,uBAAvD,EAAgF;AAC9E4B,EAAAA,QAAQ,CAACC,iBAAT,CAA2B,WAA3B,EAAwClE,sBAAxC,EAAgE0C,UAAhE;;AAEA,MAAIgC,SAAS,GAAGT,QAAQ,CAACe,aAAT,CAAuBrC,MAAvB,CAAhB;AACA,MAAIsC,MAAM,GAAG,CAAC,GAAGzF,aAAa,CAAC0F,oBAAlB,EAAwCR,SAAxC,CAAb;AACA,SAAOS,2BAA2B,CAACF,MAAD,EAAS5C,uBAAT,CAAlC;AACD;AACD;AACA;AACA;AACA;AACA;;;AAGA,SAASV,QAAT,CAAkBhD,KAAlB,EAAyB4E,MAAzB,EAAiC;AAC/B,MAAImB,SAAS,GAAG,CAAC,GAAGlF,aAAa,CAACmF,oBAAlB,EAAwChG,KAAK,CAACiG,IAA9C,EAAoDjG,KAAK,CAACkG,MAA1D,EAAkElG,KAAK,CAACmG,MAAxE,EAAgFnG,KAAK,CAACoG,UAAtF,CAAhB;AACA,MAAIK,aAAa,GAAG,CAAC,GAAG7F,QAAQ,CAAC,KAAD,CAAZ,EAAqBZ,KAAK,CAAC0G,qBAA3B,CAApB;AACA,MAAIzB,oBAAoB,GAAG,CAACL,MAAM,CAACtC,QAAP,CAAgByD,SAAhB,CAAD,EAA6BnB,MAAM,CAACtC,QAAP,CAAgBmE,aAAhB,CAA7B,CAA3B;AACA7B,EAAAA,MAAM,CAACS,UAAP,CAAkB/D,IAAlB,EAAwB2D,oBAAxB;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASX,UAAT,CAAoBgB,QAApB,EAA8BvB,UAA9B,EAA0CC,MAA1C,EAAkDN,uBAAlD,EAA2E;AACzE4B,EAAAA,QAAQ,CAACC,iBAAT,CAA2B,MAA3B,EAAmChE,gBAAnC,EAAqDwC,UAArD;;AAEA,MAAIgC,SAAS,GAAGT,QAAQ,CAACe,aAAT,CAAuBrC,MAAvB,CAAhB;AACA,MAAIyC,aAAa,GAAGnB,QAAQ,CAACe,aAAT,CAAuBrC,MAAvB,CAApB;AACA,MAAI2C,SAAS,GAAG,CAAC,GAAG9F,aAAa,CAAC0F,oBAAlB,EAAwCR,SAAxC,CAAhB;AACA,MAAIO,MAAM,GAAG,IAAI3F,cAAc,CAACiG,IAAnB,CAAwBD,SAAS,CAACV,IAAlC,EAAwCU,SAAS,CAACT,MAAlD,EAA0DS,SAAS,CAACR,MAApE,EAA4EQ,SAAS,CAACP,UAAtF,EAAkGK,aAAlG,CAAb;AACA,SAAOD,2BAA2B,CAACF,MAAD,EAAS5C,uBAAT,CAAlC;AACD;AACD;AACA;AACA;AACA;AACA;;;AAGA,SAASR,QAAT,CAAkBlD,KAAlB,EAAyB4E,MAAzB,EAAiC;AAC/B,MAAIiC,QAAQ,GAAG,CAAC,GAAGhG,aAAa,CAACiG,cAAlB,EAAkC9G,KAAK,CAAC+G,IAAxC,EAA8C/G,KAAK,CAACgH,KAApD,EAA2DhH,KAAK,CAACiH,GAAjE,CAAf;AACA,MAAIhC,oBAAoB,GAAG,CAACL,MAAM,CAACtC,QAAP,CAAgBuE,QAAhB,CAAD,CAA3B;AACAjC,EAAAA,MAAM,CAACS,UAAP,CAAkB7D,IAAlB,EAAwByD,oBAAxB;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASV,UAAT,CAAoBe,QAApB,EAA8BvB,UAA9B,EAA0CC,MAA1C,EAAkDN,uBAAlD,EAA2E;AACzE4B,EAAAA,QAAQ,CAACC,iBAAT,CAA2B,MAA3B,EAAmC9D,gBAAnC,EAAqDsC,UAArD;;AAEA,MAAI8C,QAAQ,GAAGvB,QAAQ,CAACe,aAAT,CAAuBrC,MAAvB,CAAf;AACA,MAAIsC,MAAM,GAAG,CAAC,GAAGzF,aAAa,CAACqG,cAAlB,EAAkCL,QAAlC,CAAb;AACA,SAAOL,2BAA2B,CAACF,MAAD,EAAS5C,uBAAT,CAAlC;AACD;AACD;AACA;AACA;AACA;AACA;;;AAGA,SAASN,iBAAT,CAA2BpD,KAA3B,EAAkC4E,MAAlC,EAA0C;AACxC,MAAIuC,WAAW,GAAG,CAAC,GAAGtG,aAAa,CAACuG,0BAAlB,EAA8CpH,KAAK,CAAC+G,IAApD,EAA0D/G,KAAK,CAACgH,KAAhE,EAAuEhH,KAAK,CAACiH,GAA7E,EAAkFjH,KAAK,CAACiG,IAAxF,EAA8FjG,KAAK,CAACkG,MAApG,EAA4GlG,KAAK,CAACmG,MAAlH,EAA0HnG,KAAK,CAACoG,UAAhI,CAAlB;AACA,MAAIiB,IAAI,GAAG,CAAC,GAAGzG,QAAQ,CAAC,KAAD,CAAZ,EAAqBZ,KAAK,CAACoG,UAA3B,CAAX;AACA,MAAInB,oBAAoB,GAAG,CAACL,MAAM,CAACtC,QAAP,CAAgB6E,WAAhB,CAAD,EAA+BvC,MAAM,CAACtC,QAAP,CAAgB+E,IAAhB,CAA/B,CAA3B;AACAzC,EAAAA,MAAM,CAACS,UAAP,CAAkB3D,eAAlB,EAAmCuD,oBAAnC;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAAST,mBAAT,CAA6Bc,QAA7B,EAAuCvB,UAAvC,EAAmDC,MAAnD,EAA2DN,uBAA3D,EAAoF;AAClF4B,EAAAA,QAAQ,CAACC,iBAAT,CAA2B,eAA3B,EAA4C5D,2BAA5C,EAAyEoC,UAAzE;;AAEA,MAAIoD,WAAW,GAAG7B,QAAQ,CAACe,aAAT,CAAuBrC,MAAvB,CAAlB;AACA,MAAIqD,IAAI,GAAG/B,QAAQ,CAACe,aAAT,CAAuBrC,MAAvB,CAAX;AACA,MAAIsC,MAAM,GAAG,CAAC,GAAGzF,aAAa,CAACyG,iCAAlB,EAAqDH,WAArD,EAAkEE,IAAlE,CAAb;AACA,SAAOb,2BAA2B,CAACF,MAAD,EAAS5C,uBAAT,CAAlC;AACD;AACD;AACA;AACA;AACA;AACA;;;AAGA,SAASJ,YAAT,CAAsBtD,KAAtB,EAA6B4E,MAA7B,EAAqC;AACnC,MAAI5E,KAAK,CAACuH,UAAV,EAAsB;AACpBC,IAAAA,sBAAsB,CAACxH,KAAD,EAAQ4E,MAAR,CAAtB;AACD,GAFD,MAEO;AACL6C,IAAAA,0BAA0B,CAACzH,KAAD,EAAQ4E,MAAR,CAA1B;AACD;AACF;AACD;AACA;AACA;AACA;AACA;;;AAGA,SAAS6C,0BAAT,CAAoCzH,KAApC,EAA2C4E,MAA3C,EAAmD;AACjD,MAAIuC,WAAW,GAAG,CAAC,GAAGtG,aAAa,CAACuG,0BAAlB,EAA8CpH,KAAK,CAAC+G,IAApD,EAA0D/G,KAAK,CAACgH,KAAhE,EAAuEhH,KAAK,CAACiH,GAA7E,EAAkFjH,KAAK,CAACiG,IAAxF,EAA8FjG,KAAK,CAACkG,MAApG,EAA4GlG,KAAK,CAACmG,MAAlH,EAA0HnG,KAAK,CAACoG,UAAhI,CAAlB;AACA,MAAIiB,IAAI,GAAG,CAAC,GAAGzG,QAAQ,CAAC,KAAD,CAAZ,EAAqBZ,KAAK,CAACoG,UAA3B,CAAX;AACA,MAAIM,qBAAqB,GAAG,CAAC,GAAG9F,QAAQ,CAAC,KAAD,CAAZ,EAAqBZ,KAAK,CAAC0G,qBAA3B,CAA5B;AACA,MAAIzB,oBAAoB,GAAG,CAACL,MAAM,CAACtC,QAAP,CAAgB6E,WAAhB,CAAD,EAA+BvC,MAAM,CAACtC,QAAP,CAAgB+E,IAAhB,CAA/B,EAAsDzC,MAAM,CAACtC,QAAP,CAAgBoE,qBAAhB,CAAtD,CAA3B;AACA9B,EAAAA,MAAM,CAACS,UAAP,CAAkBzD,0BAAlB,EAA8CqD,oBAA9C;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASR,4BAAT,CAAsCa,QAAtC,EAAgDvB,UAAhD,EAA4DC,MAA5D,EAAoEN,uBAApE,EAA6F;AAC3F4B,EAAAA,QAAQ,CAACC,iBAAT,CAA2B,wBAA3B,EAAqD1D,sCAArD,EAA6FkC,UAA7F;;AAEA,MAAIoD,WAAW,GAAG7B,QAAQ,CAACe,aAAT,CAAuBrC,MAAvB,CAAlB;AACA,MAAIqD,IAAI,GAAG/B,QAAQ,CAACe,aAAT,CAAuBrC,MAAvB,CAAX;AACA,MAAI0C,qBAAqB,GAAGpB,QAAQ,CAACe,aAAT,CAAuBrC,MAAvB,CAA5B;AACA,MAAI0D,aAAa,GAAG,CAAC,GAAG7G,aAAa,CAACyG,iCAAlB,EAAqDH,WAArD,EAAkEE,IAAlE,CAApB;AACA,MAAIf,MAAM,GAAG,IAAI3F,cAAc,CAACgH,QAAnB,CAA4BD,aAAa,CAACX,IAA1C,EAAgDW,aAAa,CAACV,KAA9D,EAAqEU,aAAa,CAACT,GAAnF,EAAwFS,aAAa,CAACzB,IAAtG,EAA4GyB,aAAa,CAACxB,MAA1H,EAAkIwB,aAAa,CAACvB,MAAhJ,EAAwJuB,aAAa,CAACtB,UAAtK,EAAkLM,qBAAlL,EAAyM,IAAzM,CAAb;AACA,SAAOF,2BAA2B,CAACF,MAAD,EAAS5C,uBAAT,CAAlC;AACD;AACD;AACA;AACA;AACA;AACA;;;AAGA,SAAS8D,sBAAT,CAAgCxH,KAAhC,EAAuC4E,MAAvC,EAA+C;AAC7C,MAAIuC,WAAW,GAAG,CAAC,GAAGtG,aAAa,CAACuG,0BAAlB,EAA8CpH,KAAK,CAAC+G,IAApD,EAA0D/G,KAAK,CAACgH,KAAhE,EAAuEhH,KAAK,CAACiH,GAA7E,EAAkFjH,KAAK,CAACiG,IAAxF,EAA8FjG,KAAK,CAACkG,MAApG,EAA4GlG,KAAK,CAACmG,MAAlH,EAA0HnG,KAAK,CAACoG,UAAhI,CAAlB;AACA,MAAIiB,IAAI,GAAG,CAAC,GAAGzG,QAAQ,CAAC,KAAD,CAAZ,EAAqBZ,KAAK,CAACoG,UAA3B,CAAX;AACA,MAAImB,UAAU,GAAGvH,KAAK,CAACuH,UAAvB;AACA,MAAItC,oBAAoB,GAAG,CAACL,MAAM,CAACtC,QAAP,CAAgB6E,WAAhB,CAAD,EAA+BvC,MAAM,CAACtC,QAAP,CAAgB+E,IAAhB,CAA/B,EAAsDzC,MAAM,CAACtC,QAAP,CAAgBiF,UAAhB,CAAtD,CAA3B;AACA3C,EAAAA,MAAM,CAACS,UAAP,CAAkBvD,sBAAlB,EAA0CmD,oBAA1C;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASP,wBAAT,CAAkCY,QAAlC,EAA4CvB,UAA5C,EAAwDC,MAAxD,EAAgEN,uBAAhE,EAAyF;AACvF4B,EAAAA,QAAQ,CAACC,iBAAT,CAA2B,oBAA3B,EAAiDxD,kCAAjD,EAAqFgC,UAArF;;AAEA,MAAIoD,WAAW,GAAG7B,QAAQ,CAACe,aAAT,CAAuBrC,MAAvB,CAAlB;AACA,MAAIqD,IAAI,GAAG/B,QAAQ,CAACe,aAAT,CAAuBrC,MAAvB,CAAX;AACA,MAAIuD,UAAU,GAAGjC,QAAQ,CAACG,MAAT,CAAgBzB,MAAhB,CAAjB;AACA,MAAI0D,aAAa,GAAG,CAAC,GAAG7G,aAAa,CAACyG,iCAAlB,EAAqDH,WAArD,EAAkEE,IAAlE,CAApB;AACA,MAAIf,MAAM,GAAG,IAAI3F,cAAc,CAACgH,QAAnB,CAA4BD,aAAa,CAACX,IAA1C,EAAgDW,aAAa,CAACV,KAA9D,EAAqEU,aAAa,CAACT,GAAnF,EAAwFS,aAAa,CAACzB,IAAtG,EAA4GyB,aAAa,CAACxB,MAA1H,EAAkIwB,aAAa,CAACvB,MAAhJ,EAAwJuB,aAAa,CAACtB,UAAtK,EAAkL,IAAlL,EAAwLmB,UAAxL,CAAb;AACA,SAAOf,2BAA2B,CAACF,MAAD,EAAS5C,uBAAT,CAAlC;AACD;;AAED,SAAS8C,2BAAT,CAAqCjE,GAArC,EAA0CmB,uBAA1C,EAAmE;AACjE,MAAI,CAACA,uBAAL,EAA8B;AAC5B,WAAOnB,GAAP;AACD;;AAED,MAAIqF,KAAK,GAAG/H,MAAM,CAACgI,MAAP,CAAchI,MAAM,CAACiI,cAAP,CAAsBvF,GAAtB,CAAd,CAAZ;;AAEA,OAAK,IAAIwF,IAAT,IAAiBxF,GAAjB,EAAsB;AACpB,QAAIA,GAAG,CAACyF,cAAJ,CAAmBD,IAAnB,CAAJ,EAA8B;AAC5B,UAAI/H,KAAK,GAAGuC,GAAG,CAACwF,IAAD,CAAf;AACAH,MAAAA,KAAK,CAACG,IAAD,CAAL,GAAc,CAAC,GAAGnH,QAAQ,CAACqH,KAAb,EAAoBjI,KAApB,IAA6BA,KAAK,CAACkI,kBAAN,EAA7B,GAA0DlI,KAAxE;AACD;AACF;;AAEDH,EAAAA,MAAM,CAACsI,MAAP,CAAcP,KAAd;AACA,SAAOA,KAAP;AACD","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Unpacker = exports.Packer = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _get2 = _interopRequireDefault(require(\"@babel/runtime/helpers/get\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar v1 = _interopRequireWildcard(require(\"./packstream-v1\"));\n\nvar _spatialTypes = require(\"../spatial-types\");\n\nvar _temporalTypes = require(\"../temporal-types\");\n\nvar _integer = require(\"../integer\");\n\nvar _temporalUtil = require(\"./temporal-util\");\n\n/**\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar POINT_2D = 0x58;\nvar POINT_2D_STRUCT_SIZE = 3;\nvar POINT_3D = 0x59;\nvar POINT_3D_STRUCT_SIZE = 4;\nvar DURATION = 0x45;\nvar DURATION_STRUCT_SIZE = 4;\nvar LOCAL_TIME = 0x74;\nvar LOCAL_TIME_STRUCT_SIZE = 1;\nvar TIME = 0x54;\nvar TIME_STRUCT_SIZE = 2;\nvar DATE = 0x44;\nvar DATE_STRUCT_SIZE = 1;\nvar LOCAL_DATE_TIME = 0x64;\nvar LOCAL_DATE_TIME_STRUCT_SIZE = 2;\nvar DATE_TIME_WITH_ZONE_OFFSET = 0x46;\nvar DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE = 3;\nvar DATE_TIME_WITH_ZONE_ID = 0x66;\nvar DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE = 3;\n\nvar Packer =\n/*#__PURE__*/\nfunction (_v1$Packer) {\n  (0, _inherits2[\"default\"])(Packer, _v1$Packer);\n\n  function Packer() {\n    (0, _classCallCheck2[\"default\"])(this, Packer);\n    return (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(Packer).apply(this, arguments));\n  }\n\n  (0, _createClass2[\"default\"])(Packer, [{\n    key: \"disableByteArrays\",\n    value: function disableByteArrays() {\n      throw new Error('Bolt V2 should always support byte arrays');\n    }\n  }, {\n    key: \"packable\",\n    value: function packable(obj) {\n      var _this = this;\n\n      if ((0, _spatialTypes.isPoint)(obj)) {\n        return function () {\n          return packPoint(obj, _this);\n        };\n      } else if ((0, _temporalTypes.isDuration)(obj)) {\n        return function () {\n          return packDuration(obj, _this);\n        };\n      } else if ((0, _temporalTypes.isLocalTime)(obj)) {\n        return function () {\n          return packLocalTime(obj, _this);\n        };\n      } else if ((0, _temporalTypes.isTime)(obj)) {\n        return function () {\n          return packTime(obj, _this);\n        };\n      } else if ((0, _temporalTypes.isDate)(obj)) {\n        return function () {\n          return packDate(obj, _this);\n        };\n      } else if ((0, _temporalTypes.isLocalDateTime)(obj)) {\n        return function () {\n          return packLocalDateTime(obj, _this);\n        };\n      } else if ((0, _temporalTypes.isDateTime)(obj)) {\n        return function () {\n          return packDateTime(obj, _this);\n        };\n      } else {\n        return (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(Packer.prototype), \"packable\", this).call(this, obj);\n      }\n    }\n  }]);\n  return Packer;\n}(v1.Packer);\n\nexports.Packer = Packer;\n\nvar Unpacker =\n/*#__PURE__*/\nfunction (_v1$Unpacker) {\n  (0, _inherits2[\"default\"])(Unpacker, _v1$Unpacker);\n\n  /**\n   * @constructor\n   * @param {boolean} disableLosslessIntegers if this unpacker should convert all received integers to native JS numbers.\n   */\n  function Unpacker() {\n    var disableLosslessIntegers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    (0, _classCallCheck2[\"default\"])(this, Unpacker);\n    return (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(Unpacker).call(this, disableLosslessIntegers));\n  }\n\n  (0, _createClass2[\"default\"])(Unpacker, [{\n    key: \"_unpackUnknownStruct\",\n    value: function _unpackUnknownStruct(signature, structSize, buffer) {\n      if (signature === POINT_2D) {\n        return unpackPoint2D(this, structSize, buffer);\n      } else if (signature === POINT_3D) {\n        return unpackPoint3D(this, structSize, buffer);\n      } else if (signature === DURATION) {\n        return unpackDuration(this, structSize, buffer);\n      } else if (signature === LOCAL_TIME) {\n        return unpackLocalTime(this, structSize, buffer, this._disableLosslessIntegers);\n      } else if (signature === TIME) {\n        return unpackTime(this, structSize, buffer, this._disableLosslessIntegers);\n      } else if (signature === DATE) {\n        return unpackDate(this, structSize, buffer, this._disableLosslessIntegers);\n      } else if (signature === LOCAL_DATE_TIME) {\n        return unpackLocalDateTime(this, structSize, buffer, this._disableLosslessIntegers);\n      } else if (signature === DATE_TIME_WITH_ZONE_OFFSET) {\n        return unpackDateTimeWithZoneOffset(this, structSize, buffer, this._disableLosslessIntegers);\n      } else if (signature === DATE_TIME_WITH_ZONE_ID) {\n        return unpackDateTimeWithZoneId(this, structSize, buffer, this._disableLosslessIntegers);\n      } else {\n        return (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(Unpacker.prototype), \"_unpackUnknownStruct\", this).call(this, signature, structSize, buffer, this._disableLosslessIntegers);\n      }\n    }\n  }]);\n  return Unpacker;\n}(v1.Unpacker);\n/**\n * Pack given 2D or 3D point.\n * @param {Point} point the point value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nexports.Unpacker = Unpacker;\n\nfunction packPoint(point, packer) {\n  var is2DPoint = point.z === null || point.z === undefined;\n\n  if (is2DPoint) {\n    packPoint2D(point, packer);\n  } else {\n    packPoint3D(point, packer);\n  }\n}\n/**\n * Pack given 2D point.\n * @param {Point} point the point value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packPoint2D(point, packer) {\n  var packableStructFields = [packer.packable((0, _integer[\"int\"])(point.srid)), packer.packable(point.x), packer.packable(point.y)];\n  packer.packStruct(POINT_2D, packableStructFields);\n}\n/**\n * Pack given 3D point.\n * @param {Point} point the point value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packPoint3D(point, packer) {\n  var packableStructFields = [packer.packable((0, _integer[\"int\"])(point.srid)), packer.packable(point.x), packer.packable(point.y), packer.packable(point.z)];\n  packer.packStruct(POINT_3D, packableStructFields);\n}\n/**\n * Unpack 2D point value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @return {Point} the unpacked 2D point value.\n */\n\n\nfunction unpackPoint2D(unpacker, structSize, buffer) {\n  unpacker._verifyStructSize('Point2D', POINT_2D_STRUCT_SIZE, structSize);\n\n  return new _spatialTypes.Point(unpacker.unpack(buffer), // srid\n  unpacker.unpack(buffer), // x\n  unpacker.unpack(buffer), // y\n  undefined // z\n  );\n}\n/**\n * Unpack 3D point value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @return {Point} the unpacked 3D point value.\n */\n\n\nfunction unpackPoint3D(unpacker, structSize, buffer) {\n  unpacker._verifyStructSize('Point3D', POINT_3D_STRUCT_SIZE, structSize);\n\n  return new _spatialTypes.Point(unpacker.unpack(buffer), // srid\n  unpacker.unpack(buffer), // x\n  unpacker.unpack(buffer), // y\n  unpacker.unpack(buffer) // z\n  );\n}\n/**\n * Pack given duration.\n * @param {Duration} value the duration value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packDuration(value, packer) {\n  var months = (0, _integer[\"int\"])(value.months);\n  var days = (0, _integer[\"int\"])(value.days);\n  var seconds = (0, _integer[\"int\"])(value.seconds);\n  var nanoseconds = (0, _integer[\"int\"])(value.nanoseconds);\n  var packableStructFields = [packer.packable(months), packer.packable(days), packer.packable(seconds), packer.packable(nanoseconds)];\n  packer.packStruct(DURATION, packableStructFields);\n}\n/**\n * Unpack duration value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @return {Duration} the unpacked duration value.\n */\n\n\nfunction unpackDuration(unpacker, structSize, buffer) {\n  unpacker._verifyStructSize('Duration', DURATION_STRUCT_SIZE, structSize);\n\n  var months = unpacker.unpack(buffer);\n  var days = unpacker.unpack(buffer);\n  var seconds = unpacker.unpack(buffer);\n  var nanoseconds = unpacker.unpack(buffer);\n  return new _temporalTypes.Duration(months, days, seconds, nanoseconds);\n}\n/**\n * Pack given local time.\n * @param {LocalTime} value the local time value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packLocalTime(value, packer) {\n  var nanoOfDay = (0, _temporalUtil.localTimeToNanoOfDay)(value.hour, value.minute, value.second, value.nanosecond);\n  var packableStructFields = [packer.packable(nanoOfDay)];\n  packer.packStruct(LOCAL_TIME, packableStructFields);\n}\n/**\n * Unpack local time value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result local time should be native JS numbers.\n * @return {LocalTime} the unpacked local time value.\n */\n\n\nfunction unpackLocalTime(unpacker, structSize, buffer, disableLosslessIntegers) {\n  unpacker._verifyStructSize('LocalTime', LOCAL_TIME_STRUCT_SIZE, structSize);\n\n  var nanoOfDay = unpacker.unpackInteger(buffer);\n  var result = (0, _temporalUtil.nanoOfDayToLocalTime)(nanoOfDay);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);\n}\n/**\n * Pack given time.\n * @param {Time} value the time value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packTime(value, packer) {\n  var nanoOfDay = (0, _temporalUtil.localTimeToNanoOfDay)(value.hour, value.minute, value.second, value.nanosecond);\n  var offsetSeconds = (0, _integer[\"int\"])(value.timeZoneOffsetSeconds);\n  var packableStructFields = [packer.packable(nanoOfDay), packer.packable(offsetSeconds)];\n  packer.packStruct(TIME, packableStructFields);\n}\n/**\n * Unpack time value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result time should be native JS numbers.\n * @return {Time} the unpacked time value.\n */\n\n\nfunction unpackTime(unpacker, structSize, buffer, disableLosslessIntegers) {\n  unpacker._verifyStructSize('Time', TIME_STRUCT_SIZE, structSize);\n\n  var nanoOfDay = unpacker.unpackInteger(buffer);\n  var offsetSeconds = unpacker.unpackInteger(buffer);\n  var localTime = (0, _temporalUtil.nanoOfDayToLocalTime)(nanoOfDay);\n  var result = new _temporalTypes.Time(localTime.hour, localTime.minute, localTime.second, localTime.nanosecond, offsetSeconds);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);\n}\n/**\n * Pack given neo4j date.\n * @param {Date} value the date value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packDate(value, packer) {\n  var epochDay = (0, _temporalUtil.dateToEpochDay)(value.year, value.month, value.day);\n  var packableStructFields = [packer.packable(epochDay)];\n  packer.packStruct(DATE, packableStructFields);\n}\n/**\n * Unpack neo4j date value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result date should be native JS numbers.\n * @return {Date} the unpacked neo4j date value.\n */\n\n\nfunction unpackDate(unpacker, structSize, buffer, disableLosslessIntegers) {\n  unpacker._verifyStructSize('Date', DATE_STRUCT_SIZE, structSize);\n\n  var epochDay = unpacker.unpackInteger(buffer);\n  var result = (0, _temporalUtil.epochDayToDate)(epochDay);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);\n}\n/**\n * Pack given local date time.\n * @param {LocalDateTime} value the local date time value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packLocalDateTime(value, packer) {\n  var epochSecond = (0, _temporalUtil.localDateTimeToEpochSecond)(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n  var nano = (0, _integer[\"int\"])(value.nanosecond);\n  var packableStructFields = [packer.packable(epochSecond), packer.packable(nano)];\n  packer.packStruct(LOCAL_DATE_TIME, packableStructFields);\n}\n/**\n * Unpack local date time value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result local date-time should be native JS numbers.\n * @return {LocalDateTime} the unpacked local date time value.\n */\n\n\nfunction unpackLocalDateTime(unpacker, structSize, buffer, disableLosslessIntegers) {\n  unpacker._verifyStructSize('LocalDateTime', LOCAL_DATE_TIME_STRUCT_SIZE, structSize);\n\n  var epochSecond = unpacker.unpackInteger(buffer);\n  var nano = unpacker.unpackInteger(buffer);\n  var result = (0, _temporalUtil.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);\n}\n/**\n * Pack given date time.\n * @param {DateTime} value the date time value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packDateTime(value, packer) {\n  if (value.timeZoneId) {\n    packDateTimeWithZoneId(value, packer);\n  } else {\n    packDateTimeWithZoneOffset(value, packer);\n  }\n}\n/**\n * Pack given date time with zone offset.\n * @param {DateTime} value the date time value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packDateTimeWithZoneOffset(value, packer) {\n  var epochSecond = (0, _temporalUtil.localDateTimeToEpochSecond)(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n  var nano = (0, _integer[\"int\"])(value.nanosecond);\n  var timeZoneOffsetSeconds = (0, _integer[\"int\"])(value.timeZoneOffsetSeconds);\n  var packableStructFields = [packer.packable(epochSecond), packer.packable(nano), packer.packable(timeZoneOffsetSeconds)];\n  packer.packStruct(DATE_TIME_WITH_ZONE_OFFSET, packableStructFields);\n}\n/**\n * Unpack date time with zone offset value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.\n * @return {DateTime} the unpacked date time with zone offset value.\n */\n\n\nfunction unpackDateTimeWithZoneOffset(unpacker, structSize, buffer, disableLosslessIntegers) {\n  unpacker._verifyStructSize('DateTimeWithZoneOffset', DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE, structSize);\n\n  var epochSecond = unpacker.unpackInteger(buffer);\n  var nano = unpacker.unpackInteger(buffer);\n  var timeZoneOffsetSeconds = unpacker.unpackInteger(buffer);\n  var localDateTime = (0, _temporalUtil.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n  var result = new _temporalTypes.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, timeZoneOffsetSeconds, null);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);\n}\n/**\n * Pack given date time with zone id.\n * @param {DateTime} value the date time value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packDateTimeWithZoneId(value, packer) {\n  var epochSecond = (0, _temporalUtil.localDateTimeToEpochSecond)(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n  var nano = (0, _integer[\"int\"])(value.nanosecond);\n  var timeZoneId = value.timeZoneId;\n  var packableStructFields = [packer.packable(epochSecond), packer.packable(nano), packer.packable(timeZoneId)];\n  packer.packStruct(DATE_TIME_WITH_ZONE_ID, packableStructFields);\n}\n/**\n * Unpack date time with zone id value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.\n * @return {DateTime} the unpacked date time with zone id value.\n */\n\n\nfunction unpackDateTimeWithZoneId(unpacker, structSize, buffer, disableLosslessIntegers) {\n  unpacker._verifyStructSize('DateTimeWithZoneId', DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE, structSize);\n\n  var epochSecond = unpacker.unpackInteger(buffer);\n  var nano = unpacker.unpackInteger(buffer);\n  var timeZoneId = unpacker.unpack(buffer);\n  var localDateTime = (0, _temporalUtil.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n  var result = new _temporalTypes.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, null, timeZoneId);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);\n}\n\nfunction convertIntegerPropsIfNeeded(obj, disableLosslessIntegers) {\n  if (!disableLosslessIntegers) {\n    return obj;\n  }\n\n  var clone = Object.create(Object.getPrototypeOf(obj));\n\n  for (var prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      var value = obj[prop];\n      clone[prop] = (0, _integer.isInt)(value) ? value.toNumberOrInfinity() : value;\n    }\n  }\n\n  Object.freeze(clone);\n  return clone;\n}"]},"metadata":{},"sourceType":"script"}