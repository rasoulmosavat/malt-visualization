{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _streamObservers = require(\"./internal/stream-observers\");\n\nvar _result = _interopRequireDefault(require(\"./result\"));\n\nvar _transaction = _interopRequireDefault(require(\"./transaction\"));\n\nvar _error = require(\"./error\");\n\nvar _util = require(\"./internal/util\");\n\nvar _connectionHolder = _interopRequireDefault(require(\"./internal/connection-holder\"));\n\nvar _driver = _interopRequireDefault(require(\"./driver\"));\n\nvar _constants = require(\"./internal/constants\");\n\nvar _transactionExecutor = _interopRequireDefault(require(\"./internal/transaction-executor\"));\n\nvar _bookmark = _interopRequireDefault(require(\"./internal/bookmark\"));\n\nvar _txConfig = _interopRequireDefault(require(\"./internal/tx-config\"));\n/**\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A Session instance is used for handling the connection and\n * sending queries through the connection.\n * In a single session, multiple queries will be executed serially.\n * In order to execute parallel queries, multiple sessions are required.\n * @access public\n */\n\n\nvar Session = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * @protected\n   * @param {Object} args\n   * @param {string} args.mode the default access mode for this session.\n   * @param {ConnectionProvider} args.connectionProvider - The connection provider to acquire connections from.\n   * @param {Bookmark} args.bookmark - The initial bookmark for this session.\n   * @param {string} args.database the database name\n   * @param {Object} args.config={} - This driver configuration.\n   * @param {boolean} args.reactive - Whether this session should create reactive streams\n   * @param {number} args.fetchSize - Defines how many records is pulled in each pulling batch\n   */\n  function Session(_ref) {\n    var mode = _ref.mode,\n        connectionProvider = _ref.connectionProvider,\n        bookmark = _ref.bookmark,\n        database = _ref.database,\n        config = _ref.config,\n        reactive = _ref.reactive,\n        fetchSize = _ref.fetchSize;\n    (0, _classCallCheck2[\"default\"])(this, Session);\n    this._mode = mode;\n    this._database = database;\n    this._reactive = reactive;\n    this._fetchSize = fetchSize;\n    this._readConnectionHolder = new _connectionHolder[\"default\"]({\n      mode: _constants.ACCESS_MODE_READ,\n      database: database,\n      bookmark: bookmark,\n      connectionProvider: connectionProvider\n    });\n    this._writeConnectionHolder = new _connectionHolder[\"default\"]({\n      mode: _constants.ACCESS_MODE_WRITE,\n      database: database,\n      bookmark: bookmark,\n      connectionProvider: connectionProvider\n    });\n    this._open = true;\n    this._hasTx = false;\n    this._lastBookmark = bookmark;\n    this._transactionExecutor = _createTransactionExecutor(config);\n    this._onComplete = this._onCompleteCallback.bind(this);\n  }\n  /**\n   * Run Cypher query\n   * Could be called with a query object i.e.: `{text: \"MATCH ...\", prameters: {param: 1}}`\n   * or with the query and parameters as separate arguments.\n   *\n   * @public\n   * @param {mixed} query - Cypher query to execute\n   * @param {Object} parameters - Map with parameters to use in query\n   * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.\n   * @return {Result} New Result.\n   */\n\n\n  (0, _createClass2[\"default\"])(Session, [{\n    key: \"run\",\n    value: function run(query, parameters, transactionConfig) {\n      var _this = this;\n\n      var _validateQueryAndPara = (0, _util.validateQueryAndParameters)(query, parameters),\n          validatedQuery = _validateQueryAndPara.validatedQuery,\n          params = _validateQueryAndPara.params;\n\n      var autoCommitTxConfig = transactionConfig ? new _txConfig[\"default\"](transactionConfig) : _txConfig[\"default\"].empty();\n      return this._run(validatedQuery, params, function (connection) {\n        _this._assertSessionIsOpen();\n\n        return connection.protocol().run(validatedQuery, params, {\n          bookmark: _this._lastBookmark,\n          txConfig: autoCommitTxConfig,\n          mode: _this._mode,\n          database: _this._database,\n          afterComplete: _this._onComplete,\n          reactive: _this._reactive,\n          fetchSize: _this._fetchSize\n        });\n      });\n    }\n  }, {\n    key: \"_run\",\n    value: function _run(query, parameters, customRunner) {\n      var connectionHolder = this._connectionHolderWithMode(this._mode);\n\n      var observerPromise;\n\n      if (!this._open) {\n        observerPromise = Promise.resolve(new _streamObservers.FailedObserver({\n          error: (0, _error.newError)('Cannot run query in a closed session.')\n        }));\n      } else if (!this._hasTx && connectionHolder.initializeConnection()) {\n        observerPromise = connectionHolder.getConnection().then(function (connection) {\n          return customRunner(connection);\n        })[\"catch\"](function (error) {\n          return Promise.resolve(new _streamObservers.FailedObserver({\n            error: error\n          }));\n        });\n      } else {\n        observerPromise = Promise.resolve(new _streamObservers.FailedObserver({\n          error: (0, _error.newError)('Queries cannot be run directly on a ' + 'session with an open transaction; either run from within the ' + 'transaction or use a different session.')\n        }));\n      }\n\n      return new _result[\"default\"](observerPromise, query, parameters, connectionHolder);\n    }\n    /**\n     * Begin a new transaction in this session. A session can have at most one transaction running at a time, if you\n     * want to run multiple concurrent transactions, you should use multiple concurrent sessions.\n     *\n     * While a transaction is open the session cannot be used to run queries outside the transaction.\n     *\n     * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.\n     * @returns {Transaction} New Transaction.\n     */\n\n  }, {\n    key: \"beginTransaction\",\n    value: function beginTransaction(transactionConfig) {\n      // this function needs to support bookmarks parameter for backwards compatibility\n      // parameter was of type {string|string[]} and represented either a single or multiple bookmarks\n      // that's why we need to check parameter type and decide how to interpret the value\n      var arg = transactionConfig;\n\n      var txConfig = _txConfig[\"default\"].empty();\n\n      if (arg) {\n        txConfig = new _txConfig[\"default\"](arg);\n      }\n\n      return this._beginTransaction(this._mode, txConfig);\n    }\n  }, {\n    key: \"_beginTransaction\",\n    value: function _beginTransaction(accessMode, txConfig) {\n      if (!this._open) {\n        throw (0, _error.newError)('Cannot begin a transaction on a closed session.');\n      }\n\n      if (this._hasTx) {\n        throw (0, _error.newError)('You cannot begin a transaction on a session with an open transaction; ' + 'either run from within the transaction or use a different session.');\n      }\n\n      var mode = _driver[\"default\"]._validateSessionMode(accessMode);\n\n      var connectionHolder = this._connectionHolderWithMode(mode);\n\n      connectionHolder.initializeConnection();\n      this._hasTx = true;\n      var tx = new _transaction[\"default\"]({\n        connectionHolder: connectionHolder,\n        onClose: this._transactionClosed.bind(this),\n        onBookmark: this._updateBookmark.bind(this),\n        onConnection: this._assertSessionIsOpen.bind(this),\n        reactive: this._reactive,\n        fetchSize: this._fetchSize\n      });\n\n      tx._begin(this._lastBookmark, txConfig);\n\n      return tx;\n    }\n  }, {\n    key: \"_assertSessionIsOpen\",\n    value: function _assertSessionIsOpen() {\n      if (!this._open) {\n        throw (0, _error.newError)('You cannot run more transactions on a closed session.');\n      }\n    }\n  }, {\n    key: \"_transactionClosed\",\n    value: function _transactionClosed() {\n      this._hasTx = false;\n    }\n    /**\n     * Return the bookmark received following the last completed {@link Transaction}.\n     *\n     * @return {string[]} A reference to a previous transaction.\n     */\n\n  }, {\n    key: \"lastBookmark\",\n    value: function lastBookmark() {\n      return this._lastBookmark.values();\n    }\n    /**\n     * Execute given unit of work in a {@link READ} transaction.\n     *\n     * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n     * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n     * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n     * `maxTransactionRetryTime` property in milliseconds.\n     *\n     * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against\n     * a given {@link Transaction}.\n     * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n     * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n     * function or commit fails.\n     */\n\n  }, {\n    key: \"readTransaction\",\n    value: function readTransaction(transactionWork, transactionConfig) {\n      var config = new _txConfig[\"default\"](transactionConfig);\n      return this._runTransaction(_constants.ACCESS_MODE_READ, config, transactionWork);\n    }\n    /**\n     * Execute given unit of work in a {@link WRITE} transaction.\n     *\n     * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n     * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n     * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n     * `maxTransactionRetryTime` property in milliseconds.\n     *\n     * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against\n     * a given {@link Transaction}.\n     * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n     * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n     * function or commit fails.\n     */\n\n  }, {\n    key: \"writeTransaction\",\n    value: function writeTransaction(transactionWork, transactionConfig) {\n      var config = new _txConfig[\"default\"](transactionConfig);\n      return this._runTransaction(_constants.ACCESS_MODE_WRITE, config, transactionWork);\n    }\n  }, {\n    key: \"_runTransaction\",\n    value: function _runTransaction(accessMode, transactionConfig, transactionWork) {\n      var _this2 = this;\n\n      return this._transactionExecutor.execute(function () {\n        return _this2._beginTransaction(accessMode, transactionConfig);\n      }, transactionWork);\n    }\n    /**\n     * Update value of the last bookmark.\n     * @param {Bookmark} newBookmark - The new bookmark.\n     */\n\n  }, {\n    key: \"_updateBookmark\",\n    value: function _updateBookmark(newBookmark) {\n      if (newBookmark && !newBookmark.isEmpty()) {\n        this._lastBookmark = newBookmark;\n      }\n    }\n    /**\n     * Close this session.\n     * @return {Promise}\n     */\n\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee() {\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this._open) {\n                  _context.next = 7;\n                  break;\n                }\n\n                this._open = false;\n\n                this._transactionExecutor.close();\n\n                _context.next = 5;\n                return this._readConnectionHolder.close();\n\n              case 5:\n                _context.next = 7;\n                return this._writeConnectionHolder.close();\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n  }, {\n    key: \"_connectionHolderWithMode\",\n    value: function _connectionHolderWithMode(mode) {\n      if (mode === _constants.ACCESS_MODE_READ) {\n        return this._readConnectionHolder;\n      } else if (mode === _constants.ACCESS_MODE_WRITE) {\n        return this._writeConnectionHolder;\n      } else {\n        throw (0, _error.newError)('Unknown access mode: ' + mode);\n      }\n    }\n  }, {\n    key: \"_onCompleteCallback\",\n    value: function _onCompleteCallback(meta) {\n      this._updateBookmark(new _bookmark[\"default\"](meta.bookmark));\n    }\n  }]);\n  return Session;\n}();\n\nfunction _createTransactionExecutor(config) {\n  var maxRetryTimeMs = config && config.maxTransactionRetryTime ? config.maxTransactionRetryTime : null;\n  return new _transactionExecutor[\"default\"](maxRetryTimeMs);\n}\n\nvar _default = Session;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["d:/webback/pro5/node_modules/neo4j-driver/lib/session.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","_regenerator","_asyncToGenerator2","_classCallCheck2","_createClass2","_streamObservers","_result","_transaction","_error","_util","_connectionHolder","_driver","_constants","_transactionExecutor","_bookmark","_txConfig","Session","_ref","mode","connectionProvider","bookmark","database","config","reactive","fetchSize","_mode","_database","_reactive","_fetchSize","_readConnectionHolder","ACCESS_MODE_READ","_writeConnectionHolder","ACCESS_MODE_WRITE","_open","_hasTx","_lastBookmark","_createTransactionExecutor","_onComplete","_onCompleteCallback","bind","key","run","query","parameters","transactionConfig","_this","_validateQueryAndPara","validateQueryAndParameters","validatedQuery","params","autoCommitTxConfig","empty","_run","connection","_assertSessionIsOpen","protocol","txConfig","afterComplete","customRunner","connectionHolder","_connectionHolderWithMode","observerPromise","Promise","resolve","FailedObserver","error","newError","initializeConnection","getConnection","then","beginTransaction","arg","_beginTransaction","accessMode","_validateSessionMode","tx","onClose","_transactionClosed","onBookmark","_updateBookmark","onConnection","_begin","lastBookmark","values","readTransaction","transactionWork","_runTransaction","writeTransaction","_this2","execute","newBookmark","isEmpty","_close","mark","_callee","wrap","_callee$","_context","prev","next","close","stop","apply","arguments","meta","maxRetryTimeMs","maxTransactionRetryTime","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _streamObservers = require(\"./internal/stream-observers\");\n\nvar _result = _interopRequireDefault(require(\"./result\"));\n\nvar _transaction = _interopRequireDefault(require(\"./transaction\"));\n\nvar _error = require(\"./error\");\n\nvar _util = require(\"./internal/util\");\n\nvar _connectionHolder = _interopRequireDefault(require(\"./internal/connection-holder\"));\n\nvar _driver = _interopRequireDefault(require(\"./driver\"));\n\nvar _constants = require(\"./internal/constants\");\n\nvar _transactionExecutor = _interopRequireDefault(require(\"./internal/transaction-executor\"));\n\nvar _bookmark = _interopRequireDefault(require(\"./internal/bookmark\"));\n\nvar _txConfig = _interopRequireDefault(require(\"./internal/tx-config\"));\n\n/**\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A Session instance is used for handling the connection and\n * sending queries through the connection.\n * In a single session, multiple queries will be executed serially.\n * In order to execute parallel queries, multiple sessions are required.\n * @access public\n */\nvar Session =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @constructor\n   * @protected\n   * @param {Object} args\n   * @param {string} args.mode the default access mode for this session.\n   * @param {ConnectionProvider} args.connectionProvider - The connection provider to acquire connections from.\n   * @param {Bookmark} args.bookmark - The initial bookmark for this session.\n   * @param {string} args.database the database name\n   * @param {Object} args.config={} - This driver configuration.\n   * @param {boolean} args.reactive - Whether this session should create reactive streams\n   * @param {number} args.fetchSize - Defines how many records is pulled in each pulling batch\n   */\n  function Session(_ref) {\n    var mode = _ref.mode,\n        connectionProvider = _ref.connectionProvider,\n        bookmark = _ref.bookmark,\n        database = _ref.database,\n        config = _ref.config,\n        reactive = _ref.reactive,\n        fetchSize = _ref.fetchSize;\n    (0, _classCallCheck2[\"default\"])(this, Session);\n    this._mode = mode;\n    this._database = database;\n    this._reactive = reactive;\n    this._fetchSize = fetchSize;\n    this._readConnectionHolder = new _connectionHolder[\"default\"]({\n      mode: _constants.ACCESS_MODE_READ,\n      database: database,\n      bookmark: bookmark,\n      connectionProvider: connectionProvider\n    });\n    this._writeConnectionHolder = new _connectionHolder[\"default\"]({\n      mode: _constants.ACCESS_MODE_WRITE,\n      database: database,\n      bookmark: bookmark,\n      connectionProvider: connectionProvider\n    });\n    this._open = true;\n    this._hasTx = false;\n    this._lastBookmark = bookmark;\n    this._transactionExecutor = _createTransactionExecutor(config);\n    this._onComplete = this._onCompleteCallback.bind(this);\n  }\n  /**\n   * Run Cypher query\n   * Could be called with a query object i.e.: `{text: \"MATCH ...\", prameters: {param: 1}}`\n   * or with the query and parameters as separate arguments.\n   *\n   * @public\n   * @param {mixed} query - Cypher query to execute\n   * @param {Object} parameters - Map with parameters to use in query\n   * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.\n   * @return {Result} New Result.\n   */\n\n\n  (0, _createClass2[\"default\"])(Session, [{\n    key: \"run\",\n    value: function run(query, parameters, transactionConfig) {\n      var _this = this;\n\n      var _validateQueryAndPara = (0, _util.validateQueryAndParameters)(query, parameters),\n          validatedQuery = _validateQueryAndPara.validatedQuery,\n          params = _validateQueryAndPara.params;\n\n      var autoCommitTxConfig = transactionConfig ? new _txConfig[\"default\"](transactionConfig) : _txConfig[\"default\"].empty();\n      return this._run(validatedQuery, params, function (connection) {\n        _this._assertSessionIsOpen();\n\n        return connection.protocol().run(validatedQuery, params, {\n          bookmark: _this._lastBookmark,\n          txConfig: autoCommitTxConfig,\n          mode: _this._mode,\n          database: _this._database,\n          afterComplete: _this._onComplete,\n          reactive: _this._reactive,\n          fetchSize: _this._fetchSize\n        });\n      });\n    }\n  }, {\n    key: \"_run\",\n    value: function _run(query, parameters, customRunner) {\n      var connectionHolder = this._connectionHolderWithMode(this._mode);\n\n      var observerPromise;\n\n      if (!this._open) {\n        observerPromise = Promise.resolve(new _streamObservers.FailedObserver({\n          error: (0, _error.newError)('Cannot run query in a closed session.')\n        }));\n      } else if (!this._hasTx && connectionHolder.initializeConnection()) {\n        observerPromise = connectionHolder.getConnection().then(function (connection) {\n          return customRunner(connection);\n        })[\"catch\"](function (error) {\n          return Promise.resolve(new _streamObservers.FailedObserver({\n            error: error\n          }));\n        });\n      } else {\n        observerPromise = Promise.resolve(new _streamObservers.FailedObserver({\n          error: (0, _error.newError)('Queries cannot be run directly on a ' + 'session with an open transaction; either run from within the ' + 'transaction or use a different session.')\n        }));\n      }\n\n      return new _result[\"default\"](observerPromise, query, parameters, connectionHolder);\n    }\n    /**\n     * Begin a new transaction in this session. A session can have at most one transaction running at a time, if you\n     * want to run multiple concurrent transactions, you should use multiple concurrent sessions.\n     *\n     * While a transaction is open the session cannot be used to run queries outside the transaction.\n     *\n     * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.\n     * @returns {Transaction} New Transaction.\n     */\n\n  }, {\n    key: \"beginTransaction\",\n    value: function beginTransaction(transactionConfig) {\n      // this function needs to support bookmarks parameter for backwards compatibility\n      // parameter was of type {string|string[]} and represented either a single or multiple bookmarks\n      // that's why we need to check parameter type and decide how to interpret the value\n      var arg = transactionConfig;\n\n      var txConfig = _txConfig[\"default\"].empty();\n\n      if (arg) {\n        txConfig = new _txConfig[\"default\"](arg);\n      }\n\n      return this._beginTransaction(this._mode, txConfig);\n    }\n  }, {\n    key: \"_beginTransaction\",\n    value: function _beginTransaction(accessMode, txConfig) {\n      if (!this._open) {\n        throw (0, _error.newError)('Cannot begin a transaction on a closed session.');\n      }\n\n      if (this._hasTx) {\n        throw (0, _error.newError)('You cannot begin a transaction on a session with an open transaction; ' + 'either run from within the transaction or use a different session.');\n      }\n\n      var mode = _driver[\"default\"]._validateSessionMode(accessMode);\n\n      var connectionHolder = this._connectionHolderWithMode(mode);\n\n      connectionHolder.initializeConnection();\n      this._hasTx = true;\n      var tx = new _transaction[\"default\"]({\n        connectionHolder: connectionHolder,\n        onClose: this._transactionClosed.bind(this),\n        onBookmark: this._updateBookmark.bind(this),\n        onConnection: this._assertSessionIsOpen.bind(this),\n        reactive: this._reactive,\n        fetchSize: this._fetchSize\n      });\n\n      tx._begin(this._lastBookmark, txConfig);\n\n      return tx;\n    }\n  }, {\n    key: \"_assertSessionIsOpen\",\n    value: function _assertSessionIsOpen() {\n      if (!this._open) {\n        throw (0, _error.newError)('You cannot run more transactions on a closed session.');\n      }\n    }\n  }, {\n    key: \"_transactionClosed\",\n    value: function _transactionClosed() {\n      this._hasTx = false;\n    }\n    /**\n     * Return the bookmark received following the last completed {@link Transaction}.\n     *\n     * @return {string[]} A reference to a previous transaction.\n     */\n\n  }, {\n    key: \"lastBookmark\",\n    value: function lastBookmark() {\n      return this._lastBookmark.values();\n    }\n    /**\n     * Execute given unit of work in a {@link READ} transaction.\n     *\n     * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n     * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n     * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n     * `maxTransactionRetryTime` property in milliseconds.\n     *\n     * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against\n     * a given {@link Transaction}.\n     * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n     * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n     * function or commit fails.\n     */\n\n  }, {\n    key: \"readTransaction\",\n    value: function readTransaction(transactionWork, transactionConfig) {\n      var config = new _txConfig[\"default\"](transactionConfig);\n      return this._runTransaction(_constants.ACCESS_MODE_READ, config, transactionWork);\n    }\n    /**\n     * Execute given unit of work in a {@link WRITE} transaction.\n     *\n     * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n     * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n     * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n     * `maxTransactionRetryTime` property in milliseconds.\n     *\n     * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against\n     * a given {@link Transaction}.\n     * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n     * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n     * function or commit fails.\n     */\n\n  }, {\n    key: \"writeTransaction\",\n    value: function writeTransaction(transactionWork, transactionConfig) {\n      var config = new _txConfig[\"default\"](transactionConfig);\n      return this._runTransaction(_constants.ACCESS_MODE_WRITE, config, transactionWork);\n    }\n  }, {\n    key: \"_runTransaction\",\n    value: function _runTransaction(accessMode, transactionConfig, transactionWork) {\n      var _this2 = this;\n\n      return this._transactionExecutor.execute(function () {\n        return _this2._beginTransaction(accessMode, transactionConfig);\n      }, transactionWork);\n    }\n    /**\n     * Update value of the last bookmark.\n     * @param {Bookmark} newBookmark - The new bookmark.\n     */\n\n  }, {\n    key: \"_updateBookmark\",\n    value: function _updateBookmark(newBookmark) {\n      if (newBookmark && !newBookmark.isEmpty()) {\n        this._lastBookmark = newBookmark;\n      }\n    }\n    /**\n     * Close this session.\n     * @return {Promise}\n     */\n\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = (0, _asyncToGenerator2[\"default\"])(\n      /*#__PURE__*/\n      _regenerator[\"default\"].mark(function _callee() {\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this._open) {\n                  _context.next = 7;\n                  break;\n                }\n\n                this._open = false;\n\n                this._transactionExecutor.close();\n\n                _context.next = 5;\n                return this._readConnectionHolder.close();\n\n              case 5:\n                _context.next = 7;\n                return this._writeConnectionHolder.close();\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n  }, {\n    key: \"_connectionHolderWithMode\",\n    value: function _connectionHolderWithMode(mode) {\n      if (mode === _constants.ACCESS_MODE_READ) {\n        return this._readConnectionHolder;\n      } else if (mode === _constants.ACCESS_MODE_WRITE) {\n        return this._writeConnectionHolder;\n      } else {\n        throw (0, _error.newError)('Unknown access mode: ' + mode);\n      }\n    }\n  }, {\n    key: \"_onCompleteCallback\",\n    value: function _onCompleteCallback(meta) {\n      this._updateBookmark(new _bookmark[\"default\"](meta.bookmark));\n    }\n  }]);\n  return Session;\n}();\n\nfunction _createTransactionExecutor(config) {\n  var maxRetryTimeMs = config && config.maxTransactionRetryTime ? config.maxTransactionRetryTime : null;\n  return new _transactionExecutor[\"default\"](maxRetryTimeMs);\n}\n\nvar _default = Session;\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}