{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Dechunker = exports.Chunker = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _baseBuf = _interopRequireDefault(require(\"./buf/base-buf\"));\n\nvar _node = require(\"./node\");\n\nvar _combinedBuf = _interopRequireDefault(require(\"./buf/combined-buf\"));\n/**\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar _CHUNK_HEADER_SIZE = 2;\nvar _MESSAGE_BOUNDARY = 0x00;\nvar _DEFAULT_BUFFER_SIZE = 1400; // http://stackoverflow.com/questions/2613734/maximum-packet-size-for-a-tcp-connection\n\n/**\n * Looks like a writable buffer, chunks output transparently into a channel below.\n * @access private\n */\n\nvar Chunker = /*#__PURE__*/function (_BaseBuffer) {\n  (0, _inherits2[\"default\"])(Chunker, _BaseBuffer);\n\n  function Chunker(channel, bufferSize) {\n    var _this;\n\n    (0, _classCallCheck2[\"default\"])(this, Chunker);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(Chunker).call(this, 0));\n    _this._bufferSize = bufferSize || _DEFAULT_BUFFER_SIZE;\n    _this._ch = channel;\n    _this._buffer = (0, _node.alloc)(_this._bufferSize);\n    _this._currentChunkStart = 0;\n    _this._chunkOpen = false;\n    return _this;\n  }\n\n  (0, _createClass2[\"default\"])(Chunker, [{\n    key: \"putUInt8\",\n    value: function putUInt8(position, val) {\n      this._ensure(1);\n\n      this._buffer.writeUInt8(val);\n    }\n  }, {\n    key: \"putInt8\",\n    value: function putInt8(position, val) {\n      this._ensure(1);\n\n      this._buffer.writeInt8(val);\n    }\n  }, {\n    key: \"putFloat64\",\n    value: function putFloat64(position, val) {\n      this._ensure(8);\n\n      this._buffer.writeFloat64(val);\n    }\n  }, {\n    key: \"putBytes\",\n    value: function putBytes(position, data) {\n      // TODO: If data is larger than our chunk size or so, we're very likely better off just passing this buffer on\n      // rather than doing the copy here TODO: *however* note that we need some way to find out when the data has been\n      // written (and thus the buffer can be re-used) if we take that approach\n      while (data.remaining() > 0) {\n        // Ensure there is an open chunk, and that it has at least one byte of space left\n        this._ensure(1);\n\n        if (this._buffer.remaining() > data.remaining()) {\n          this._buffer.writeBytes(data);\n        } else {\n          this._buffer.writeBytes(data.readSlice(this._buffer.remaining()));\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      if (this._buffer.position > 0) {\n        this._closeChunkIfOpen(); // Local copy and clear the buffer field. This ensures that the buffer is not re-released if the flush call fails\n\n\n        var out = this._buffer;\n        this._buffer = null;\n\n        this._ch.write(out.getSlice(0, out.position)); // Alloc a new output buffer. We assume we're using NodeJS's buffer pooling under the hood here!\n\n\n        this._buffer = (0, _node.alloc)(this._bufferSize);\n        this._chunkOpen = false;\n      }\n\n      return this;\n    }\n    /**\n     * Bolt messages are encoded in one or more chunks, and the boundary between two messages\n     * is encoded as a 0-length chunk, `00 00`. This inserts such a message boundary, closing\n     * any currently open chunk as needed\n     */\n\n  }, {\n    key: \"messageBoundary\",\n    value: function messageBoundary() {\n      this._closeChunkIfOpen();\n\n      if (this._buffer.remaining() < _CHUNK_HEADER_SIZE) {\n        this.flush();\n      } // Write message boundary\n\n\n      this._buffer.writeInt16(_MESSAGE_BOUNDARY);\n    }\n    /** Ensure at least the given size is available for writing */\n\n  }, {\n    key: \"_ensure\",\n    value: function _ensure(size) {\n      var toWriteSize = this._chunkOpen ? size : size + _CHUNK_HEADER_SIZE;\n\n      if (this._buffer.remaining() < toWriteSize) {\n        this.flush();\n      }\n\n      if (!this._chunkOpen) {\n        this._currentChunkStart = this._buffer.position;\n        this._buffer.position = this._buffer.position + _CHUNK_HEADER_SIZE;\n        this._chunkOpen = true;\n      }\n    }\n  }, {\n    key: \"_closeChunkIfOpen\",\n    value: function _closeChunkIfOpen() {\n      if (this._chunkOpen) {\n        var chunkSize = this._buffer.position - (this._currentChunkStart + _CHUNK_HEADER_SIZE);\n\n        this._buffer.putUInt16(this._currentChunkStart, chunkSize);\n\n        this._chunkOpen = false;\n      }\n    }\n  }]);\n  return Chunker;\n}(_baseBuf[\"default\"]);\n/**\n * Combines chunks until a complete message is gathered up, and then forwards that\n * message to an 'onmessage' listener.\n * @access private\n */\n\n\nexports.Chunker = Chunker;\n\nvar Dechunker = /*#__PURE__*/function () {\n  function Dechunker() {\n    (0, _classCallCheck2[\"default\"])(this, Dechunker);\n    this._currentMessage = [];\n    this._partialChunkHeader = 0;\n    this._state = this.AWAITING_CHUNK;\n  }\n\n  (0, _createClass2[\"default\"])(Dechunker, [{\n    key: \"AWAITING_CHUNK\",\n    value: function AWAITING_CHUNK(buf) {\n      if (buf.remaining() >= 2) {\n        // Whole header available, read that\n        return this._onHeader(buf.readUInt16());\n      } else {\n        // Only one byte available, read that and wait for the second byte\n        this._partialChunkHeader = buf.readUInt8() << 8;\n        return this.IN_HEADER;\n      }\n    }\n  }, {\n    key: \"IN_HEADER\",\n    value: function IN_HEADER(buf) {\n      // First header byte read, now we read the next one\n      return this._onHeader((this._partialChunkHeader | buf.readUInt8()) & 0xffff);\n    }\n  }, {\n    key: \"IN_CHUNK\",\n    value: function IN_CHUNK(buf) {\n      if (this._chunkSize <= buf.remaining()) {\n        // Current packet is larger than current chunk, or same size:\n        this._currentMessage.push(buf.readSlice(this._chunkSize));\n\n        return this.AWAITING_CHUNK;\n      } else {\n        // Current packet is smaller than the chunk we're reading, split the current chunk itself up\n        this._chunkSize -= buf.remaining();\n\n        this._currentMessage.push(buf.readSlice(buf.remaining()));\n\n        return this.IN_CHUNK;\n      }\n    }\n  }, {\n    key: \"CLOSED\",\n    value: function CLOSED(buf) {} // no-op\n\n    /** Called when a complete chunk header has been received */\n\n  }, {\n    key: \"_onHeader\",\n    value: function _onHeader(header) {\n      if (header === 0) {\n        // Message boundary\n        var message;\n\n        if (this._currentMessage.length === 1) {\n          message = this._currentMessage[0];\n        } else {\n          message = new _combinedBuf[\"default\"](this._currentMessage);\n        }\n\n        this._currentMessage = [];\n        this.onmessage(message);\n        return this.AWAITING_CHUNK;\n      } else {\n        this._chunkSize = header;\n        return this.IN_CHUNK;\n      }\n    }\n  }, {\n    key: \"write\",\n    value: function write(buf) {\n      while (buf.hasRemaining()) {\n        this._state = this._state(buf);\n      }\n    }\n  }]);\n  return Dechunker;\n}();\n\nexports.Dechunker = Dechunker;","map":{"version":3,"sources":["d:/webback/pro5/node_modules/neo4j-driver/lib/internal/chunking.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","Dechunker","Chunker","_classCallCheck2","_createClass2","_possibleConstructorReturn2","_getPrototypeOf2","_inherits2","_baseBuf","_node","_combinedBuf","_CHUNK_HEADER_SIZE","_MESSAGE_BOUNDARY","_DEFAULT_BUFFER_SIZE","_BaseBuffer","channel","bufferSize","_this","call","_bufferSize","_ch","_buffer","alloc","_currentChunkStart","_chunkOpen","key","putUInt8","position","val","_ensure","writeUInt8","putInt8","writeInt8","putFloat64","writeFloat64","putBytes","data","remaining","writeBytes","readSlice","flush","_closeChunkIfOpen","out","write","getSlice","messageBoundary","writeInt16","size","toWriteSize","chunkSize","putUInt16","_currentMessage","_partialChunkHeader","_state","AWAITING_CHUNK","buf","_onHeader","readUInt16","readUInt8","IN_HEADER","IN_CHUNK","_chunkSize","push","CLOSED","header","message","length","onmessage","hasRemaining"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Dechunker = exports.Chunker = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _baseBuf = _interopRequireDefault(require(\"./buf/base-buf\"));\n\nvar _node = require(\"./node\");\n\nvar _combinedBuf = _interopRequireDefault(require(\"./buf/combined-buf\"));\n\n/**\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _CHUNK_HEADER_SIZE = 2;\nvar _MESSAGE_BOUNDARY = 0x00;\nvar _DEFAULT_BUFFER_SIZE = 1400; // http://stackoverflow.com/questions/2613734/maximum-packet-size-for-a-tcp-connection\n\n/**\n * Looks like a writable buffer, chunks output transparently into a channel below.\n * @access private\n */\n\nvar Chunker =\n/*#__PURE__*/\nfunction (_BaseBuffer) {\n  (0, _inherits2[\"default\"])(Chunker, _BaseBuffer);\n\n  function Chunker(channel, bufferSize) {\n    var _this;\n\n    (0, _classCallCheck2[\"default\"])(this, Chunker);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(Chunker).call(this, 0));\n    _this._bufferSize = bufferSize || _DEFAULT_BUFFER_SIZE;\n    _this._ch = channel;\n    _this._buffer = (0, _node.alloc)(_this._bufferSize);\n    _this._currentChunkStart = 0;\n    _this._chunkOpen = false;\n    return _this;\n  }\n\n  (0, _createClass2[\"default\"])(Chunker, [{\n    key: \"putUInt8\",\n    value: function putUInt8(position, val) {\n      this._ensure(1);\n\n      this._buffer.writeUInt8(val);\n    }\n  }, {\n    key: \"putInt8\",\n    value: function putInt8(position, val) {\n      this._ensure(1);\n\n      this._buffer.writeInt8(val);\n    }\n  }, {\n    key: \"putFloat64\",\n    value: function putFloat64(position, val) {\n      this._ensure(8);\n\n      this._buffer.writeFloat64(val);\n    }\n  }, {\n    key: \"putBytes\",\n    value: function putBytes(position, data) {\n      // TODO: If data is larger than our chunk size or so, we're very likely better off just passing this buffer on\n      // rather than doing the copy here TODO: *however* note that we need some way to find out when the data has been\n      // written (and thus the buffer can be re-used) if we take that approach\n      while (data.remaining() > 0) {\n        // Ensure there is an open chunk, and that it has at least one byte of space left\n        this._ensure(1);\n\n        if (this._buffer.remaining() > data.remaining()) {\n          this._buffer.writeBytes(data);\n        } else {\n          this._buffer.writeBytes(data.readSlice(this._buffer.remaining()));\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      if (this._buffer.position > 0) {\n        this._closeChunkIfOpen(); // Local copy and clear the buffer field. This ensures that the buffer is not re-released if the flush call fails\n\n\n        var out = this._buffer;\n        this._buffer = null;\n\n        this._ch.write(out.getSlice(0, out.position)); // Alloc a new output buffer. We assume we're using NodeJS's buffer pooling under the hood here!\n\n\n        this._buffer = (0, _node.alloc)(this._bufferSize);\n        this._chunkOpen = false;\n      }\n\n      return this;\n    }\n    /**\n     * Bolt messages are encoded in one or more chunks, and the boundary between two messages\n     * is encoded as a 0-length chunk, `00 00`. This inserts such a message boundary, closing\n     * any currently open chunk as needed\n     */\n\n  }, {\n    key: \"messageBoundary\",\n    value: function messageBoundary() {\n      this._closeChunkIfOpen();\n\n      if (this._buffer.remaining() < _CHUNK_HEADER_SIZE) {\n        this.flush();\n      } // Write message boundary\n\n\n      this._buffer.writeInt16(_MESSAGE_BOUNDARY);\n    }\n    /** Ensure at least the given size is available for writing */\n\n  }, {\n    key: \"_ensure\",\n    value: function _ensure(size) {\n      var toWriteSize = this._chunkOpen ? size : size + _CHUNK_HEADER_SIZE;\n\n      if (this._buffer.remaining() < toWriteSize) {\n        this.flush();\n      }\n\n      if (!this._chunkOpen) {\n        this._currentChunkStart = this._buffer.position;\n        this._buffer.position = this._buffer.position + _CHUNK_HEADER_SIZE;\n        this._chunkOpen = true;\n      }\n    }\n  }, {\n    key: \"_closeChunkIfOpen\",\n    value: function _closeChunkIfOpen() {\n      if (this._chunkOpen) {\n        var chunkSize = this._buffer.position - (this._currentChunkStart + _CHUNK_HEADER_SIZE);\n\n        this._buffer.putUInt16(this._currentChunkStart, chunkSize);\n\n        this._chunkOpen = false;\n      }\n    }\n  }]);\n  return Chunker;\n}(_baseBuf[\"default\"]);\n/**\n * Combines chunks until a complete message is gathered up, and then forwards that\n * message to an 'onmessage' listener.\n * @access private\n */\n\n\nexports.Chunker = Chunker;\n\nvar Dechunker =\n/*#__PURE__*/\nfunction () {\n  function Dechunker() {\n    (0, _classCallCheck2[\"default\"])(this, Dechunker);\n    this._currentMessage = [];\n    this._partialChunkHeader = 0;\n    this._state = this.AWAITING_CHUNK;\n  }\n\n  (0, _createClass2[\"default\"])(Dechunker, [{\n    key: \"AWAITING_CHUNK\",\n    value: function AWAITING_CHUNK(buf) {\n      if (buf.remaining() >= 2) {\n        // Whole header available, read that\n        return this._onHeader(buf.readUInt16());\n      } else {\n        // Only one byte available, read that and wait for the second byte\n        this._partialChunkHeader = buf.readUInt8() << 8;\n        return this.IN_HEADER;\n      }\n    }\n  }, {\n    key: \"IN_HEADER\",\n    value: function IN_HEADER(buf) {\n      // First header byte read, now we read the next one\n      return this._onHeader((this._partialChunkHeader | buf.readUInt8()) & 0xffff);\n    }\n  }, {\n    key: \"IN_CHUNK\",\n    value: function IN_CHUNK(buf) {\n      if (this._chunkSize <= buf.remaining()) {\n        // Current packet is larger than current chunk, or same size:\n        this._currentMessage.push(buf.readSlice(this._chunkSize));\n\n        return this.AWAITING_CHUNK;\n      } else {\n        // Current packet is smaller than the chunk we're reading, split the current chunk itself up\n        this._chunkSize -= buf.remaining();\n\n        this._currentMessage.push(buf.readSlice(buf.remaining()));\n\n        return this.IN_CHUNK;\n      }\n    }\n  }, {\n    key: \"CLOSED\",\n    value: function CLOSED(buf) {} // no-op\n\n    /** Called when a complete chunk header has been received */\n\n  }, {\n    key: \"_onHeader\",\n    value: function _onHeader(header) {\n      if (header === 0) {\n        // Message boundary\n        var message;\n\n        if (this._currentMessage.length === 1) {\n          message = this._currentMessage[0];\n        } else {\n          message = new _combinedBuf[\"default\"](this._currentMessage);\n        }\n\n        this._currentMessage = [];\n        this.onmessage(message);\n        return this.AWAITING_CHUNK;\n      } else {\n        this._chunkSize = header;\n        return this.IN_CHUNK;\n      }\n    }\n  }, {\n    key: \"write\",\n    value: function write(buf) {\n      while (buf.hasRemaining()) {\n        this._state = this._state(buf);\n      }\n    }\n  }]);\n  return Dechunker;\n}();\n\nexports.Dechunker = Dechunker;"]},"metadata":{},"sourceType":"script"}