{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.toString = exports.toNumber = exports.inSafeRange = exports.isInt = exports[\"int\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _error = require(\"./error\");\n/**\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// 64-bit Integer library, originally from Long.js by dcodeIO\n// https://github.com/dcodeIO/Long.js\n// License Apache 2\n\n/**\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\n * See exported functions for more convenient ways of operating integers.\n * Use `int()` function to create new integers, `isInt()` to check if given object is integer,\n * `inSafeRange()` to check if it is safe to convert given value to native number,\n * `toNumber()` and `toString()` to convert given integer to number or string respectively.\n * @access public\n * @exports Integer\n * @class A Integer class for representing a 64 bit two's-complement integer value.\n * @param {number} low The low (signed) 32 bits of the long\n * @param {number} high The high (signed) 32 bits of the long\n * @constructor\n */\n\n\nvar Integer = /*#__PURE__*/function () {\n  function Integer(low, high) {\n    (0, _classCallCheck2[\"default\"])(this, Integer);\n    /**\n     * The low 32 bits as a signed value.\n     * @type {number}\n     * @expose\n     */\n\n    this.low = low | 0;\n    /**\n     * The high 32 bits as a signed value.\n     * @type {number}\n     * @expose\n     */\n\n    this.high = high | 0;\n  } // The internal representation of an Integer is the two given signed, 32-bit values.\n  // We use 32-bit pieces because these are the size of integers on which\n  // JavaScript performs bit-operations.  For operations like addition and\n  // multiplication, we split each number into 16 bit pieces, which can easily be\n  // multiplied within JavaScript's floating-point representation without overflow\n  // or change in sign.\n  //\n  // In the algorithms below, we frequently reduce the negative case to the\n  // positive case by negating the input(s) and then post-processing the result.\n  // Note that we must ALWAYS check specially whether those values are MIN_VALUE\n  // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n  // a positive number, it overflows back into a negative).  Not handling this\n  // case would often result in infinite recursion.\n  //\n  // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\n  // methods on which they depend.\n\n\n  (0, _createClass2[\"default\"])(Integer, [{\n    key: \"inSafeRange\",\n    value: function inSafeRange() {\n      return this.greaterThanOrEqual(Integer.MIN_SAFE_VALUE) && this.lessThanOrEqual(Integer.MAX_SAFE_VALUE);\n    }\n    /**\n     * Converts the Integer to an exact javascript Number, assuming it is a 32 bit integer.\n     * @returns {number}\n     * @expose\n     */\n\n  }, {\n    key: \"toInt\",\n    value: function toInt() {\n      return this.low;\n    }\n    /**\n     * Converts the Integer to a the nearest floating-point representation of this value (double, 53 bit mantissa).\n     * @returns {number}\n     * @expose\n     */\n\n  }, {\n    key: \"toNumber\",\n    value: function toNumber() {\n      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n    }\n    /**\n     * Converts the Integer to native number or -Infinity/+Infinity when it does not fit.\n     * @return {number}\n     * @package\n     */\n\n  }, {\n    key: \"toNumberOrInfinity\",\n    value: function toNumberOrInfinity() {\n      if (this.lessThan(Integer.MIN_SAFE_VALUE)) {\n        return Number.NEGATIVE_INFINITY;\n      } else if (this.greaterThan(Integer.MAX_SAFE_VALUE)) {\n        return Number.POSITIVE_INFINITY;\n      } else {\n        return this.toNumber();\n      }\n    }\n    /**\n     * Converts the Integer to a string written in the specified radix.\n     * @param {number=} radix Radix (2-36), defaults to 10\n     * @returns {string}\n     * @override\n     * @throws {RangeError} If `radix` is out of range\n     * @expose\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString(radix) {\n      radix = radix || 10;\n\n      if (radix < 2 || radix > 36) {\n        throw RangeError('radix out of range: ' + radix);\n      }\n\n      if (this.isZero()) {\n        return '0';\n      }\n\n      var rem;\n\n      if (this.isNegative()) {\n        if (this.equals(Integer.MIN_VALUE)) {\n          // We need to change the Integer value before it can be negated, so we remove\n          // the bottom-most digit in this base and then recurse to do the rest.\n          var radixInteger = Integer.fromNumber(radix);\n          var div = this.div(radixInteger);\n          rem = div.multiply(radixInteger).subtract(this);\n          return div.toString(radix) + rem.toInt().toString(radix);\n        } else {\n          return '-' + this.negate().toString(radix);\n        }\n      } // Do several (6) digits each time through the loop, so as to\n      // minimize the calls to the very expensive emulated div.\n\n\n      var radixToPower = Integer.fromNumber(Math.pow(radix, 6));\n      rem = this;\n      var result = '';\n\n      while (true) {\n        var remDiv = rem.div(radixToPower);\n        var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt() >>> 0;\n        var digits = intval.toString(radix);\n        rem = remDiv;\n\n        if (rem.isZero()) {\n          return digits + result;\n        } else {\n          while (digits.length < 6) {\n            digits = '0' + digits;\n          }\n\n          result = '' + digits + result;\n        }\n      }\n    }\n    /**\n     * Gets the high 32 bits as a signed integer.\n     * @returns {number} Signed high bits\n     * @expose\n     */\n\n  }, {\n    key: \"getHighBits\",\n    value: function getHighBits() {\n      return this.high;\n    }\n    /**\n     * Gets the low 32 bits as a signed integer.\n     * @returns {number} Signed low bits\n     * @expose\n     */\n\n  }, {\n    key: \"getLowBits\",\n    value: function getLowBits() {\n      return this.low;\n    }\n    /**\n     * Gets the number of bits needed to represent the absolute value of this Integer.\n     * @returns {number}\n     * @expose\n     */\n\n  }, {\n    key: \"getNumBitsAbs\",\n    value: function getNumBitsAbs() {\n      if (this.isNegative()) {\n        return this.equals(Integer.MIN_VALUE) ? 64 : this.negate().getNumBitsAbs();\n      }\n\n      var val = this.high !== 0 ? this.high : this.low;\n\n      for (var bit = 31; bit > 0; bit--) {\n        if ((val & 1 << bit) !== 0) {\n          break;\n        }\n      }\n\n      return this.high !== 0 ? bit + 33 : bit + 1;\n    }\n    /**\n     * Tests if this Integer's value equals zero.\n     * @returns {boolean}\n     * @expose\n     */\n\n  }, {\n    key: \"isZero\",\n    value: function isZero() {\n      return this.high === 0 && this.low === 0;\n    }\n    /**\n     * Tests if this Integer's value is negative.\n     * @returns {boolean}\n     * @expose\n     */\n\n  }, {\n    key: \"isNegative\",\n    value: function isNegative() {\n      return this.high < 0;\n    }\n    /**\n     * Tests if this Integer's value is positive.\n     * @returns {boolean}\n     * @expose\n     */\n\n  }, {\n    key: \"isPositive\",\n    value: function isPositive() {\n      return this.high >= 0;\n    }\n    /**\n     * Tests if this Integer's value is odd.\n     * @returns {boolean}\n     * @expose\n     */\n\n  }, {\n    key: \"isOdd\",\n    value: function isOdd() {\n      return (this.low & 1) === 1;\n    }\n    /**\n     * Tests if this Integer's value is even.\n     * @returns {boolean}\n     * @expose\n     */\n\n  }, {\n    key: \"isEven\",\n    value: function isEven() {\n      return (this.low & 1) === 0;\n    }\n    /**\n     * Tests if this Integer's value equals the specified's.\n     * @param {!Integer|number|string} other Other value\n     * @returns {boolean}\n     * @expose\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (!Integer.isInteger(other)) {\n        other = Integer.fromValue(other);\n      }\n\n      return this.high === other.high && this.low === other.low;\n    }\n    /**\n     * Tests if this Integer's value differs from the specified's.\n     * @param {!Integer|number|string} other Other value\n     * @returns {boolean}\n     * @expose\n     */\n\n  }, {\n    key: \"notEquals\",\n    value: function notEquals(other) {\n      return !this.equals(\n      /* validates */\n      other);\n    }\n    /**\n     * Tests if this Integer's value is less than the specified's.\n     * @param {!Integer|number|string} other Other value\n     * @returns {boolean}\n     * @expose\n     */\n\n  }, {\n    key: \"lessThan\",\n    value: function lessThan(other) {\n      return this.compare(\n      /* validates */\n      other) < 0;\n    }\n    /**\n     * Tests if this Integer's value is less than or equal the specified's.\n     * @param {!Integer|number|string} other Other value\n     * @returns {boolean}\n     * @expose\n     */\n\n  }, {\n    key: \"lessThanOrEqual\",\n    value: function lessThanOrEqual(other) {\n      return this.compare(\n      /* validates */\n      other) <= 0;\n    }\n    /**\n     * Tests if this Integer's value is greater than the specified's.\n     * @param {!Integer|number|string} other Other value\n     * @returns {boolean}\n     * @expose\n     */\n\n  }, {\n    key: \"greaterThan\",\n    value: function greaterThan(other) {\n      return this.compare(\n      /* validates */\n      other) > 0;\n    }\n    /**\n     * Tests if this Integer's value is greater than or equal the specified's.\n     * @param {!Integer|number|string} other Other value\n     * @returns {boolean}\n     * @expose\n     */\n\n  }, {\n    key: \"greaterThanOrEqual\",\n    value: function greaterThanOrEqual(other) {\n      return this.compare(\n      /* validates */\n      other) >= 0;\n    }\n    /**\n     * Compares this Integer's value with the specified's.\n     * @param {!Integer|number|string} other Other value\n     * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n     *  if the given one is greater\n     * @expose\n     */\n\n  }, {\n    key: \"compare\",\n    value: function compare(other) {\n      if (!Integer.isInteger(other)) {\n        other = Integer.fromValue(other);\n      }\n\n      if (this.equals(other)) {\n        return 0;\n      }\n\n      var thisNeg = this.isNegative();\n      var otherNeg = other.isNegative();\n\n      if (thisNeg && !otherNeg) {\n        return -1;\n      }\n\n      if (!thisNeg && otherNeg) {\n        return 1;\n      } // At this point the sign bits are the same\n\n\n      return this.subtract(other).isNegative() ? -1 : 1;\n    }\n    /**\n     * Negates this Integer's value.\n     * @returns {!Integer} Negated Integer\n     * @expose\n     */\n\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      if (this.equals(Integer.MIN_VALUE)) {\n        return Integer.MIN_VALUE;\n      }\n\n      return this.not().add(Integer.ONE);\n    }\n    /**\n     * Returns the sum of this and the specified Integer.\n     * @param {!Integer|number|string} addend Addend\n     * @returns {!Integer} Sum\n     * @expose\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(addend) {\n      if (!Integer.isInteger(addend)) {\n        addend = Integer.fromValue(addend);\n      } // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n\n\n      var a48 = this.high >>> 16;\n      var a32 = this.high & 0xffff;\n      var a16 = this.low >>> 16;\n      var a00 = this.low & 0xffff;\n      var b48 = addend.high >>> 16;\n      var b32 = addend.high & 0xffff;\n      var b16 = addend.low >>> 16;\n      var b00 = addend.low & 0xffff;\n      var c48 = 0;\n      var c32 = 0;\n      var c16 = 0;\n      var c00 = 0;\n      c00 += a00 + b00;\n      c16 += c00 >>> 16;\n      c00 &= 0xffff;\n      c16 += a16 + b16;\n      c32 += c16 >>> 16;\n      c16 &= 0xffff;\n      c32 += a32 + b32;\n      c48 += c32 >>> 16;\n      c32 &= 0xffff;\n      c48 += a48 + b48;\n      c48 &= 0xffff;\n      return Integer.fromBits(c16 << 16 | c00, c48 << 16 | c32);\n    }\n    /**\n     * Returns the difference of this and the specified Integer.\n     * @param {!Integer|number|string} subtrahend Subtrahend\n     * @returns {!Integer} Difference\n     * @expose\n     */\n\n  }, {\n    key: \"subtract\",\n    value: function subtract(subtrahend) {\n      if (!Integer.isInteger(subtrahend)) {\n        subtrahend = Integer.fromValue(subtrahend);\n      }\n\n      return this.add(subtrahend.negate());\n    }\n    /**\n     * Returns the product of this and the specified Integer.\n     * @param {!Integer|number|string} multiplier Multiplier\n     * @returns {!Integer} Product\n     * @expose\n     */\n\n  }, {\n    key: \"multiply\",\n    value: function multiply(multiplier) {\n      if (this.isZero()) {\n        return Integer.ZERO;\n      }\n\n      if (!Integer.isInteger(multiplier)) {\n        multiplier = Integer.fromValue(multiplier);\n      }\n\n      if (multiplier.isZero()) {\n        return Integer.ZERO;\n      }\n\n      if (this.equals(Integer.MIN_VALUE)) {\n        return multiplier.isOdd() ? Integer.MIN_VALUE : Integer.ZERO;\n      }\n\n      if (multiplier.equals(Integer.MIN_VALUE)) {\n        return this.isOdd() ? Integer.MIN_VALUE : Integer.ZERO;\n      }\n\n      if (this.isNegative()) {\n        if (multiplier.isNegative()) {\n          return this.negate().multiply(multiplier.negate());\n        } else {\n          return this.negate().multiply(multiplier).negate();\n        }\n      } else if (multiplier.isNegative()) {\n        return this.multiply(multiplier.negate()).negate();\n      } // If both longs are small, use float multiplication\n\n\n      if (this.lessThan(TWO_PWR_24) && multiplier.lessThan(TWO_PWR_24)) {\n        return Integer.fromNumber(this.toNumber() * multiplier.toNumber());\n      } // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n      // We can skip products that would overflow.\n\n\n      var a48 = this.high >>> 16;\n      var a32 = this.high & 0xffff;\n      var a16 = this.low >>> 16;\n      var a00 = this.low & 0xffff;\n      var b48 = multiplier.high >>> 16;\n      var b32 = multiplier.high & 0xffff;\n      var b16 = multiplier.low >>> 16;\n      var b00 = multiplier.low & 0xffff;\n      var c48 = 0;\n      var c32 = 0;\n      var c16 = 0;\n      var c00 = 0;\n      c00 += a00 * b00;\n      c16 += c00 >>> 16;\n      c00 &= 0xffff;\n      c16 += a16 * b00;\n      c32 += c16 >>> 16;\n      c16 &= 0xffff;\n      c16 += a00 * b16;\n      c32 += c16 >>> 16;\n      c16 &= 0xffff;\n      c32 += a32 * b00;\n      c48 += c32 >>> 16;\n      c32 &= 0xffff;\n      c32 += a16 * b16;\n      c48 += c32 >>> 16;\n      c32 &= 0xffff;\n      c32 += a00 * b32;\n      c48 += c32 >>> 16;\n      c32 &= 0xffff;\n      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n      c48 &= 0xffff;\n      return Integer.fromBits(c16 << 16 | c00, c48 << 16 | c32);\n    }\n    /**\n     * Returns this Integer divided by the specified.\n     * @param {!Integer|number|string} divisor Divisor\n     * @returns {!Integer} Quotient\n     * @expose\n     */\n\n  }, {\n    key: \"div\",\n    value: function div(divisor) {\n      if (!Integer.isInteger(divisor)) {\n        divisor = Integer.fromValue(divisor);\n      }\n\n      if (divisor.isZero()) {\n        throw (0, _error.newError)('division by zero');\n      }\n\n      if (this.isZero()) {\n        return Integer.ZERO;\n      }\n\n      var approx, rem, res;\n\n      if (this.equals(Integer.MIN_VALUE)) {\n        if (divisor.equals(Integer.ONE) || divisor.equals(Integer.NEG_ONE)) {\n          return Integer.MIN_VALUE;\n        }\n\n        if (divisor.equals(Integer.MIN_VALUE)) {\n          return Integer.ONE;\n        } else {\n          // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n          var halfThis = this.shiftRight(1);\n          approx = halfThis.div(divisor).shiftLeft(1);\n\n          if (approx.equals(Integer.ZERO)) {\n            return divisor.isNegative() ? Integer.ONE : Integer.NEG_ONE;\n          } else {\n            rem = this.subtract(divisor.multiply(approx));\n            res = approx.add(rem.div(divisor));\n            return res;\n          }\n        }\n      } else if (divisor.equals(Integer.MIN_VALUE)) {\n        return Integer.ZERO;\n      }\n\n      if (this.isNegative()) {\n        if (divisor.isNegative()) {\n          return this.negate().div(divisor.negate());\n        }\n\n        return this.negate().div(divisor).negate();\n      } else if (divisor.isNegative()) {\n        return this.div(divisor.negate()).negate();\n      } // Repeat the following until the remainder is less than other:  find a\n      // floating-point that approximates remainder / other *from below*, add this\n      // into the result, and subtract it from the remainder.  It is critical that\n      // the approximate value is less than or equal to the real value so that the\n      // remainder never becomes negative.\n\n\n      res = Integer.ZERO;\n      rem = this;\n\n      while (rem.greaterThanOrEqual(divisor)) {\n        // Approximate the result of division. This may be a little greater or\n        // smaller than the actual value.\n        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber())); // We will tweak the approximate result by changing it in the 48-th digit or\n        // the smallest non-fractional digit, whichever is larger.\n\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2);\n        var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48); // Decrease the approximation until it is smaller than the remainder.  Note\n        // that if it is too large, the product overflows and is negative.\n\n        var approxRes = Integer.fromNumber(approx);\n        var approxRem = approxRes.multiply(divisor);\n\n        while (approxRem.isNegative() || approxRem.greaterThan(rem)) {\n          approx -= delta;\n          approxRes = Integer.fromNumber(approx);\n          approxRem = approxRes.multiply(divisor);\n        } // We know the answer can't be zero... and actually, zero would cause\n        // infinite recursion since we would make no progress.\n\n\n        if (approxRes.isZero()) {\n          approxRes = Integer.ONE;\n        }\n\n        res = res.add(approxRes);\n        rem = rem.subtract(approxRem);\n      }\n\n      return res;\n    }\n    /**\n     * Returns this Integer modulo the specified.\n     * @param {!Integer|number|string} divisor Divisor\n     * @returns {!Integer} Remainder\n     * @expose\n     */\n\n  }, {\n    key: \"modulo\",\n    value: function modulo(divisor) {\n      if (!Integer.isInteger(divisor)) {\n        divisor = Integer.fromValue(divisor);\n      }\n\n      return this.subtract(this.div(divisor).multiply(divisor));\n    }\n    /**\n     * Returns the bitwise NOT of this Integer.\n     * @returns {!Integer}\n     * @expose\n     */\n\n  }, {\n    key: \"not\",\n    value: function not() {\n      return Integer.fromBits(~this.low, ~this.high);\n    }\n    /**\n     * Returns the bitwise AND of this Integer and the specified.\n     * @param {!Integer|number|string} other Other Integer\n     * @returns {!Integer}\n     * @expose\n     */\n\n  }, {\n    key: \"and\",\n    value: function and(other) {\n      if (!Integer.isInteger(other)) {\n        other = Integer.fromValue(other);\n      }\n\n      return Integer.fromBits(this.low & other.low, this.high & other.high);\n    }\n    /**\n     * Returns the bitwise OR of this Integer and the specified.\n     * @param {!Integer|number|string} other Other Integer\n     * @returns {!Integer}\n     * @expose\n     */\n\n  }, {\n    key: \"or\",\n    value: function or(other) {\n      if (!Integer.isInteger(other)) {\n        other = Integer.fromValue(other);\n      }\n\n      return Integer.fromBits(this.low | other.low, this.high | other.high);\n    }\n    /**\n     * Returns the bitwise XOR of this Integer and the given one.\n     * @param {!Integer|number|string} other Other Integer\n     * @returns {!Integer}\n     * @expose\n     */\n\n  }, {\n    key: \"xor\",\n    value: function xor(other) {\n      if (!Integer.isInteger(other)) {\n        other = Integer.fromValue(other);\n      }\n\n      return Integer.fromBits(this.low ^ other.low, this.high ^ other.high);\n    }\n    /**\n     * Returns this Integer with bits shifted to the left by the given amount.\n     * @param {number|!Integer} numBits Number of bits\n     * @returns {!Integer} Shifted Integer\n     * @expose\n     */\n\n  }, {\n    key: \"shiftLeft\",\n    value: function shiftLeft(numBits) {\n      if (Integer.isInteger(numBits)) {\n        numBits = numBits.toInt();\n      }\n\n      if ((numBits &= 63) === 0) {\n        return this;\n      } else if (numBits < 32) {\n        return Integer.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits);\n      } else {\n        return Integer.fromBits(0, this.low << numBits - 32);\n      }\n    }\n    /**\n     * Returns this Integer with bits arithmetically shifted to the right by the given amount.\n     * @param {number|!Integer} numBits Number of bits\n     * @returns {!Integer} Shifted Integer\n     * @expose\n     */\n\n  }, {\n    key: \"shiftRight\",\n    value: function shiftRight(numBits) {\n      if (Integer.isInteger(numBits)) {\n        numBits = numBits.toInt();\n      }\n\n      if ((numBits &= 63) === 0) {\n        return this;\n      } else if (numBits < 32) {\n        return Integer.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits);\n      } else {\n        return Integer.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1);\n      }\n    }\n  }]);\n  return Integer;\n}();\n/**\n * An indicator used to reliably determine if an object is a Integer or not.\n * @type {boolean}\n * @const\n * @expose\n * @private\n */\n\n\nInteger.__isInteger__ = true;\nObject.defineProperty(Integer.prototype, '__isInteger__', {\n  value: true,\n  enumerable: false,\n  configurable: false\n});\n/**\n * Tests if the specified object is a Integer.\n * @access private\n * @param {*} obj Object\n * @returns {boolean}\n * @expose\n */\n\nInteger.isInteger = function (obj) {\n  return (obj && obj.__isInteger__) === true;\n};\n/**\n * A cache of the Integer representations of small integer values.\n * @type {!Object}\n * @inner\n * @private\n */\n\n\nvar INT_CACHE = {};\n/**\n * Returns a Integer representing the given 32 bit integer value.\n * @access private\n * @param {number} value The 32 bit integer in question\n * @returns {!Integer} The corresponding Integer value\n * @expose\n */\n\nInteger.fromInt = function (value) {\n  var obj, cachedObj;\n  value = value | 0;\n\n  if (value >= -128 && value < 128) {\n    cachedObj = INT_CACHE[value];\n\n    if (cachedObj) {\n      return cachedObj;\n    }\n  }\n\n  obj = new Integer(value, value < 0 ? -1 : 0, false);\n\n  if (value >= -128 && value < 128) {\n    INT_CACHE[value] = obj;\n  }\n\n  return obj;\n};\n/**\n * Returns a Integer representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n * @access private\n * @param {number} value The number in question\n * @returns {!Integer} The corresponding Integer value\n * @expose\n */\n\n\nInteger.fromNumber = function (value) {\n  if (isNaN(value) || !isFinite(value)) {\n    return Integer.ZERO;\n  }\n\n  if (value <= -TWO_PWR_63_DBL) {\n    return Integer.MIN_VALUE;\n  }\n\n  if (value + 1 >= TWO_PWR_63_DBL) {\n    return Integer.MAX_VALUE;\n  }\n\n  if (value < 0) {\n    return Integer.fromNumber(-value).negate();\n  }\n\n  return new Integer(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0);\n};\n/**\n * Returns a Integer representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\n *  assumed to use 32 bits.\n * @access private\n * @param {number} lowBits The low 32 bits\n * @param {number} highBits The high 32 bits\n * @returns {!Integer} The corresponding Integer value\n * @expose\n */\n\n\nInteger.fromBits = function (lowBits, highBits) {\n  return new Integer(lowBits, highBits);\n};\n/**\n * Returns a Integer representation of the given string, written using the specified radix.\n * @access private\n * @param {string} str The textual representation of the Integer\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\n * @returns {!Integer} The corresponding Integer value\n * @expose\n */\n\n\nInteger.fromString = function (str, radix) {\n  if (str.length === 0) {\n    throw (0, _error.newError)('number format error: empty string');\n  }\n\n  if (str === 'NaN' || str === 'Infinity' || str === '+Infinity' || str === '-Infinity') {\n    return Integer.ZERO;\n  }\n\n  radix = radix || 10;\n\n  if (radix < 2 || radix > 36) {\n    throw (0, _error.newError)('radix out of range: ' + radix);\n  }\n\n  var p;\n\n  if ((p = str.indexOf('-')) > 0) {\n    throw (0, _error.newError)('number format error: interior \"-\" character: ' + str);\n  } else if (p === 0) {\n    return Integer.fromString(str.substring(1), radix).negate();\n  } // Do several (8) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n\n\n  var radixToPower = Integer.fromNumber(Math.pow(radix, 8));\n  var result = Integer.ZERO;\n\n  for (var i = 0; i < str.length; i += 8) {\n    var size = Math.min(8, str.length - i);\n    var value = parseInt(str.substring(i, i + size), radix);\n\n    if (size < 8) {\n      var power = Integer.fromNumber(Math.pow(radix, size));\n      result = result.multiply(power).add(Integer.fromNumber(value));\n    } else {\n      result = result.multiply(radixToPower);\n      result = result.add(Integer.fromNumber(value));\n    }\n  }\n\n  return result;\n};\n/**\n * Converts the specified value to a Integer.\n * @access private\n * @param {!Integer|number|string|!{low: number, high: number}} val Value\n * @returns {!Integer}\n * @expose\n */\n\n\nInteger.fromValue = function (val) {\n  if (val\n  /* is compatible */\n  instanceof Integer) {\n    return val;\n  }\n\n  if (typeof val === 'number') {\n    return Integer.fromNumber(val);\n  }\n\n  if (typeof val === 'string') {\n    return Integer.fromString(val);\n  } // Throws for non-objects, converts non-instanceof Integer:\n\n\n  return new Integer(val.low, val.high);\n};\n/**\n * Converts the specified value to a number.\n * @access private\n * @param {!Integer|number|string|!{low: number, high: number}} val Value\n * @returns {number}\n * @expose\n */\n\n\nInteger.toNumber = function (val) {\n  return Integer.fromValue(val).toNumber();\n};\n/**\n * Converts the specified value to a string.\n * @access private\n * @param {!Integer|number|string|!{low: number, high: number}} val Value\n * @param {number} radix optional radix for string conversion, defaults to 10\n * @returns {string}\n * @expose\n */\n\n\nInteger.toString = function (val, radix) {\n  return Integer.fromValue(val).toString(radix);\n};\n/**\n * Checks if the given value is in the safe range in order to be converted to a native number\n * @access private\n * @param {!Integer|number|string|!{low: number, high: number}} val Value\n * @param {number} radix optional radix for string conversion, defaults to 10\n * @returns {boolean}\n * @expose\n */\n\n\nInteger.inSafeRange = function (val) {\n  return Integer.fromValue(val).inSafeRange();\n};\n/**\n * @type {number}\n * @const\n * @inner\n * @private\n */\n\n\nvar TWO_PWR_16_DBL = 1 << 16;\n/**\n * @type {number}\n * @const\n * @inner\n * @private\n */\n\nvar TWO_PWR_24_DBL = 1 << 24;\n/**\n * @type {number}\n * @const\n * @inner\n * @private\n */\n\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n/**\n * @type {number}\n * @const\n * @inner\n * @private\n */\n\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n/**\n * @type {number}\n * @const\n * @inner\n * @private\n */\n\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n/**\n * @type {!Integer}\n * @const\n * @inner\n * @private\n */\n\nvar TWO_PWR_24 = Integer.fromInt(TWO_PWR_24_DBL);\n/**\n * Signed zero.\n * @type {!Integer}\n * @expose\n */\n\nInteger.ZERO = Integer.fromInt(0);\n/**\n * Signed one.\n * @type {!Integer}\n * @expose\n */\n\nInteger.ONE = Integer.fromInt(1);\n/**\n * Signed negative one.\n * @type {!Integer}\n * @expose\n */\n\nInteger.NEG_ONE = Integer.fromInt(-1);\n/**\n * Maximum signed value.\n * @type {!Integer}\n * @expose\n */\n\nInteger.MAX_VALUE = Integer.fromBits(0xffffffff | 0, 0x7fffffff | 0, false);\n/**\n * Minimum signed value.\n * @type {!Integer}\n * @expose\n */\n\nInteger.MIN_VALUE = Integer.fromBits(0, 0x80000000 | 0, false);\n/**\n * Minimum safe value.\n * @type {!Integer}\n * @expose\n */\n\nInteger.MIN_SAFE_VALUE = Integer.fromBits(0x1 | 0, 0xffffffffffe00000 | 0);\n/**\n * Maximum safe value.\n * @type {!Integer}\n * @expose\n */\n\nInteger.MAX_SAFE_VALUE = Integer.fromBits(0xffffffff | 0, 0x1fffff | 0);\n/**\n * Cast value to Integer type.\n * @access public\n * @param {Mixed} value - The value to use.\n * @return {Integer} - An object of type Integer.\n */\n\nvar _int = Integer.fromValue;\n/**\n * Check if a variable is of Integer type.\n * @access public\n * @param {Mixed} value - The variable to check.\n * @return {Boolean} - Is it of the Integer type?\n */\n\nexports[\"int\"] = _int;\nvar isInt = Integer.isInteger;\n/**\n * Check if a variable can be safely converted to a number\n * @access public\n * @param {Mixed} value - The variable to check\n * @return {Boolean} - true if it is safe to call toNumber on variable otherwise false\n */\n\nexports.isInt = isInt;\nvar inSafeRange = Integer.inSafeRange;\n/**\n * Converts a variable to a number\n * @access public\n * @param {Mixed} value - The variable to convert\n * @return {number} - the variable as a number\n */\n\nexports.inSafeRange = inSafeRange;\nvar toNumber = Integer.toNumber;\n/**\n * Converts the integer to a string representation\n * @access public\n * @param {Mixed} value - The variable to convert\n * @param {number} radix - radix to use in string conversion, defaults to 10\n * @return {string} - returns a string representation of the integer\n */\n\nexports.toNumber = toNumber;\nvar toString = Integer.toString;\nexports.toString = toString;\nvar _default = Integer;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["d:/webback/pro5/node_modules/neo4j-driver/lib/integer.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","toString","toNumber","inSafeRange","isInt","_classCallCheck2","_createClass2","_error","Integer","low","high","key","greaterThanOrEqual","MIN_SAFE_VALUE","lessThanOrEqual","MAX_SAFE_VALUE","toInt","TWO_PWR_32_DBL","toNumberOrInfinity","lessThan","Number","NEGATIVE_INFINITY","greaterThan","POSITIVE_INFINITY","radix","RangeError","isZero","rem","isNegative","equals","MIN_VALUE","radixInteger","fromNumber","div","multiply","subtract","negate","radixToPower","Math","pow","result","remDiv","intval","digits","length","getHighBits","getLowBits","getNumBitsAbs","val","bit","isPositive","isOdd","isEven","other","isInteger","fromValue","notEquals","compare","thisNeg","otherNeg","not","add","ONE","addend","a48","a32","a16","a00","b48","b32","b16","b00","c48","c32","c16","c00","fromBits","subtrahend","multiplier","ZERO","TWO_PWR_24","divisor","newError","approx","res","NEG_ONE","halfThis","shiftRight","shiftLeft","max","floor","log2","ceil","log","LN2","delta","approxRes","approxRem","modulo","and","or","xor","numBits","__isInteger__","prototype","enumerable","configurable","obj","INT_CACHE","fromInt","cachedObj","isNaN","isFinite","TWO_PWR_63_DBL","MAX_VALUE","lowBits","highBits","fromString","str","p","indexOf","substring","i","size","min","parseInt","power","TWO_PWR_16_DBL","TWO_PWR_24_DBL","TWO_PWR_64_DBL","_int","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.toString = exports.toNumber = exports.inSafeRange = exports.isInt = exports[\"int\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _error = require(\"./error\");\n\n/**\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// 64-bit Integer library, originally from Long.js by dcodeIO\n// https://github.com/dcodeIO/Long.js\n// License Apache 2\n\n/**\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\n * See exported functions for more convenient ways of operating integers.\n * Use `int()` function to create new integers, `isInt()` to check if given object is integer,\n * `inSafeRange()` to check if it is safe to convert given value to native number,\n * `toNumber()` and `toString()` to convert given integer to number or string respectively.\n * @access public\n * @exports Integer\n * @class A Integer class for representing a 64 bit two's-complement integer value.\n * @param {number} low The low (signed) 32 bits of the long\n * @param {number} high The high (signed) 32 bits of the long\n * @constructor\n */\nvar Integer =\n/*#__PURE__*/\nfunction () {\n  function Integer(low, high) {\n    (0, _classCallCheck2[\"default\"])(this, Integer);\n\n    /**\n     * The low 32 bits as a signed value.\n     * @type {number}\n     * @expose\n     */\n    this.low = low | 0;\n    /**\n     * The high 32 bits as a signed value.\n     * @type {number}\n     * @expose\n     */\n\n    this.high = high | 0;\n  } // The internal representation of an Integer is the two given signed, 32-bit values.\n  // We use 32-bit pieces because these are the size of integers on which\n  // JavaScript performs bit-operations.  For operations like addition and\n  // multiplication, we split each number into 16 bit pieces, which can easily be\n  // multiplied within JavaScript's floating-point representation without overflow\n  // or change in sign.\n  //\n  // In the algorithms below, we frequently reduce the negative case to the\n  // positive case by negating the input(s) and then post-processing the result.\n  // Note that we must ALWAYS check specially whether those values are MIN_VALUE\n  // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n  // a positive number, it overflows back into a negative).  Not handling this\n  // case would often result in infinite recursion.\n  //\n  // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\n  // methods on which they depend.\n\n\n  (0, _createClass2[\"default\"])(Integer, [{\n    key: \"inSafeRange\",\n    value: function inSafeRange() {\n      return this.greaterThanOrEqual(Integer.MIN_SAFE_VALUE) && this.lessThanOrEqual(Integer.MAX_SAFE_VALUE);\n    }\n    /**\n     * Converts the Integer to an exact javascript Number, assuming it is a 32 bit integer.\n     * @returns {number}\n     * @expose\n     */\n\n  }, {\n    key: \"toInt\",\n    value: function toInt() {\n      return this.low;\n    }\n    /**\n     * Converts the Integer to a the nearest floating-point representation of this value (double, 53 bit mantissa).\n     * @returns {number}\n     * @expose\n     */\n\n  }, {\n    key: \"toNumber\",\n    value: function toNumber() {\n      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n    }\n    /**\n     * Converts the Integer to native number or -Infinity/+Infinity when it does not fit.\n     * @return {number}\n     * @package\n     */\n\n  }, {\n    key: \"toNumberOrInfinity\",\n    value: function toNumberOrInfinity() {\n      if (this.lessThan(Integer.MIN_SAFE_VALUE)) {\n        return Number.NEGATIVE_INFINITY;\n      } else if (this.greaterThan(Integer.MAX_SAFE_VALUE)) {\n        return Number.POSITIVE_INFINITY;\n      } else {\n        return this.toNumber();\n      }\n    }\n    /**\n     * Converts the Integer to a string written in the specified radix.\n     * @param {number=} radix Radix (2-36), defaults to 10\n     * @returns {string}\n     * @override\n     * @throws {RangeError} If `radix` is out of range\n     * @expose\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString(radix) {\n      radix = radix || 10;\n\n      if (radix < 2 || radix > 36) {\n        throw RangeError('radix out of range: ' + radix);\n      }\n\n      if (this.isZero()) {\n        return '0';\n      }\n\n      var rem;\n\n      if (this.isNegative()) {\n        if (this.equals(Integer.MIN_VALUE)) {\n          // We need to change the Integer value before it can be negated, so we remove\n          // the bottom-most digit in this base and then recurse to do the rest.\n          var radixInteger = Integer.fromNumber(radix);\n          var div = this.div(radixInteger);\n          rem = div.multiply(radixInteger).subtract(this);\n          return div.toString(radix) + rem.toInt().toString(radix);\n        } else {\n          return '-' + this.negate().toString(radix);\n        }\n      } // Do several (6) digits each time through the loop, so as to\n      // minimize the calls to the very expensive emulated div.\n\n\n      var radixToPower = Integer.fromNumber(Math.pow(radix, 6));\n      rem = this;\n      var result = '';\n\n      while (true) {\n        var remDiv = rem.div(radixToPower);\n        var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt() >>> 0;\n        var digits = intval.toString(radix);\n        rem = remDiv;\n\n        if (rem.isZero()) {\n          return digits + result;\n        } else {\n          while (digits.length < 6) {\n            digits = '0' + digits;\n          }\n\n          result = '' + digits + result;\n        }\n      }\n    }\n    /**\n     * Gets the high 32 bits as a signed integer.\n     * @returns {number} Signed high bits\n     * @expose\n     */\n\n  }, {\n    key: \"getHighBits\",\n    value: function getHighBits() {\n      return this.high;\n    }\n    /**\n     * Gets the low 32 bits as a signed integer.\n     * @returns {number} Signed low bits\n     * @expose\n     */\n\n  }, {\n    key: \"getLowBits\",\n    value: function getLowBits() {\n      return this.low;\n    }\n    /**\n     * Gets the number of bits needed to represent the absolute value of this Integer.\n     * @returns {number}\n     * @expose\n     */\n\n  }, {\n    key: \"getNumBitsAbs\",\n    value: function getNumBitsAbs() {\n      if (this.isNegative()) {\n        return this.equals(Integer.MIN_VALUE) ? 64 : this.negate().getNumBitsAbs();\n      }\n\n      var val = this.high !== 0 ? this.high : this.low;\n\n      for (var bit = 31; bit > 0; bit--) {\n        if ((val & 1 << bit) !== 0) {\n          break;\n        }\n      }\n\n      return this.high !== 0 ? bit + 33 : bit + 1;\n    }\n    /**\n     * Tests if this Integer's value equals zero.\n     * @returns {boolean}\n     * @expose\n     */\n\n  }, {\n    key: \"isZero\",\n    value: function isZero() {\n      return this.high === 0 && this.low === 0;\n    }\n    /**\n     * Tests if this Integer's value is negative.\n     * @returns {boolean}\n     * @expose\n     */\n\n  }, {\n    key: \"isNegative\",\n    value: function isNegative() {\n      return this.high < 0;\n    }\n    /**\n     * Tests if this Integer's value is positive.\n     * @returns {boolean}\n     * @expose\n     */\n\n  }, {\n    key: \"isPositive\",\n    value: function isPositive() {\n      return this.high >= 0;\n    }\n    /**\n     * Tests if this Integer's value is odd.\n     * @returns {boolean}\n     * @expose\n     */\n\n  }, {\n    key: \"isOdd\",\n    value: function isOdd() {\n      return (this.low & 1) === 1;\n    }\n    /**\n     * Tests if this Integer's value is even.\n     * @returns {boolean}\n     * @expose\n     */\n\n  }, {\n    key: \"isEven\",\n    value: function isEven() {\n      return (this.low & 1) === 0;\n    }\n    /**\n     * Tests if this Integer's value equals the specified's.\n     * @param {!Integer|number|string} other Other value\n     * @returns {boolean}\n     * @expose\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (!Integer.isInteger(other)) {\n        other = Integer.fromValue(other);\n      }\n\n      return this.high === other.high && this.low === other.low;\n    }\n    /**\n     * Tests if this Integer's value differs from the specified's.\n     * @param {!Integer|number|string} other Other value\n     * @returns {boolean}\n     * @expose\n     */\n\n  }, {\n    key: \"notEquals\",\n    value: function notEquals(other) {\n      return !this.equals(\n      /* validates */\n      other);\n    }\n    /**\n     * Tests if this Integer's value is less than the specified's.\n     * @param {!Integer|number|string} other Other value\n     * @returns {boolean}\n     * @expose\n     */\n\n  }, {\n    key: \"lessThan\",\n    value: function lessThan(other) {\n      return this.compare(\n      /* validates */\n      other) < 0;\n    }\n    /**\n     * Tests if this Integer's value is less than or equal the specified's.\n     * @param {!Integer|number|string} other Other value\n     * @returns {boolean}\n     * @expose\n     */\n\n  }, {\n    key: \"lessThanOrEqual\",\n    value: function lessThanOrEqual(other) {\n      return this.compare(\n      /* validates */\n      other) <= 0;\n    }\n    /**\n     * Tests if this Integer's value is greater than the specified's.\n     * @param {!Integer|number|string} other Other value\n     * @returns {boolean}\n     * @expose\n     */\n\n  }, {\n    key: \"greaterThan\",\n    value: function greaterThan(other) {\n      return this.compare(\n      /* validates */\n      other) > 0;\n    }\n    /**\n     * Tests if this Integer's value is greater than or equal the specified's.\n     * @param {!Integer|number|string} other Other value\n     * @returns {boolean}\n     * @expose\n     */\n\n  }, {\n    key: \"greaterThanOrEqual\",\n    value: function greaterThanOrEqual(other) {\n      return this.compare(\n      /* validates */\n      other) >= 0;\n    }\n    /**\n     * Compares this Integer's value with the specified's.\n     * @param {!Integer|number|string} other Other value\n     * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n     *  if the given one is greater\n     * @expose\n     */\n\n  }, {\n    key: \"compare\",\n    value: function compare(other) {\n      if (!Integer.isInteger(other)) {\n        other = Integer.fromValue(other);\n      }\n\n      if (this.equals(other)) {\n        return 0;\n      }\n\n      var thisNeg = this.isNegative();\n      var otherNeg = other.isNegative();\n\n      if (thisNeg && !otherNeg) {\n        return -1;\n      }\n\n      if (!thisNeg && otherNeg) {\n        return 1;\n      } // At this point the sign bits are the same\n\n\n      return this.subtract(other).isNegative() ? -1 : 1;\n    }\n    /**\n     * Negates this Integer's value.\n     * @returns {!Integer} Negated Integer\n     * @expose\n     */\n\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      if (this.equals(Integer.MIN_VALUE)) {\n        return Integer.MIN_VALUE;\n      }\n\n      return this.not().add(Integer.ONE);\n    }\n    /**\n     * Returns the sum of this and the specified Integer.\n     * @param {!Integer|number|string} addend Addend\n     * @returns {!Integer} Sum\n     * @expose\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(addend) {\n      if (!Integer.isInteger(addend)) {\n        addend = Integer.fromValue(addend);\n      } // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n\n\n      var a48 = this.high >>> 16;\n      var a32 = this.high & 0xffff;\n      var a16 = this.low >>> 16;\n      var a00 = this.low & 0xffff;\n      var b48 = addend.high >>> 16;\n      var b32 = addend.high & 0xffff;\n      var b16 = addend.low >>> 16;\n      var b00 = addend.low & 0xffff;\n      var c48 = 0;\n      var c32 = 0;\n      var c16 = 0;\n      var c00 = 0;\n      c00 += a00 + b00;\n      c16 += c00 >>> 16;\n      c00 &= 0xffff;\n      c16 += a16 + b16;\n      c32 += c16 >>> 16;\n      c16 &= 0xffff;\n      c32 += a32 + b32;\n      c48 += c32 >>> 16;\n      c32 &= 0xffff;\n      c48 += a48 + b48;\n      c48 &= 0xffff;\n      return Integer.fromBits(c16 << 16 | c00, c48 << 16 | c32);\n    }\n    /**\n     * Returns the difference of this and the specified Integer.\n     * @param {!Integer|number|string} subtrahend Subtrahend\n     * @returns {!Integer} Difference\n     * @expose\n     */\n\n  }, {\n    key: \"subtract\",\n    value: function subtract(subtrahend) {\n      if (!Integer.isInteger(subtrahend)) {\n        subtrahend = Integer.fromValue(subtrahend);\n      }\n\n      return this.add(subtrahend.negate());\n    }\n    /**\n     * Returns the product of this and the specified Integer.\n     * @param {!Integer|number|string} multiplier Multiplier\n     * @returns {!Integer} Product\n     * @expose\n     */\n\n  }, {\n    key: \"multiply\",\n    value: function multiply(multiplier) {\n      if (this.isZero()) {\n        return Integer.ZERO;\n      }\n\n      if (!Integer.isInteger(multiplier)) {\n        multiplier = Integer.fromValue(multiplier);\n      }\n\n      if (multiplier.isZero()) {\n        return Integer.ZERO;\n      }\n\n      if (this.equals(Integer.MIN_VALUE)) {\n        return multiplier.isOdd() ? Integer.MIN_VALUE : Integer.ZERO;\n      }\n\n      if (multiplier.equals(Integer.MIN_VALUE)) {\n        return this.isOdd() ? Integer.MIN_VALUE : Integer.ZERO;\n      }\n\n      if (this.isNegative()) {\n        if (multiplier.isNegative()) {\n          return this.negate().multiply(multiplier.negate());\n        } else {\n          return this.negate().multiply(multiplier).negate();\n        }\n      } else if (multiplier.isNegative()) {\n        return this.multiply(multiplier.negate()).negate();\n      } // If both longs are small, use float multiplication\n\n\n      if (this.lessThan(TWO_PWR_24) && multiplier.lessThan(TWO_PWR_24)) {\n        return Integer.fromNumber(this.toNumber() * multiplier.toNumber());\n      } // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n      // We can skip products that would overflow.\n\n\n      var a48 = this.high >>> 16;\n      var a32 = this.high & 0xffff;\n      var a16 = this.low >>> 16;\n      var a00 = this.low & 0xffff;\n      var b48 = multiplier.high >>> 16;\n      var b32 = multiplier.high & 0xffff;\n      var b16 = multiplier.low >>> 16;\n      var b00 = multiplier.low & 0xffff;\n      var c48 = 0;\n      var c32 = 0;\n      var c16 = 0;\n      var c00 = 0;\n      c00 += a00 * b00;\n      c16 += c00 >>> 16;\n      c00 &= 0xffff;\n      c16 += a16 * b00;\n      c32 += c16 >>> 16;\n      c16 &= 0xffff;\n      c16 += a00 * b16;\n      c32 += c16 >>> 16;\n      c16 &= 0xffff;\n      c32 += a32 * b00;\n      c48 += c32 >>> 16;\n      c32 &= 0xffff;\n      c32 += a16 * b16;\n      c48 += c32 >>> 16;\n      c32 &= 0xffff;\n      c32 += a00 * b32;\n      c48 += c32 >>> 16;\n      c32 &= 0xffff;\n      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n      c48 &= 0xffff;\n      return Integer.fromBits(c16 << 16 | c00, c48 << 16 | c32);\n    }\n    /**\n     * Returns this Integer divided by the specified.\n     * @param {!Integer|number|string} divisor Divisor\n     * @returns {!Integer} Quotient\n     * @expose\n     */\n\n  }, {\n    key: \"div\",\n    value: function div(divisor) {\n      if (!Integer.isInteger(divisor)) {\n        divisor = Integer.fromValue(divisor);\n      }\n\n      if (divisor.isZero()) {\n        throw (0, _error.newError)('division by zero');\n      }\n\n      if (this.isZero()) {\n        return Integer.ZERO;\n      }\n\n      var approx, rem, res;\n\n      if (this.equals(Integer.MIN_VALUE)) {\n        if (divisor.equals(Integer.ONE) || divisor.equals(Integer.NEG_ONE)) {\n          return Integer.MIN_VALUE;\n        }\n\n        if (divisor.equals(Integer.MIN_VALUE)) {\n          return Integer.ONE;\n        } else {\n          // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n          var halfThis = this.shiftRight(1);\n          approx = halfThis.div(divisor).shiftLeft(1);\n\n          if (approx.equals(Integer.ZERO)) {\n            return divisor.isNegative() ? Integer.ONE : Integer.NEG_ONE;\n          } else {\n            rem = this.subtract(divisor.multiply(approx));\n            res = approx.add(rem.div(divisor));\n            return res;\n          }\n        }\n      } else if (divisor.equals(Integer.MIN_VALUE)) {\n        return Integer.ZERO;\n      }\n\n      if (this.isNegative()) {\n        if (divisor.isNegative()) {\n          return this.negate().div(divisor.negate());\n        }\n\n        return this.negate().div(divisor).negate();\n      } else if (divisor.isNegative()) {\n        return this.div(divisor.negate()).negate();\n      } // Repeat the following until the remainder is less than other:  find a\n      // floating-point that approximates remainder / other *from below*, add this\n      // into the result, and subtract it from the remainder.  It is critical that\n      // the approximate value is less than or equal to the real value so that the\n      // remainder never becomes negative.\n\n\n      res = Integer.ZERO;\n      rem = this;\n\n      while (rem.greaterThanOrEqual(divisor)) {\n        // Approximate the result of division. This may be a little greater or\n        // smaller than the actual value.\n        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber())); // We will tweak the approximate result by changing it in the 48-th digit or\n        // the smallest non-fractional digit, whichever is larger.\n\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2);\n        var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48); // Decrease the approximation until it is smaller than the remainder.  Note\n        // that if it is too large, the product overflows and is negative.\n\n        var approxRes = Integer.fromNumber(approx);\n        var approxRem = approxRes.multiply(divisor);\n\n        while (approxRem.isNegative() || approxRem.greaterThan(rem)) {\n          approx -= delta;\n          approxRes = Integer.fromNumber(approx);\n          approxRem = approxRes.multiply(divisor);\n        } // We know the answer can't be zero... and actually, zero would cause\n        // infinite recursion since we would make no progress.\n\n\n        if (approxRes.isZero()) {\n          approxRes = Integer.ONE;\n        }\n\n        res = res.add(approxRes);\n        rem = rem.subtract(approxRem);\n      }\n\n      return res;\n    }\n    /**\n     * Returns this Integer modulo the specified.\n     * @param {!Integer|number|string} divisor Divisor\n     * @returns {!Integer} Remainder\n     * @expose\n     */\n\n  }, {\n    key: \"modulo\",\n    value: function modulo(divisor) {\n      if (!Integer.isInteger(divisor)) {\n        divisor = Integer.fromValue(divisor);\n      }\n\n      return this.subtract(this.div(divisor).multiply(divisor));\n    }\n    /**\n     * Returns the bitwise NOT of this Integer.\n     * @returns {!Integer}\n     * @expose\n     */\n\n  }, {\n    key: \"not\",\n    value: function not() {\n      return Integer.fromBits(~this.low, ~this.high);\n    }\n    /**\n     * Returns the bitwise AND of this Integer and the specified.\n     * @param {!Integer|number|string} other Other Integer\n     * @returns {!Integer}\n     * @expose\n     */\n\n  }, {\n    key: \"and\",\n    value: function and(other) {\n      if (!Integer.isInteger(other)) {\n        other = Integer.fromValue(other);\n      }\n\n      return Integer.fromBits(this.low & other.low, this.high & other.high);\n    }\n    /**\n     * Returns the bitwise OR of this Integer and the specified.\n     * @param {!Integer|number|string} other Other Integer\n     * @returns {!Integer}\n     * @expose\n     */\n\n  }, {\n    key: \"or\",\n    value: function or(other) {\n      if (!Integer.isInteger(other)) {\n        other = Integer.fromValue(other);\n      }\n\n      return Integer.fromBits(this.low | other.low, this.high | other.high);\n    }\n    /**\n     * Returns the bitwise XOR of this Integer and the given one.\n     * @param {!Integer|number|string} other Other Integer\n     * @returns {!Integer}\n     * @expose\n     */\n\n  }, {\n    key: \"xor\",\n    value: function xor(other) {\n      if (!Integer.isInteger(other)) {\n        other = Integer.fromValue(other);\n      }\n\n      return Integer.fromBits(this.low ^ other.low, this.high ^ other.high);\n    }\n    /**\n     * Returns this Integer with bits shifted to the left by the given amount.\n     * @param {number|!Integer} numBits Number of bits\n     * @returns {!Integer} Shifted Integer\n     * @expose\n     */\n\n  }, {\n    key: \"shiftLeft\",\n    value: function shiftLeft(numBits) {\n      if (Integer.isInteger(numBits)) {\n        numBits = numBits.toInt();\n      }\n\n      if ((numBits &= 63) === 0) {\n        return this;\n      } else if (numBits < 32) {\n        return Integer.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits);\n      } else {\n        return Integer.fromBits(0, this.low << numBits - 32);\n      }\n    }\n    /**\n     * Returns this Integer with bits arithmetically shifted to the right by the given amount.\n     * @param {number|!Integer} numBits Number of bits\n     * @returns {!Integer} Shifted Integer\n     * @expose\n     */\n\n  }, {\n    key: \"shiftRight\",\n    value: function shiftRight(numBits) {\n      if (Integer.isInteger(numBits)) {\n        numBits = numBits.toInt();\n      }\n\n      if ((numBits &= 63) === 0) {\n        return this;\n      } else if (numBits < 32) {\n        return Integer.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits);\n      } else {\n        return Integer.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1);\n      }\n    }\n  }]);\n  return Integer;\n}();\n/**\n * An indicator used to reliably determine if an object is a Integer or not.\n * @type {boolean}\n * @const\n * @expose\n * @private\n */\n\n\nInteger.__isInteger__ = true;\nObject.defineProperty(Integer.prototype, '__isInteger__', {\n  value: true,\n  enumerable: false,\n  configurable: false\n});\n/**\n * Tests if the specified object is a Integer.\n * @access private\n * @param {*} obj Object\n * @returns {boolean}\n * @expose\n */\n\nInteger.isInteger = function (obj) {\n  return (obj && obj.__isInteger__) === true;\n};\n/**\n * A cache of the Integer representations of small integer values.\n * @type {!Object}\n * @inner\n * @private\n */\n\n\nvar INT_CACHE = {};\n/**\n * Returns a Integer representing the given 32 bit integer value.\n * @access private\n * @param {number} value The 32 bit integer in question\n * @returns {!Integer} The corresponding Integer value\n * @expose\n */\n\nInteger.fromInt = function (value) {\n  var obj, cachedObj;\n  value = value | 0;\n\n  if (value >= -128 && value < 128) {\n    cachedObj = INT_CACHE[value];\n\n    if (cachedObj) {\n      return cachedObj;\n    }\n  }\n\n  obj = new Integer(value, value < 0 ? -1 : 0, false);\n\n  if (value >= -128 && value < 128) {\n    INT_CACHE[value] = obj;\n  }\n\n  return obj;\n};\n/**\n * Returns a Integer representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n * @access private\n * @param {number} value The number in question\n * @returns {!Integer} The corresponding Integer value\n * @expose\n */\n\n\nInteger.fromNumber = function (value) {\n  if (isNaN(value) || !isFinite(value)) {\n    return Integer.ZERO;\n  }\n\n  if (value <= -TWO_PWR_63_DBL) {\n    return Integer.MIN_VALUE;\n  }\n\n  if (value + 1 >= TWO_PWR_63_DBL) {\n    return Integer.MAX_VALUE;\n  }\n\n  if (value < 0) {\n    return Integer.fromNumber(-value).negate();\n  }\n\n  return new Integer(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0);\n};\n/**\n * Returns a Integer representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\n *  assumed to use 32 bits.\n * @access private\n * @param {number} lowBits The low 32 bits\n * @param {number} highBits The high 32 bits\n * @returns {!Integer} The corresponding Integer value\n * @expose\n */\n\n\nInteger.fromBits = function (lowBits, highBits) {\n  return new Integer(lowBits, highBits);\n};\n/**\n * Returns a Integer representation of the given string, written using the specified radix.\n * @access private\n * @param {string} str The textual representation of the Integer\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\n * @returns {!Integer} The corresponding Integer value\n * @expose\n */\n\n\nInteger.fromString = function (str, radix) {\n  if (str.length === 0) {\n    throw (0, _error.newError)('number format error: empty string');\n  }\n\n  if (str === 'NaN' || str === 'Infinity' || str === '+Infinity' || str === '-Infinity') {\n    return Integer.ZERO;\n  }\n\n  radix = radix || 10;\n\n  if (radix < 2 || radix > 36) {\n    throw (0, _error.newError)('radix out of range: ' + radix);\n  }\n\n  var p;\n\n  if ((p = str.indexOf('-')) > 0) {\n    throw (0, _error.newError)('number format error: interior \"-\" character: ' + str);\n  } else if (p === 0) {\n    return Integer.fromString(str.substring(1), radix).negate();\n  } // Do several (8) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n\n\n  var radixToPower = Integer.fromNumber(Math.pow(radix, 8));\n  var result = Integer.ZERO;\n\n  for (var i = 0; i < str.length; i += 8) {\n    var size = Math.min(8, str.length - i);\n    var value = parseInt(str.substring(i, i + size), radix);\n\n    if (size < 8) {\n      var power = Integer.fromNumber(Math.pow(radix, size));\n      result = result.multiply(power).add(Integer.fromNumber(value));\n    } else {\n      result = result.multiply(radixToPower);\n      result = result.add(Integer.fromNumber(value));\n    }\n  }\n\n  return result;\n};\n/**\n * Converts the specified value to a Integer.\n * @access private\n * @param {!Integer|number|string|!{low: number, high: number}} val Value\n * @returns {!Integer}\n * @expose\n */\n\n\nInteger.fromValue = function (val) {\n  if (val\n  /* is compatible */\n  instanceof Integer) {\n    return val;\n  }\n\n  if (typeof val === 'number') {\n    return Integer.fromNumber(val);\n  }\n\n  if (typeof val === 'string') {\n    return Integer.fromString(val);\n  } // Throws for non-objects, converts non-instanceof Integer:\n\n\n  return new Integer(val.low, val.high);\n};\n/**\n * Converts the specified value to a number.\n * @access private\n * @param {!Integer|number|string|!{low: number, high: number}} val Value\n * @returns {number}\n * @expose\n */\n\n\nInteger.toNumber = function (val) {\n  return Integer.fromValue(val).toNumber();\n};\n/**\n * Converts the specified value to a string.\n * @access private\n * @param {!Integer|number|string|!{low: number, high: number}} val Value\n * @param {number} radix optional radix for string conversion, defaults to 10\n * @returns {string}\n * @expose\n */\n\n\nInteger.toString = function (val, radix) {\n  return Integer.fromValue(val).toString(radix);\n};\n/**\n * Checks if the given value is in the safe range in order to be converted to a native number\n * @access private\n * @param {!Integer|number|string|!{low: number, high: number}} val Value\n * @param {number} radix optional radix for string conversion, defaults to 10\n * @returns {boolean}\n * @expose\n */\n\n\nInteger.inSafeRange = function (val) {\n  return Integer.fromValue(val).inSafeRange();\n};\n/**\n * @type {number}\n * @const\n * @inner\n * @private\n */\n\n\nvar TWO_PWR_16_DBL = 1 << 16;\n/**\n * @type {number}\n * @const\n * @inner\n * @private\n */\n\nvar TWO_PWR_24_DBL = 1 << 24;\n/**\n * @type {number}\n * @const\n * @inner\n * @private\n */\n\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n/**\n * @type {number}\n * @const\n * @inner\n * @private\n */\n\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n/**\n * @type {number}\n * @const\n * @inner\n * @private\n */\n\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n/**\n * @type {!Integer}\n * @const\n * @inner\n * @private\n */\n\nvar TWO_PWR_24 = Integer.fromInt(TWO_PWR_24_DBL);\n/**\n * Signed zero.\n * @type {!Integer}\n * @expose\n */\n\nInteger.ZERO = Integer.fromInt(0);\n/**\n * Signed one.\n * @type {!Integer}\n * @expose\n */\n\nInteger.ONE = Integer.fromInt(1);\n/**\n * Signed negative one.\n * @type {!Integer}\n * @expose\n */\n\nInteger.NEG_ONE = Integer.fromInt(-1);\n/**\n * Maximum signed value.\n * @type {!Integer}\n * @expose\n */\n\nInteger.MAX_VALUE = Integer.fromBits(0xffffffff | 0, 0x7fffffff | 0, false);\n/**\n * Minimum signed value.\n * @type {!Integer}\n * @expose\n */\n\nInteger.MIN_VALUE = Integer.fromBits(0, 0x80000000 | 0, false);\n/**\n * Minimum safe value.\n * @type {!Integer}\n * @expose\n */\n\nInteger.MIN_SAFE_VALUE = Integer.fromBits(0x1 | 0, 0xffffffffffe00000 | 0);\n/**\n * Maximum safe value.\n * @type {!Integer}\n * @expose\n */\n\nInteger.MAX_SAFE_VALUE = Integer.fromBits(0xffffffff | 0, 0x1fffff | 0);\n/**\n * Cast value to Integer type.\n * @access public\n * @param {Mixed} value - The value to use.\n * @return {Integer} - An object of type Integer.\n */\n\nvar _int = Integer.fromValue;\n/**\n * Check if a variable is of Integer type.\n * @access public\n * @param {Mixed} value - The variable to check.\n * @return {Boolean} - Is it of the Integer type?\n */\n\nexports[\"int\"] = _int;\nvar isInt = Integer.isInteger;\n/**\n * Check if a variable can be safely converted to a number\n * @access public\n * @param {Mixed} value - The variable to check\n * @return {Boolean} - true if it is safe to call toNumber on variable otherwise false\n */\n\nexports.isInt = isInt;\nvar inSafeRange = Integer.inSafeRange;\n/**\n * Converts a variable to a number\n * @access public\n * @param {Mixed} value - The variable to convert\n * @return {number} - the variable as a number\n */\n\nexports.inSafeRange = inSafeRange;\nvar toNumber = Integer.toNumber;\n/**\n * Converts the integer to a string representation\n * @access public\n * @param {Mixed} value - The variable to convert\n * @param {number} radix - radix to use in string conversion, defaults to 10\n * @return {string} - returns a string representation of the integer\n */\n\nexports.toNumber = toNumber;\nvar toString = Integer.toString;\nexports.toString = toString;\nvar _default = Integer;\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}