{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _error = require(\"../error\");\n\nvar _integer = _interopRequireWildcard(require(\"../integer\"));\n\nvar _serverVersion = require(\"./server-version\");\n\nvar _bookmark = _interopRequireDefault(require(\"./bookmark\"));\n\nvar _session = _interopRequireDefault(require(\"../session\"));\n\nvar _txConfig = _interopRequireDefault(require(\"./tx-config\"));\n\nvar _serverAddress = _interopRequireDefault(require(\"./server-address\"));\n/**\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar CONTEXT = 'context';\nvar CALL_GET_ROUTING_TABLE = \"CALL dbms.cluster.routing.getRoutingTable($\".concat(CONTEXT, \")\");\nvar DATABASE = 'database';\nvar CALL_GET_ROUTING_TABLE_MULTI_DB = \"CALL dbms.routing.getRoutingTable($\".concat(CONTEXT, \", $\").concat(DATABASE, \")\");\nvar PROCEDURE_NOT_FOUND_CODE = 'Neo.ClientError.Procedure.ProcedureNotFound';\nvar DATABASE_NOT_FOUND_CODE = 'Neo.ClientError.Database.DatabaseNotFound';\n\nvar RoutingUtil = /*#__PURE__*/function () {\n  function RoutingUtil(routingContext) {\n    (0, _classCallCheck2[\"default\"])(this, RoutingUtil);\n    this._routingContext = routingContext;\n  }\n  /**\n   * Invoke routing procedure using the given session.\n   * @param {Session} session the session to use.\n   * @param {string} routerAddress the URL of the router.\n   * @return {Promise<Record[]>} promise resolved with records returned by the procedure call or null if\n   * connection error happened.\n   */\n\n\n  (0, _createClass2[\"default\"])(RoutingUtil, [{\n    key: \"callRoutingProcedure\",\n    value: function () {\n      var _callRoutingProcedure = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(session, database, routerAddress) {\n        var result;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return this._callAvailableRoutingProcedure(session, database);\n\n              case 3:\n                result = _context.sent;\n                _context.next = 6;\n                return session.close();\n\n              case 6:\n                return _context.abrupt(\"return\", result.records);\n\n              case 9:\n                _context.prev = 9;\n                _context.t0 = _context[\"catch\"](0);\n\n                if (!(_context.t0.code === DATABASE_NOT_FOUND_CODE)) {\n                  _context.next = 15;\n                  break;\n                }\n\n                throw _context.t0;\n\n              case 15:\n                if (!(_context.t0.code === PROCEDURE_NOT_FOUND_CODE)) {\n                  _context.next = 19;\n                  break;\n                }\n\n                throw (0, _error.newError)(\"Server at \".concat(routerAddress.asHostPort(), \" can't perform routing. Make sure you are connecting to a causal cluster\"), _error.SERVICE_UNAVAILABLE);\n\n              case 19:\n                return _context.abrupt(\"return\", null);\n\n              case 20:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 9]]);\n      }));\n\n      function callRoutingProcedure(_x, _x2, _x3) {\n        return _callRoutingProcedure.apply(this, arguments);\n      }\n\n      return callRoutingProcedure;\n    }()\n  }, {\n    key: \"parseTtl\",\n    value: function parseTtl(record, routerAddress) {\n      try {\n        var now = (0, _integer[\"int\"])(Date.now());\n        var expires = (0, _integer[\"int\"])(record.get('ttl')).multiply(1000).add(now); // if the server uses a really big expire time like Long.MAX_VALUE this may have overflowed\n\n        if (expires.lessThan(now)) {\n          return _integer[\"default\"].MAX_VALUE;\n        }\n\n        return expires;\n      } catch (error) {\n        throw (0, _error.newError)(\"Unable to parse TTL entry from router \".concat(routerAddress, \" from record:\\n\").concat(JSON.stringify(record), \"\\nError message: \").concat(error.message), _error.PROTOCOL_ERROR);\n      }\n    }\n  }, {\n    key: \"parseServers\",\n    value: function parseServers(record, routerAddress) {\n      try {\n        var servers = record.get('servers');\n        var routers = [];\n        var readers = [];\n        var writers = [];\n        servers.forEach(function (server) {\n          var role = server.role;\n          var addresses = server.addresses;\n\n          if (role === 'ROUTE') {\n            routers = parseArray(addresses).map(function (address) {\n              return _serverAddress[\"default\"].fromUrl(address);\n            });\n          } else if (role === 'WRITE') {\n            writers = parseArray(addresses).map(function (address) {\n              return _serverAddress[\"default\"].fromUrl(address);\n            });\n          } else if (role === 'READ') {\n            readers = parseArray(addresses).map(function (address) {\n              return _serverAddress[\"default\"].fromUrl(address);\n            });\n          } else {\n            throw (0, _error.newError)('Unknown server role \"' + role + '\"', _error.PROTOCOL_ERROR);\n          }\n        });\n        return {\n          routers: routers,\n          readers: readers,\n          writers: writers\n        };\n      } catch (error) {\n        throw (0, _error.newError)(\"Unable to parse servers entry from router \".concat(routerAddress, \" from record:\\n\").concat(JSON.stringify(record), \"\\nError message: \").concat(error.message), _error.PROTOCOL_ERROR);\n      }\n    }\n  }, {\n    key: \"_callAvailableRoutingProcedure\",\n    value: function _callAvailableRoutingProcedure(session, database) {\n      var _this = this;\n\n      return session._run(null, null, function (connection) {\n        var query;\n        var params;\n\n        var version = _serverVersion.ServerVersion.fromString(connection.version);\n\n        if (version.compareTo(_serverVersion.VERSION_4_0_0) >= 0) {\n          query = CALL_GET_ROUTING_TABLE_MULTI_DB;\n          params = {\n            context: _this._routingContext,\n            database: database || null\n          };\n        } else {\n          query = CALL_GET_ROUTING_TABLE;\n          params = {\n            context: _this._routingContext\n          };\n        }\n\n        return connection.protocol().run(query, params, {\n          bookmark: session._lastBookmark,\n          txConfig: _txConfig[\"default\"].empty(),\n          mode: session._mode,\n          database: session._database,\n          afterComplete: session._onComplete\n        });\n      });\n    }\n  }]);\n  return RoutingUtil;\n}();\n\nexports[\"default\"] = RoutingUtil;\n\nfunction parseArray(addresses) {\n  if (!Array.isArray(addresses)) {\n    throw new TypeError('Array expected but got: ' + addresses);\n  }\n\n  return Array.from(addresses);\n}","map":{"version":3,"sources":["d:/webback/pro5/node_modules/neo4j-driver/lib/internal/routing-util.js"],"names":["_interopRequireWildcard","require","_interopRequireDefault","Object","defineProperty","exports","value","_regenerator","_asyncToGenerator2","_classCallCheck2","_createClass2","_error","_integer","_serverVersion","_bookmark","_session","_txConfig","_serverAddress","CONTEXT","CALL_GET_ROUTING_TABLE","concat","DATABASE","CALL_GET_ROUTING_TABLE_MULTI_DB","PROCEDURE_NOT_FOUND_CODE","DATABASE_NOT_FOUND_CODE","RoutingUtil","routingContext","_routingContext","key","_callRoutingProcedure","mark","_callee","session","database","routerAddress","result","wrap","_callee$","_context","prev","next","_callAvailableRoutingProcedure","sent","close","abrupt","records","t0","code","newError","asHostPort","SERVICE_UNAVAILABLE","stop","callRoutingProcedure","_x","_x2","_x3","apply","arguments","parseTtl","record","now","Date","expires","get","multiply","add","lessThan","MAX_VALUE","error","JSON","stringify","message","PROTOCOL_ERROR","parseServers","servers","routers","readers","writers","forEach","server","role","addresses","parseArray","map","address","fromUrl","_this","_run","connection","query","params","version","ServerVersion","fromString","compareTo","VERSION_4_0_0","context","protocol","run","bookmark","_lastBookmark","txConfig","empty","mode","_mode","_database","afterComplete","_onComplete","Array","isArray","TypeError","from"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _error = require(\"../error\");\n\nvar _integer = _interopRequireWildcard(require(\"../integer\"));\n\nvar _serverVersion = require(\"./server-version\");\n\nvar _bookmark = _interopRequireDefault(require(\"./bookmark\"));\n\nvar _session = _interopRequireDefault(require(\"../session\"));\n\nvar _txConfig = _interopRequireDefault(require(\"./tx-config\"));\n\nvar _serverAddress = _interopRequireDefault(require(\"./server-address\"));\n\n/**\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar CONTEXT = 'context';\nvar CALL_GET_ROUTING_TABLE = \"CALL dbms.cluster.routing.getRoutingTable($\".concat(CONTEXT, \")\");\nvar DATABASE = 'database';\nvar CALL_GET_ROUTING_TABLE_MULTI_DB = \"CALL dbms.routing.getRoutingTable($\".concat(CONTEXT, \", $\").concat(DATABASE, \")\");\nvar PROCEDURE_NOT_FOUND_CODE = 'Neo.ClientError.Procedure.ProcedureNotFound';\nvar DATABASE_NOT_FOUND_CODE = 'Neo.ClientError.Database.DatabaseNotFound';\n\nvar RoutingUtil =\n/*#__PURE__*/\nfunction () {\n  function RoutingUtil(routingContext) {\n    (0, _classCallCheck2[\"default\"])(this, RoutingUtil);\n    this._routingContext = routingContext;\n  }\n  /**\n   * Invoke routing procedure using the given session.\n   * @param {Session} session the session to use.\n   * @param {string} routerAddress the URL of the router.\n   * @return {Promise<Record[]>} promise resolved with records returned by the procedure call or null if\n   * connection error happened.\n   */\n\n\n  (0, _createClass2[\"default\"])(RoutingUtil, [{\n    key: \"callRoutingProcedure\",\n    value: function () {\n      var _callRoutingProcedure = (0, _asyncToGenerator2[\"default\"])(\n      /*#__PURE__*/\n      _regenerator[\"default\"].mark(function _callee(session, database, routerAddress) {\n        var result;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return this._callAvailableRoutingProcedure(session, database);\n\n              case 3:\n                result = _context.sent;\n                _context.next = 6;\n                return session.close();\n\n              case 6:\n                return _context.abrupt(\"return\", result.records);\n\n              case 9:\n                _context.prev = 9;\n                _context.t0 = _context[\"catch\"](0);\n\n                if (!(_context.t0.code === DATABASE_NOT_FOUND_CODE)) {\n                  _context.next = 15;\n                  break;\n                }\n\n                throw _context.t0;\n\n              case 15:\n                if (!(_context.t0.code === PROCEDURE_NOT_FOUND_CODE)) {\n                  _context.next = 19;\n                  break;\n                }\n\n                throw (0, _error.newError)(\"Server at \".concat(routerAddress.asHostPort(), \" can't perform routing. Make sure you are connecting to a causal cluster\"), _error.SERVICE_UNAVAILABLE);\n\n              case 19:\n                return _context.abrupt(\"return\", null);\n\n              case 20:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 9]]);\n      }));\n\n      function callRoutingProcedure(_x, _x2, _x3) {\n        return _callRoutingProcedure.apply(this, arguments);\n      }\n\n      return callRoutingProcedure;\n    }()\n  }, {\n    key: \"parseTtl\",\n    value: function parseTtl(record, routerAddress) {\n      try {\n        var now = (0, _integer[\"int\"])(Date.now());\n        var expires = (0, _integer[\"int\"])(record.get('ttl')).multiply(1000).add(now); // if the server uses a really big expire time like Long.MAX_VALUE this may have overflowed\n\n        if (expires.lessThan(now)) {\n          return _integer[\"default\"].MAX_VALUE;\n        }\n\n        return expires;\n      } catch (error) {\n        throw (0, _error.newError)(\"Unable to parse TTL entry from router \".concat(routerAddress, \" from record:\\n\").concat(JSON.stringify(record), \"\\nError message: \").concat(error.message), _error.PROTOCOL_ERROR);\n      }\n    }\n  }, {\n    key: \"parseServers\",\n    value: function parseServers(record, routerAddress) {\n      try {\n        var servers = record.get('servers');\n        var routers = [];\n        var readers = [];\n        var writers = [];\n        servers.forEach(function (server) {\n          var role = server.role;\n          var addresses = server.addresses;\n\n          if (role === 'ROUTE') {\n            routers = parseArray(addresses).map(function (address) {\n              return _serverAddress[\"default\"].fromUrl(address);\n            });\n          } else if (role === 'WRITE') {\n            writers = parseArray(addresses).map(function (address) {\n              return _serverAddress[\"default\"].fromUrl(address);\n            });\n          } else if (role === 'READ') {\n            readers = parseArray(addresses).map(function (address) {\n              return _serverAddress[\"default\"].fromUrl(address);\n            });\n          } else {\n            throw (0, _error.newError)('Unknown server role \"' + role + '\"', _error.PROTOCOL_ERROR);\n          }\n        });\n        return {\n          routers: routers,\n          readers: readers,\n          writers: writers\n        };\n      } catch (error) {\n        throw (0, _error.newError)(\"Unable to parse servers entry from router \".concat(routerAddress, \" from record:\\n\").concat(JSON.stringify(record), \"\\nError message: \").concat(error.message), _error.PROTOCOL_ERROR);\n      }\n    }\n  }, {\n    key: \"_callAvailableRoutingProcedure\",\n    value: function _callAvailableRoutingProcedure(session, database) {\n      var _this = this;\n\n      return session._run(null, null, function (connection) {\n        var query;\n        var params;\n\n        var version = _serverVersion.ServerVersion.fromString(connection.version);\n\n        if (version.compareTo(_serverVersion.VERSION_4_0_0) >= 0) {\n          query = CALL_GET_ROUTING_TABLE_MULTI_DB;\n          params = {\n            context: _this._routingContext,\n            database: database || null\n          };\n        } else {\n          query = CALL_GET_ROUTING_TABLE;\n          params = {\n            context: _this._routingContext\n          };\n        }\n\n        return connection.protocol().run(query, params, {\n          bookmark: session._lastBookmark,\n          txConfig: _txConfig[\"default\"].empty(),\n          mode: session._mode,\n          database: session._database,\n          afterComplete: session._onComplete\n        });\n      });\n    }\n  }]);\n  return RoutingUtil;\n}();\n\nexports[\"default\"] = RoutingUtil;\n\nfunction parseArray(addresses) {\n  if (!Array.isArray(addresses)) {\n    throw new TypeError('Array expected but got: ' + addresses);\n  }\n\n  return Array.from(addresses);\n}"]},"metadata":{},"sourceType":"script"}