{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _resultSummary = _interopRequireDefault(require(\"./result-summary\"));\n\nvar _connectionHolder = require(\"./internal/connection-holder\");\n\nvar _streamObservers = require(\"./internal/stream-observers\");\n/**\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar DEFAULT_ON_ERROR = function DEFAULT_ON_ERROR(error) {\n  console.log('Uncaught error when processing result: ' + error);\n};\n\nvar DEFAULT_ON_COMPLETED = function DEFAULT_ON_COMPLETED(summary) {};\n\nvar DEFAULT_METADATA_SUPPLIER = function DEFAULT_METADATA_SUPPLIER(metadata) {};\n/**\n * A stream of {@link Record} representing the result of a query.\n * Can be consumed eagerly as {@link Promise} resolved with array of records and {@link ResultSummary}\n * summary, or rejected with error that contains {@link string} code and {@link string} message.\n * Alternatively can be consumed lazily using {@link Result#subscribe} function.\n * @access public\n */\n\n\nvar Result = /*#__PURE__*/function () {\n  /**\n   * Inject the observer to be used.\n   * @constructor\n   * @access private\n   * @param {Promise<ResultStreamObserver>} streamObserverPromise\n   * @param {mixed} query - Cypher query to execute\n   * @param {Object} parameters - Map with parameters to use in query\n   * @param {ConnectionHolder} connectionHolder - to be notified when result is either fully consumed or error happened.\n   */\n  function Result(streamObserverPromise, query, parameters, connectionHolder) {\n    (0, _classCallCheck2[\"default\"])(this, Result);\n    this._stack = captureStacktrace();\n    this._streamObserverPromise = streamObserverPromise;\n    this._p = null;\n    this._query = query;\n    this._parameters = parameters || {};\n    this._connectionHolder = connectionHolder || _connectionHolder.EMPTY_CONNECTION_HOLDER;\n  }\n  /**\n   * Returns a promise for the field keys.\n   *\n   * *Should not be combined with {@link Result#subscribe} function.*\n   *\n   * @public\n   * @returns {Promise<string[]>} - Field keys, in the order they will appear in records.\n   }\n   */\n\n\n  (0, _createClass2[\"default\"])(Result, [{\n    key: \"keys\",\n    value: function keys() {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        _this._streamObserverPromise.then(function (observer) {\n          return observer.subscribe({\n            onKeys: function onKeys(keys) {\n              return resolve(keys);\n            },\n            onError: function onError(err) {\n              return reject(err);\n            }\n          });\n        });\n      });\n    }\n    /**\n     * Returns a promise for the result summary.\n     *\n     * *Should not be combined with {@link Result#subscribe} function.*\n     *\n     * @public\n     * @returns {Promise<ResultSummary>} - Result summary.\n     *\n     */\n\n  }, {\n    key: \"summary\",\n    value: function summary() {\n      var _this2 = this;\n\n      return new Promise(function (resolve, reject) {\n        _this2._streamObserverPromise.then(function (o) {\n          o.cancel();\n          o.subscribe({\n            onCompleted: function onCompleted(metadata) {\n              return resolve(metadata);\n            },\n            onError: function onError(err) {\n              return reject(err);\n            }\n          });\n        });\n      });\n    }\n    /**\n     * Create and return new Promise\n     *\n     * @private\n     * @return {Promise} new Promise.\n     */\n\n  }, {\n    key: \"_getOrCreatePromise\",\n    value: function _getOrCreatePromise() {\n      var _this3 = this;\n\n      if (!this._p) {\n        this._p = new Promise(function (resolve, reject) {\n          var records = [];\n          var observer = {\n            onNext: function onNext(record) {\n              records.push(record);\n            },\n            onCompleted: function onCompleted(summary) {\n              resolve({\n                records: records,\n                summary: summary\n              });\n            },\n            onError: function onError(error) {\n              reject(error);\n            }\n          };\n\n          _this3.subscribe(observer);\n        });\n      }\n\n      return this._p;\n    }\n    /**\n     * Waits for all results and calls the passed in function with the results.\n     *\n     * *Should not be combined with {@link Result#subscribe} function.*\n     *\n     * @param {function(result: {records:Array<Record>, summary: ResultSummary})} onFulfilled - function to be called\n     * when finished.\n     * @param {function(error: {message:string, code:string})} onRejected - function to be called upon errors.\n     * @return {Promise} promise.\n     */\n\n  }, {\n    key: \"then\",\n    value: function then(onFulfilled, onRejected) {\n      return this._getOrCreatePromise().then(onFulfilled, onRejected);\n    }\n    /**\n     * Catch errors when using promises.\n     *\n     * *Should not be combined with {@link Result#subscribe} function.*\n     *\n     * @param {function(error: Neo4jError)} onRejected - Function to be called upon errors.\n     * @return {Promise} promise.\n     */\n\n  }, {\n    key: \"catch\",\n    value: function _catch(onRejected) {\n      return this._getOrCreatePromise()[\"catch\"](onRejected);\n    }\n    /**\n     * Stream records to observer as they come in, this is a more efficient method\n     * of handling the results, and allows you to handle arbitrarily large results.\n     *\n     * @param {Object} observer - Observer object\n     * @param {function(keys: string[])} observer.onKeys - handle stream head, the field keys.\n     * @param {function(record: Record)} observer.onNext - handle records, one by one.\n     * @param {function(summary: ResultSummary)} observer.onCompleted - handle stream tail, the result summary.\n     * @param {function(error: {message:string, code:string})} observer.onError - handle errors.\n     * @return\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(observer) {\n      var _this4 = this;\n\n      var onCompletedOriginal = observer.onCompleted || DEFAULT_ON_COMPLETED;\n\n      var onCompletedWrapper = function onCompletedWrapper(metadata) {\n        // notify connection holder that the used connection is not needed any more because result has\n        // been fully consumed; call the original onCompleted callback after that\n        _this4._connectionHolder.releaseConnection().then(function () {\n          onCompletedOriginal.call(observer, new _resultSummary[\"default\"](_this4._query, _this4._parameters, metadata));\n        });\n      };\n\n      observer.onCompleted = onCompletedWrapper;\n      var onErrorOriginal = observer.onError || DEFAULT_ON_ERROR;\n\n      var onErrorWrapper = function onErrorWrapper(error) {\n        // notify connection holder that the used connection is not needed any more because error happened\n        // and result can't bee consumed any further; call the original onError callback after that\n        _this4._connectionHolder.releaseConnection().then(function () {\n          replaceStacktrace(error, _this4._stack);\n          onErrorOriginal.call(observer, error);\n        });\n      };\n\n      observer.onError = onErrorWrapper;\n\n      this._streamObserverPromise.then(function (o) {\n        return o.subscribe(observer);\n      });\n    }\n    /**\n     * Signals the stream observer that the future records should be discarded on the server.\n     *\n     * @protected\n     * @since 4.0.0\n     */\n\n  }, {\n    key: \"_cancel\",\n    value: function _cancel() {\n      this._streamObserverPromise.then(function (o) {\n        return o.cancel();\n      });\n    }\n  }]);\n  return Result;\n}();\n\nfunction captureStacktrace() {\n  var error = new Error('');\n\n  if (error.stack) {\n    return error.stack.replace(/^Error(\\n\\r)*/, ''); // we don't need the 'Error\\n' part, if only it exists\n  }\n\n  return null;\n}\n\nfunction replaceStacktrace(error, newStack) {\n  if (newStack) {\n    // Error.prototype.toString() concatenates error.name and error.message nicely\n    // then we add the rest of the stack trace\n    error.stack = error.toString() + '\\n' + newStack;\n  }\n}\n\nvar _default = Result;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["d:/webback/pro5/node_modules/neo4j-driver/lib/result.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","_classCallCheck2","_createClass2","_resultSummary","_connectionHolder","_streamObservers","DEFAULT_ON_ERROR","error","console","log","DEFAULT_ON_COMPLETED","summary","DEFAULT_METADATA_SUPPLIER","metadata","Result","streamObserverPromise","query","parameters","connectionHolder","_stack","captureStacktrace","_streamObserverPromise","_p","_query","_parameters","EMPTY_CONNECTION_HOLDER","key","keys","_this","Promise","resolve","reject","then","observer","subscribe","onKeys","onError","err","_this2","o","cancel","onCompleted","_getOrCreatePromise","_this3","records","onNext","record","push","onFulfilled","onRejected","_catch","_this4","onCompletedOriginal","onCompletedWrapper","releaseConnection","call","onErrorOriginal","onErrorWrapper","replaceStacktrace","_cancel","Error","stack","replace","newStack","toString","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _resultSummary = _interopRequireDefault(require(\"./result-summary\"));\n\nvar _connectionHolder = require(\"./internal/connection-holder\");\n\nvar _streamObservers = require(\"./internal/stream-observers\");\n\n/**\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar DEFAULT_ON_ERROR = function DEFAULT_ON_ERROR(error) {\n  console.log('Uncaught error when processing result: ' + error);\n};\n\nvar DEFAULT_ON_COMPLETED = function DEFAULT_ON_COMPLETED(summary) {};\n\nvar DEFAULT_METADATA_SUPPLIER = function DEFAULT_METADATA_SUPPLIER(metadata) {};\n/**\n * A stream of {@link Record} representing the result of a query.\n * Can be consumed eagerly as {@link Promise} resolved with array of records and {@link ResultSummary}\n * summary, or rejected with error that contains {@link string} code and {@link string} message.\n * Alternatively can be consumed lazily using {@link Result#subscribe} function.\n * @access public\n */\n\n\nvar Result =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Inject the observer to be used.\n   * @constructor\n   * @access private\n   * @param {Promise<ResultStreamObserver>} streamObserverPromise\n   * @param {mixed} query - Cypher query to execute\n   * @param {Object} parameters - Map with parameters to use in query\n   * @param {ConnectionHolder} connectionHolder - to be notified when result is either fully consumed or error happened.\n   */\n  function Result(streamObserverPromise, query, parameters, connectionHolder) {\n    (0, _classCallCheck2[\"default\"])(this, Result);\n    this._stack = captureStacktrace();\n    this._streamObserverPromise = streamObserverPromise;\n    this._p = null;\n    this._query = query;\n    this._parameters = parameters || {};\n    this._connectionHolder = connectionHolder || _connectionHolder.EMPTY_CONNECTION_HOLDER;\n  }\n  /**\n   * Returns a promise for the field keys.\n   *\n   * *Should not be combined with {@link Result#subscribe} function.*\n   *\n   * @public\n   * @returns {Promise<string[]>} - Field keys, in the order they will appear in records.\n   }\n   */\n\n\n  (0, _createClass2[\"default\"])(Result, [{\n    key: \"keys\",\n    value: function keys() {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        _this._streamObserverPromise.then(function (observer) {\n          return observer.subscribe({\n            onKeys: function onKeys(keys) {\n              return resolve(keys);\n            },\n            onError: function onError(err) {\n              return reject(err);\n            }\n          });\n        });\n      });\n    }\n    /**\n     * Returns a promise for the result summary.\n     *\n     * *Should not be combined with {@link Result#subscribe} function.*\n     *\n     * @public\n     * @returns {Promise<ResultSummary>} - Result summary.\n     *\n     */\n\n  }, {\n    key: \"summary\",\n    value: function summary() {\n      var _this2 = this;\n\n      return new Promise(function (resolve, reject) {\n        _this2._streamObserverPromise.then(function (o) {\n          o.cancel();\n          o.subscribe({\n            onCompleted: function onCompleted(metadata) {\n              return resolve(metadata);\n            },\n            onError: function onError(err) {\n              return reject(err);\n            }\n          });\n        });\n      });\n    }\n    /**\n     * Create and return new Promise\n     *\n     * @private\n     * @return {Promise} new Promise.\n     */\n\n  }, {\n    key: \"_getOrCreatePromise\",\n    value: function _getOrCreatePromise() {\n      var _this3 = this;\n\n      if (!this._p) {\n        this._p = new Promise(function (resolve, reject) {\n          var records = [];\n          var observer = {\n            onNext: function onNext(record) {\n              records.push(record);\n            },\n            onCompleted: function onCompleted(summary) {\n              resolve({\n                records: records,\n                summary: summary\n              });\n            },\n            onError: function onError(error) {\n              reject(error);\n            }\n          };\n\n          _this3.subscribe(observer);\n        });\n      }\n\n      return this._p;\n    }\n    /**\n     * Waits for all results and calls the passed in function with the results.\n     *\n     * *Should not be combined with {@link Result#subscribe} function.*\n     *\n     * @param {function(result: {records:Array<Record>, summary: ResultSummary})} onFulfilled - function to be called\n     * when finished.\n     * @param {function(error: {message:string, code:string})} onRejected - function to be called upon errors.\n     * @return {Promise} promise.\n     */\n\n  }, {\n    key: \"then\",\n    value: function then(onFulfilled, onRejected) {\n      return this._getOrCreatePromise().then(onFulfilled, onRejected);\n    }\n    /**\n     * Catch errors when using promises.\n     *\n     * *Should not be combined with {@link Result#subscribe} function.*\n     *\n     * @param {function(error: Neo4jError)} onRejected - Function to be called upon errors.\n     * @return {Promise} promise.\n     */\n\n  }, {\n    key: \"catch\",\n    value: function _catch(onRejected) {\n      return this._getOrCreatePromise()[\"catch\"](onRejected);\n    }\n    /**\n     * Stream records to observer as they come in, this is a more efficient method\n     * of handling the results, and allows you to handle arbitrarily large results.\n     *\n     * @param {Object} observer - Observer object\n     * @param {function(keys: string[])} observer.onKeys - handle stream head, the field keys.\n     * @param {function(record: Record)} observer.onNext - handle records, one by one.\n     * @param {function(summary: ResultSummary)} observer.onCompleted - handle stream tail, the result summary.\n     * @param {function(error: {message:string, code:string})} observer.onError - handle errors.\n     * @return\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(observer) {\n      var _this4 = this;\n\n      var onCompletedOriginal = observer.onCompleted || DEFAULT_ON_COMPLETED;\n\n      var onCompletedWrapper = function onCompletedWrapper(metadata) {\n        // notify connection holder that the used connection is not needed any more because result has\n        // been fully consumed; call the original onCompleted callback after that\n        _this4._connectionHolder.releaseConnection().then(function () {\n          onCompletedOriginal.call(observer, new _resultSummary[\"default\"](_this4._query, _this4._parameters, metadata));\n        });\n      };\n\n      observer.onCompleted = onCompletedWrapper;\n      var onErrorOriginal = observer.onError || DEFAULT_ON_ERROR;\n\n      var onErrorWrapper = function onErrorWrapper(error) {\n        // notify connection holder that the used connection is not needed any more because error happened\n        // and result can't bee consumed any further; call the original onError callback after that\n        _this4._connectionHolder.releaseConnection().then(function () {\n          replaceStacktrace(error, _this4._stack);\n          onErrorOriginal.call(observer, error);\n        });\n      };\n\n      observer.onError = onErrorWrapper;\n\n      this._streamObserverPromise.then(function (o) {\n        return o.subscribe(observer);\n      });\n    }\n    /**\n     * Signals the stream observer that the future records should be discarded on the server.\n     *\n     * @protected\n     * @since 4.0.0\n     */\n\n  }, {\n    key: \"_cancel\",\n    value: function _cancel() {\n      this._streamObserverPromise.then(function (o) {\n        return o.cancel();\n      });\n    }\n  }]);\n  return Result;\n}();\n\nfunction captureStacktrace() {\n  var error = new Error('');\n\n  if (error.stack) {\n    return error.stack.replace(/^Error(\\n\\r)*/, ''); // we don't need the 'Error\\n' part, if only it exists\n  }\n\n  return null;\n}\n\nfunction replaceStacktrace(error, newStack) {\n  if (newStack) {\n    // Error.prototype.toString() concatenates error.name and error.message nicely\n    // then we add the rest of the stack trace\n    error.stack = error.toString() + '\\n' + newStack;\n  }\n}\n\nvar _default = Result;\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}